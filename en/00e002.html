<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>
The documentation for TOS: MagiC PC interface
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="00e.html"><img src="udo_up.gif" alt="Emulators" title="Emulators" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00e001.html"><img src="udo_lf.gif" alt="MagiC Mac specifics" title="MagiC Mac specifics" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00e003.html"><img src="udo_rg.gif" alt="STEmulator" title="STEmulator" border="0" width="24" height="24"></a>
<hr>

<h1><a name="MagiC_20PC_20interface"></a>14.2 MagiC PC interface</h1>
<p>MagiCPC knows two interfaces with which one can call up
functions of the Windows system.</p>

<ul>
<li><p><a href="#mec0_20_28MPS_29_20interface">mec0 (MPS) interface</a>: This serves for executing any kind of
(self-written) Windows code. It is stored in a DLL and called via
illegal opcodes from within MagiC PC.</p></li>
<li><p><a href="#mec1_20interface">mec1 interface</a>: With this a predefined set of special functions
can be called.</p></li>
</ul>

<h3><a name="mec0_20_28MPS_29_20interface"></a>14.2.1 mec0 (MPS) interface</h3>
<p><u>0. General remarks</u></p>

<p>MPS = Magic_Programmier_Schnittstelle = MagiC programmer's
interface</p>

<p>Files of the demo example:</p>

<table>
<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.def">mps_base.def</a></td>
<td valign="top">The export list of the DLL, <i>DO NOT ALTER!</i></td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.h">mps_base.h</a></td>
<td valign="top">Definition of the MPS interface, <i>DO NOT ALTER!</i></td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.cpp">mps_base.cpp</a></td>
<td valign="top">Basic functions of the DLL, <i>DO NOT ALTER!</i></td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_demo.h">mps_demo.h</a></td>
<td valign="top">Definitions for the demo-DLL</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_demo.cpp">mps_demo.cpp</a></td>
<td valign="top">The MPS_functions of the demo-DLL</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#testmps.s">testmps.s</a></td>
<td valign="top">Motorola - Example for calling the MPS functions of the demo

</td></tr>
</table>

<p>To develop your own MPS_DLLs, please use mps_base.def, mps_base.h and
mps_base.cpp <i>unaltered.</i> You can alter/supplement mps_demo.h and
mps_demo.cpp. In particular, please choose your own DLL_ID in <a href="#mps_demo.h">mps_demo.h</a>
for differentiation from other MPS_DLLs.</p>

<p><u>I. Concept</u></p>

<p>Windows-side one can use dynamic link libraries (DLLs) to
establish any number of functions (called 'MPS_functions' in the
following) which can be called within MagiC PC (Motorola-side).</p>

<p>In the start-up phase MagiC PC attempts to load and start all
DLLs in the MPS subdirectory. For this MagiC PC calls three
functions to be exported from the DLL (in this order):</p>


<ol>
<li><p>mps_get_type(): Must return 0x4701!</p></li>
<li><p>mps_get_functionlist(...): Obtains DLL_ID and MPS_functions
list of the DLL.</p></li>
<li><p> mps_magicinfo: Provides information about MagiC PC's own
data and functions which the DLL may use on demand.</p></li>
</ol>

<p>All functions declared in 2) can be called via special opcodes on
the Motorola side. See part IV for more about the call.</p>

<p><u>II. Functions of the DLL to be exported ('Basic
functions')</u></p>

<p>An MPS_DLL must export exactly 3 C functions under fixed ordinal
numbers (these are also called basic functions): (see mfp_base.def,
mfp_base.cpp, mfp_base.h)</p>

<ul>
<li><p>@101: int mps_get_type()<br><br>

Purpose: Serves for reassurance that it was really MPS_DLL that
was caught. !! Return value: 0x4701 !!</p></li>
<li><p>@102: int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr
**p_funktionsliste);<br><br>

Purpose: MagiC PC wants to know DLL_ID and MPS_functionlist.<br><br>

Return values:
<br>*mps_ddl_id: DLL_ID (4 bytes, to be selected DLL-specifically!)
<br>*p_functionslist: Pointer to list of the MPS_functions.
<br>Return: 1: All OK</p></li>
<li><p>@103: void mps_magicinfo(MPS_magicinfo *is);<br><br>

Purpose: Provides information about MagiC PC's own info /
function pointers which the DLL may use:<a name="MPS_magicinfo"></a>
<pre>        typedef struct {
         DWORD sizeof_str;               // <a href="00f008.html#Size">Size</a> of MPS_magicinfo
         DWORD magic_version;            // e.g. 0x010001
         DWORD magic_date;               // e.g. 19960815  (ascending)
         BYTE  is_demo;                  // Is it a demo version?
         BYTE  uu1, uu2, uu3;            // Still unused, 0

         BYTE *(*intel_adr)(DWORD motadr);   // Convert address Motorola -> Intel
         BYTE *(*intel_ptr)(DWORD motptr);   // Convert pointer Motorola -> Intel (NULL stays NULL!)

         WORD (*swap_word)(WORD w);      // Swap one WORD
         DWORD (*swap_long)(DWORD dw);   // Swap one LONGword
         } MPS_magicinfo;
</pre>
<br><br>

The address conversions return NULL if motadr or motptr is
invalid.</p></li>
</ul>

<p><u>III. The freely definable MPS_functions of a DLL:</u></p>

<p>MPS_functions basically have the form:</p>

<p>void function_blabla( MPS_motregs *motregs )</p>

<p><i>motregs</i> here points to a list of the Motorola registers
d0-a7. The contents of the registers is already in the correct Intel
byte order. The Motorola registers may also have new values written to
them.</p>

<p>With mps_get_functionlist the DLL passes the list of addresses of
all such MPS_functions. The function numbers correspond to the
position of the function within the list. If a number is to remain
free, then its address is passed as 0xffffffff (= -1). See also
<a href="#mps_demo.cpp">mps_demo.cpp</a>.</p>

<p><u>IV. Motorola-side call</u></p>

<p>MPS_functions are called by a Motorola-side 8-byte opcode:</p>

<pre>    dc.w    $4fbf       * 2 bytes: Do not alter!
    dc.l    DLL_ID      * 4 bytes: DLL-specific DLL_ID
    dc.w    Fkt_no.     * 2 bytes: Function number
</pre>
<p>DLL_ID is the DLL_ID (4 bytes!) passed via mps_get_functionlist.
Function number is the position of the function in the function list
passed by mps_get_functionlist (count starts at 0).</p>

<p><u>V. Miscellaneous</u></p>


<ol>
<li><p>Each DLL should use an individual DLL_ID to prevent conflicts
between multiple DLLs (see <a href="#mps_demo.h">mps_demo.h</a>). DLL_IDs with bit 31 set are
reserved for us (Application Systems) or for allocated IDs. Therefore
please do not choose a DLL_ID with set bit 31! If we are to allocate a
reserved DLL_ID to you, please get in touch with Herr Hoffmann of
Application Systems Heidelberg.<br><br>

The following DLL_IDs have been allocated:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">DLL_ID</td>
  <td align="left" valign="top">Program name</td>
  <td align="left" valign="top">Author</td>
</tr>
<tr>
  <td align="left" valign="top">0x003f5c66</td>
  <td align="left" valign="top">MPCTime</td>
  <td align="left" valign="top">Robert Wei√ü</td>
</tr>
<tr>
  <td align="left" valign="top">0x2053434B</td>
  <td align="left" valign="top">MPCSTiK</td>
  <td align="left" valign="top">Dan Ackerman</td>
</tr>
<tr>
  <td align="left" valign="top">0x21342812</td>
  <td align="left" valign="top">Draconis Windows Sockets</td>
  <td align="left" valign="top"></td>
</tr>
<tr>
  <td align="left" valign="top">0x44594a01</td>
  <td align="left" valign="top">In2Cat</td>
  <td align="left" valign="top">Dimitri Junker</td>
</tr>
<tr>
  <td align="left" valign="top">0x44594a02</td>
  <td align="left" valign="top">Win_Lnk</td>
  <td align="left" valign="top">Dimitri Junker</td>
</tr>
<tr>
  <td align="left" valign="top">0x50475752</td>
  <td align="left" valign="top">MPC_POWR</td>
  <td align="left" valign="top">Emanuel Welter</td>
</tr>
</table>
</div>

</p></li>
<li><p>Pay attention to the displacement of the address space!! If you
want to use a Motorola address on the DLL side, you should call
intel_adr(..) or intel_ptr(..) respectively for conversion (see
MPS_magicinfo in <a href="#mps_base.h">mps_base.h</a>). Addresses from the DLL address space can
<i>not</i> be used Motorola-side!</p></li>
<li><p>Also pay attention to the different byte order between Motorola
and Intel processors. WORDs and LONGwords from the Motorola address
space have to be swapped so that they lie correctly in the DLL. If
anything is written back then it has to be swapped once more. For this
you can call the functions swap_word(..) or swap_long(..) (see
MPS_magicinfo in <a href="#mps_base.h">mps_base.h</a>). BUT: Elements of MPS_motregs (d0-a7) are
already in the Intel order and do not have to be swapped.</p></li>
</ol>

<h4><a name="mps_base.h"></a>14.2.1.1 mps_base.h</h4>
<pre>; ==========================================================
; Export definitions for MPS <a href="00b.html">MagiC</a> PC programmer's interface   FS 15.08.96
; ==========================================================
;
; !! DO NOT ALTER !!
; ==================
EXPORTS
   mps_get_type         @101
   mps_get_functionlist @102
   mps_magicinfo        @103
</pre>
<h4><a name="mps_base.def"></a>14.2.1.2 mps_base.def</h4>
<pre>// <a href="VT_52_terminal.html#Tab">Tab</a> size: 3

// Last change:  15.08.96
// Author:   FS

// ------------------------------------------------------------------------------
//
// The <a href="00b.html">MagiC</a> PC programmer's interface
//
// <a href="#mps_base.h">mps_base.h</a>: Basic include     !! ADOPT UNALTERED !!
//                               =====================

#ifdef __cplusplus
   extern "C" {
#endif

/* =========================================================================
   The DLL functions freely definable by the user have the form:
   void mps_function(MPS_motregs *r),
   where r represents a pointer to the 16 Motorola registers, so:
*/
   typedef struct {                 // MPS_motregs = The Motorola registers
     long d0,d1,d2,d3,d4,d5,d6,d7;
     long a0,a1,a2,a3,a4,a5,a6,a7;
     } MPS_motregs;
                                    // MPS_fuptr = Pointer to a MPS_function:
   typedef void (*MPS_fuptr)(MPS_motregs *);


/* ======================================================================
   The DLL basic function mps_info is passed the following info block
   MPS_infostr:
*/
   typedef struct {
     DWORD sizeof_str;           // <a href="00f008.html#Size">Size</a> of MPS_infostr
     DWORD magic_version;        // e.g. 0x010001
     DWORD magic_date;           // e.g. 19960815  (ascending)
     BYTE  is_demo;              // Is it a demo-version?
     BYTE  uu1, uu2, uu3;        // Still unused, 0

     BYTE *(*intel_adr)(DWORD motadr); // Convert address Motorola -> Intel
     BYTE *(*intel_ptr)(DWORD motptr); // Convert pointer Motorola -> Intel (NULL stays NULL!)

     WORD (*swap_word)(WORD w);           // Swap one WORD
     DWORD (*swap_long)(DWORD dw);        // Swap one LONGword
     } <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a>;

// =============== 3 basic functions to be exported: ==================
//
   int mps_get_type();                                                        // @@101
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_functionslist);   // @@102
   void mps_magicinfo(<a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> *is);                                     // @@103
//
// See also <a href="#mps_base.cpp">mps_base.cpp</a>, mps_base.def


#ifdef __cplusplus
   }
#endif
</pre>
<p>See also: <a href="#MagiC_20PC_20interface">MagiC PC interface</a></p>

<h4><a name="mps_base.cpp"></a>14.2.1.3 mps_base.cpp</h4>
<pre>// <a href="VT_52_terminal.html#Tab">Tab</a> size: 3

// Last change:  15.08.96
// Author:   FS

// ------------------------------------------------------------------------------
// Demo example for (!nolink [<a href="00b.html">MagiC</a>]) PC programmer's interface (MPS)
//
// Part 1: Basic functions, adopt UNCHANGED!
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "<a href="#mps_base.h">mps_base.h</a>"
#include "<a href="#mps_demo.h">mps_demo.h</a>"

//
// The following 3 basic functions must be exported by the DLL:
//


// 1) Basic function @101: Type query
// ---------------------
   int mps_get_type()
// ----------------
 {
   return(0x4701);         // Must return this value
 }

// 2) Basic function @102: <a href="00b.html">MagiC</a> PC requests ID and function list
// -----------------------
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_functionslist)
// ------------------------
 {
   *mps_dll_id = DLL_ID;              // User-defined ID, see <a href="#mps_demo.h">mps_demo.h</a>
   *p_functionslist = my_funclist;    // Enter pointer to function list
   return(1);
 }

// 3) Basic function @103: <a href="00b.html">MagiC</a> PC passes <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> to the DLL
// -----------------------
   void mps_magicinfo(<a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> *is)
// -------------
 {
   m_info = *is;                    // Remember
 }

//
// END basic functions -------------------------------------------------------
//

</pre>
<p>See also: <a href="#MagiC_20PC_20interface">MagiC PC interface</a></p>

<h4><a name="mps_demo.h"></a>14.2.1.4 mps_demo.h</h4>
<pre>// <a href="VT_52_terminal.html#Tab">Tab</a> size: 3

// Last change:  15.08.96
// Author:   FS

// ------------------------------------------------------------------------------
// Demo example for <a href="00b.html">MagiC</a> PC programmer's interface (MPS)
//
// Part 2: User-defined functions, change DLL_ID to your own value !!!
// =======
//
// ------------------------------------------------------------------------------

#define DLL_ID  0x01020304           // Change to your own value
                                     // !! Values with bit 31 set are
                                     // reserved for Appl.Systems.
                                     // ID reservation: Apply to
                                     // Appl. Systems (Herr Hoffmann)!

   extern MPS_fuptr my_funclist[];   // Function list in the demo-DLL

   extern <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> m_info;      // Is adopted by <a href="00b.html">MagiC</a> PC
</pre>
<p>See also: <a href="#MagiC_20PC_20interface">MagiC PC interface</a></p>

<h4><a name="mps_demo.cpp"></a>14.2.1.5 mps_demo.cpp</h4>
<pre>// <a href="VT_52_terminal.html#Tab">Tab</a> size: 3

// Last change:  15.08.96
// Author:   FS

// ------------------------------------------------------------------------------
// Demo example for (!nolink [<a href="00b.html">MagiC</a>]) PC programmer's interface (MPS)
//
// Parl 2: User-defined functions, freely alterable
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "<a href="#mps_base.h">mps_base.h</a>"
#include "<a href="#mps_demo.h">mps_demo.h</a>"

   <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> m_info;               // Global for the DLL

//
// List of the user-defined functions (alter/extend as required):
// ------------------------------------------------------------------
   static void demo_0(MPS_motregs *r);
   static void demo_1(MPS_motregs *r);
   static void demo_3(MPS_motregs *r);
   static void copy_string(MPS_motregs *r);

   MPS_fuptr my_funclist[] = {
     demo_0,                       // Demo function 0
     demo_1,                       // Demo function 1
     (MPS_fuptr) -1,               // -1 (i.e function No.2 not defined)
     demo_3,                       // Demo function 3
     copy_string,                  // Demo function 4
     NULL                          // !! A NULL-entry at list end !!
     } ;


// ******************************************************************
//
// Here the user-defined functions:
// ================================
//

// Demo_0 only returns the value 1 in d0:
//
   static void demo_0(MPS_motregs *r)
// ----------------------
 {
   r->d0 = 1;                       // Demo-0 sets d0 to 1
   return;
 }

// Demo_1 adds the registers d1 and d2; result to d0:
//
   static void demo_1(MPS_motregs *r)
// ----------------------
 {
   r->d0 = r->d1 + r->d2;
   return;
 }

// Demo_3 does nothing at all!
//
   static void demo_3(MPS_motregs *r)
// ----------------------
 {
   return;
 }

// Demo routine_4 copy_string copies a string to Motorola address space:
//                -----------
// a0: Destination address,
// d0: Maximum number of characters (incl. 0)
//
   static void copy_string(MPS_motregs *r)
// -----------------------
 {
   static char string[] = "This is a demo-text of copy_string(..)";

   int i, nchmax;
   char *dest;

   nchmax = (int) r->d0;
   dest = (char *) (*m_info.intel_ptr)(r->a0);
   if (nchmax<=0 || dest==NULL) return;         // Invalid?

   for (i=0; i<nchmax; i++) {
     if ((dest[i] = string[i])==0)
       return;
     }
   dest[nchmax-1] = 0;                          // Too long->truncate
   return;
 }
</pre>
<p>See also: <a href="#MagiC_20PC_20interface">MagiC PC interface</a></p>

<h4><a name="testmps.s"></a>14.2.1.6 testmps.s</h4>
<pre>
*                                                 FS  15.08.96
*
*   ===========================================================
*   Sample for the call of the MPS functions from Motorola side
*   ===========================================================
*
* Source Windows-side:
* --------------------
* <a href="#mps_base.cpp">mps_base.cpp</a>, <a href="#mps_demo.cpp">mps_demo.cpp</a>
*
mps_code .equ  $4fbf                   * !! DO NOT ALTER !!
DLL_ID   .equ  $01020304               * Enter own DLL_ID here

* -------------------------------------- 60 bytes buffer
bufsize  .equ  60
.bss
.even
buffer:   ds.w  bufsize
* --------------------------------------


*
* ------------------- Here we go: -----------------------------------
*
.text
.globl _main
_main:
      moveq    #-1,d0                  * d0 to -1 (for testing)

*     ===========================      * Call function 0 (Demo_0):
      dc.w     mps_code                * = $4fbf
      dc.l     DLL_ID                  * = Own DLL_ID
      dc.w     0                       * Function number (here 0)
*     ===========================
      cmpi.l   #1,d0                   * Should return 1
      bne      finish

* Example for call with parameters (copy_string)
* ----------------------------------
      movea.l  #buffer,a0              * Pointer to buffer for string
      move.l   #bufsize,d0             * Max. string length (incl.0-byte)

*     ===========================      * Call function 4 (copy_string):
      dc.w     mps_code                * = $4fbf
      dc.l     DLL_ID                  * = Own DLL_ID
      dc.w     4                       * Function number (here 4)
*     ===========================

      bsr      put_line                * Output line (a0)
finish:
      bsr      wait                    * Wait for keypress
      rts
*
* --------------------- END main routine _main -----------------------
*


* ------------------------ Output line (a0) --------------------------
put_line:
      moveq    #13,d0
      bsr      put_char
      moveq    #10,d0
put_lnext:
      bsr      put_char
      move.b   (a0)+,d0
      bne      put_lnext
      rts

* ------------------------ Output chatacter d0 -----------------------
put_char:
      movem.l  d0-d2/a0-a2,-(sp)
      move.w   d0,-(sp)
      move.w   #2,-(sp)
      move.w   #3,-(sp)
      trap     #13
      addq.l   #6,sp
      movem.l  (sp)+,d0-d2/a0-a2
      rts

* -------------------------- Wait for keypress -----------------------
wait:
      move.w   #2,-(sp)
      move.w   #2,-(sp)
      trap     #13
      addq.l   #4,sp
      rts

</pre>
<p>See also: <a href="#MagiC_20PC_20interface">MagiC PC interface</a></p>

<h3><a name="mec1_20interface"></a>14.2.2 mec1 interface</h3>

<ol>
<li><p>Concept<br><br>

The mec1 interface makes it possible to call functions predefined
by the emulator in Motorola code. In principle it is similar to the
<a href="#mec0_20_28MPS_29_20interface">mec0 (MPS) interface</a>, though the functions are not freely definable in
a DLL but already predefined by the emulator. Call: The functions are
called uniformly by the opcode $43bf, followed by a function number,
thus with 4 bytes total length. Example:<br><br>

dc.w $43bf,$0031<br><br>

calls the mec1 function with the number 0x31. ($43bf is the opcode
for chk <ea>,d1, with <ea> = 111111 binary, so invalid). Parameter
passing is, as with mec0, via the Motorola registers.</p></li>
<li><p>The functions<table>
<tr><td nowrap="nowrap" valign="top">$0001</td>
<td valign="top">long emu_version:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">None</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: Version number</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1: Version date</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d2: Bit0: Is it a demo-version?</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0002</td>
<td valign="top">long emu_enquire: Obtains diverse information<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">long d0: What do you want to know?</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">long d0: Value</td>
</tr>
</table>
</div>

<br><br>

bisher definiert:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">was:</td>
  <td align="left" valign="top">1: Version number</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">2: Version date</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">3: Is it a demo?</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0003</td>
<td valign="top">void emu_getexepath: Obtains the full path (including drive,
without MAGIC_PC.EXE)<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: char *bufadr (Buffer)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0: short nb_max (Max. bytecount for buffer)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0004</td>
<td valign="top">int emu_install_newvdi:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: Byte *bufadr (New contents of <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLL)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0: long nbytes  (Length)</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: >0:  <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLN sucessfully created.</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">At next runup it will be automatically</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">renamed to <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLL, as discussed.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0010</td>
<td valign="top">void dw_addline: &nbsp;! As of 03.97<br><br>

Output text in new line in the debug window<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: Pointer to the text.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0011</td>
<td valign="top">void dw_addtext: &nbsp;! As of 03.97<br><br>

Output text in debug window<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: Pointer to the text</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0011</td>
<td valign="top">void dw_formtxt: &nbsp;! As of 03.97<br><br>

Output text sprintf-like in debug window<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: Pointer to the format-string</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0, d1, ...  Additional parameters suitable</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">for the format-string. The format-string</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">corresponds roughly to sprintf(format,...);</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">string pointers are not allowed, however.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0031</td>
<td valign="top">int printer_open &nbsp;! As of 03.97<br><br>

printer_open Opens the standard printer and starts a new document<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: char *DocName (NULL-pointer allowed)</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0>0: All OK</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0<=0 Error</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0032</td>
<td valign="top">int printer_close &nbsp;! As of 03.97<br><br>

printer_close Terminates the previously opened document and closes
the printer<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">None</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0>0: All OK</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0<=0 Error</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0033</td>
<td valign="top">int printer_write &nbsp;! As of 03.97<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: Byte *pData;  // Pointer to the data buffer</td>
</tr>
<tr>
  <td align="left" valign="top"></td>
  <td align="left" valign="top">d0: long nBytes;  // No. of bytes in buffer</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: Number of bytes transferred</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0040</td>
<td valign="top">DWORD getTickCount &nbsp;! As of 03.97<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: TickCount (msec since start of the computer)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0041</td>
<td valign="top">DWORD getDrivePath &nbsp;! ab 02.99<br><br>

The function obtains the Windows path for a MagiC drive<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">d0: Drive No. (0 for A:, 1 for B:, ...)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">a0: Text buffer for the path</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1: <a href="00f008.html#Size">Size</a> of the text buffer</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: 0: Not found,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 1: Container drive,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 2: xfs drive (Windows drive)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 4: Floppy drive</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0042</td>
<td valign="top">DWORD setClipboardDir &nbsp;! ab 02.99<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">a0: char *pPath // NULL: Set to default</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0: 1</td>
</tr>
</table>
</div>

<br><br>

Beispiel:<pre>        movea.l stringadr,a0    *
        dc.w    $43bf,$0042     * mec1, call function $42
        tst.l   d0              * -1: Function not implemented
        jl  nichtimplementiert
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">$0043</td>
<td valign="top">long getMouseWheel<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">d0.l: 1: Reset position after readout</td>
</tr>
<tr>
  <td align="left" valign="top"></td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0: Don't reset position after readout</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">d0.l: Current position of the mouse-wheel</td>
</tr>
</table>
</div>

<br><br>

Beispiel:<pre>        moveq   #1,d0       * Reset position after readout
        dc.w    $43bf,$0043 * mec1, call function $43
        tst.l   d0          * Position altered since last reset
        je  no_action
        <d0.l verarbeiten>
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">$0045</td>
<td valign="top">long setCompiler &nbsp;! As of 17.06.99<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameters:</td>
  <td align="left" valign="top">d0.l: Selection; realised at present:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0 = 1: Switch compiler on/off:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = 0: Compiler off,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = 1: Compiler on</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = -1: Query mode (from my experience</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this does not work, but it ought</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to work in the 6.20 version)</td>
</tr>
<tr>
  <td align="left" valign="top">Return:</td>
  <td align="left" valign="top">Old mode (0 or 1)</td>
</tr>
</table>
</div>



</td></tr>
</table>

</p></li>
</ol>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="00e.html"><img src="udo_up.gif" alt="Emulators" title="Emulators" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00e001.html"><img src="udo_lf.gif" alt="MagiC Mac specifics" title="MagiC Mac specifics" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00e003.html"><img src="udo_rg.gif" alt="STEmulator" title="STEmulator" border="0" width="24" height="24"></a></body>
</html>

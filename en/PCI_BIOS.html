<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>
The documentation for TOS: PCI-BIOS
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00400e.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="004010.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24"></a>
<hr>

<h1><a name="PCI-BIOS"></a>4.15 PCI-BIOS</h1>
<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#fast_read_config_byte">fast_read_config_byte</a></td>
<td valign="top">Read configuration byte fast</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#fast_read_config_longword">fast_read_config_longword</a></td>
<td valign="top">Read configuration longword fast</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#fast_read_config_word">fast_read_config_word</a></td>
<td valign="top">Read configuration word fast</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#find_pci_classcode">find_pci_classcode</a></td>
<td valign="top">Find PCI class code</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#find_pci_device">find_pci_device</a></td>
<td valign="top">Find PCI device</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#get_machine_id">get_machine_id</a></td>
<td valign="top">Get machine ID</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#get_resource">get_resource</a></td>
<td valign="top">Get resource Data</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#get_routing">get_routing</a></td>
<td valign="top">Get interrupt routing options</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#hook_interrupt">hook_interrupt</a></td>
<td valign="top">Hook interrupt vector</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#read_config_byte">read_config_byte</a></td>
<td valign="top">Read configuration byte</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#read_config_longword">read_config_longword</a></td>
<td valign="top">Read configuration longword</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#read_config_word">read_config_word</a></td>
<td valign="top">Read configuration word</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#set_interrupt">set_interrupt</a></td>
<td valign="top">Set hardware interrupt</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#special_cycle">special_cycle</a></td>
<td valign="top">Generates special cycle</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#unhook_interrupt">unhook_interrupt</a></td>
<td valign="top">Unhook interrupt vector</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#write_config_byte">write_config_byte</a></td>
<td valign="top">Write configuration byte</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#write_config_longword">write_config_longword</a></td>
<td valign="top">Write configuration longword</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#write_config_word">write_config_word</a></td>
<td valign="top">Write configuration word

</td></tr>
</table>

<p>See also: <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a> &nbsp; <a href="003007.html#Cookie_2C_20_PCI">Cookie _PCI</a> &nbsp; <a href="003007.html#Cookie_2C_20XPCI">Cookie XPCI</a></p>

<h3><a name="fast_read_config_byte"></a>4.15.1 fast_read_config_byte</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration byte fast«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">305</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int8_t fast_read_config_byte (int32_t handle, uint8_t reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">device handle</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top">Register number (0,1,2,... for byte access)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS 2.0</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20fast_read_config_byte">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_byte"></a>4.15.1.1 Bindings for fast_read_config_byte</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int8_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #7,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="fast_read_config_longword"></a>4.15.2 fast_read_config_longword</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration longword fast«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">307</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t fast_read_config_longword (int32_t handle, uint8_t
reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top">Register number (0,4,8,... for longword access)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20fast_read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_longword"></a>4.15.2.1 Bindings for fast_read_config_longword</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#fast_read_config_longword">fast_read_config_longword</a> (int32_t handle, uint8_t reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #307,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #7,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="fast_read_config_word"></a>4.15.3 fast_read_config_word</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration word fast«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">306</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int16_t fast_read_config_word (int32_t handle, uint8_t reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top">Register number (0,2,4,... for Word access)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20fast_read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_word"></a>4.15.3.1 Bindings for fast_read_config_word</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#fast_read_config_word">fast_read_config_word</a> (int32_t handle, uint8_t reg);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #306,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #7,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="find_pci_classcode"></a>4.15.4 find_pci_classcode</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»find_pci_classcode« - Returns a device handle for a device
that matches the given class code.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">301</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t find_pci_classcode( int32_t classcode, int16_t index );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This functions returns a device handle for a device that
matches the given class code.<br><br>

A driver can query multiple devices with the same class code by
starting with index = 0,1,2,... and calling this function until
<a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is returned.<table>
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">classcode</td>
<td valign="top">class code in bits 23..0
<br><br><br>

Bit 23 ..16 Base class (0 - $FF)
<br>Bit 15 .. 8 Sub class (0 - $FF)
<br>Bit 7 .. 0 Programming Interface (0 - $FF)<br><br>

Mask in bits 26..24
<br>Bit 26: (0: compare base class, 1: ignore it)
<br>Bit 25: (0: compare sub class, 1: ignore it)
<br>Bit 24: (0: compare Progr. Interface, 1: ignore it)</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top">index of card (0 - number of cards with these IDs)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS V2.00</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20find_pci_classcode">Binding</a> &nbsp; <a href="#find_pci_device">find_pci_device</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_classcode"></a>4.15.4.1 Bindings for find_pci_classcode</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#find_pci_classcode">find_pci_classcode</a>( int32_t classcode, int16_t index );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    index,-(sp)       ; Offset 6
move.l    classcode,-(sp)   ; Offset 2
move.w    #301,-(sp)        ; Offset 0
trap      #14               ; Call <a href="004.html">XBIOS</a>
addq.l    #8,sp             ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="find_pci_device"></a>4.15.5 find_pci_device</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»find_pci_device« - Returns a device handle for a device that
matches the given device and vendor ID.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">300</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t find_pci_device( int32_t id, int16_t index);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This functions returns a device handle for a device that
matches the given device and vendor ID. A driver can query multiple
devices with the same device and vendor ID by starting with index =
0,1,2,... and calling this function until <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is
returned.<br><br>

As a special case, Vendor ID $FFFF can be used to query all cards
found in the system, the specified Device ID is ignored in that case.<table>
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">id</td>
<td valign="top">Device ID in bits 31..16 (0 - $FFFF)
<br>Vendor ID in bits 15..0 (0 - $FFFE)</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"><a href="indexudo.html">Index</a> of card (0 - number of cards with these IDs)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS V2.00</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20find_pci_device">Binding</a> &nbsp; <a href="#find_pci_classcode">find_pci_classcode</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_device"></a>4.15.5.1 Bindings for find_pci_device</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#find_pci_device">find_pci_device</a>( int32_t id, int16_t index);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    index,-(sp)  ; Offset 6
move.l    id,-(sp)     ; Offset 2
move.w    #300,-(sp)   ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="get_machine_id"></a>4.15.6 get_machine_id</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Get Machine ID«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">337</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t get_machine_id ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function can be used to get a unique machine ID for the
computer the driver is running on.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Machine ID, or 0 (no ID available), <a href="#PCI-BIOS">PCI-BIOS</a> error-codes<br><br>

Positive, non-zero values are machine IDs. They contain a
manufacturer code in bit 24..31 and a unique serial number which is
set by the manufacturer during production in bit 0..23.<br><br>

The following manufacturer codes are defined:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">Medusa/Hades</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">Milan</td>
</tr>
<tr>
  <td align="left" valign="top">2</td>
  <td align="left" valign="top">PAK/Panther 2</td>
</tr>
<tr>
  <td align="left" valign="top">3</td>
  <td align="left" valign="top">ARAnyM</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20get_machine_id">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_machine_id"></a>4.15.6.1 Bindings for get_machine_id</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#get_machine_id">get_machine_id</a> ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #337,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #2,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="get_resource"></a>4.15.7 get_resource</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Get Resource Data«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">316</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t get_resource ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Device handle

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Pointer to array of resource descriptors or <a href="#PCI-BIOS">PCI-BIOS</a>
error-codes.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20get_resource">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_resource"></a>4.15.7.1 Bindings for get_resource</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#get_resource">get_resource</a> ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    handle,-(sp)  ; Offset 2
move.w    #316,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="get_routing"></a>4.15.8 get_routing</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Get Interrupt Routing Options«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">314</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t get_routing ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">To be defined. Not for use by device drivers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> error-codes</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20get_routing">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_routing"></a>4.15.8.1 Bindings for get_routing</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#get_routing">get_routing</a> ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    handle,-(sp)    ; Offset 2
move.w    #314,-(sp)      ; Offset 0
trap      #14             ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="hook_interrupt"></a>4.15.9 hook_interrupt</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Hook Interrupt Vector«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">311</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t hook_interrupt (int32_t handle, uint32_t *routine,
uint32_t *parameter);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function hooks the driver into the interrupt chain to
which a specific interrupt on the given card is routed. The interrupt
is enabled on the system level, however, it is the drivers
responsibility to enable the interrupt on the card as needed.<br><br>

The driver should first hook into the interrupt chain, and then
enable the interrupt on the card, in order not to cause spurious
interrupts.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top">routine</td>
<td valign="top">Pointer to interrupt handler</td></tr>

<tr><td nowrap="nowrap" valign="top">parameter</td>
<td valign="top">Parameter for interrupt handler<br><br>

The parameter is passed to the interrupt handler unmodified - its
meaning is totally driver dependent.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20hook_interrupt">Binding</a> &nbsp; <a href="#unhook_interrupt">unhook_interrupt</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20hook_interrupt"></a>4.15.9.1 Bindings for hook_interrupt</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#hook_interrupt">hook_interrupt</a> (int32_t handle, uint32_t *routine,
uint32_t *parameter);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    parameter,-(sp) ; Offset 10
move.l    routine,-(sp)   ; Offset 6
move.l    handle,-(sp)    ; Offset 2
move.w    #311,-(sp)      ; Offset 0
trap      #14             ; Call <a href="004.html">XBIOS</a>
addq.l    #14,sp          ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="read_config_byte"></a>4.15.10 read_config_byte</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration byte«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">302</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t read_config_byte (int32_t handle, uint8_t reg, uint8_t
*address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function read data from the PCI configuration space of a
given card.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Register number (0,1,2,... for Byte access)</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top">Pointer to space for read data

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="read_config_byte.html#Bindings_20for_20read_config_byte">Binding</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_byte"></a>4.15.10.1 Bindings for read_config_byte</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg,
uint8_t *address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       address,-(sp) ; Offset 8
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #302,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #11,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="read_config_longword"></a>4.15.11 read_config_longword</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration longword«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">304</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t read_config_longword (int32_t handle, uint8_t reg,
uint32_t *address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function read data from the PCI configuration space of a
given card.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Register number (0,4,8,... for Longword access)</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top">Pointer to space for read data

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="read_config_longword.html#Bindings_20for_20read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_longword"></a>4.15.11.1 Bindings for read_config_longword</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#read_config_longword">read_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t *address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       address,-(sp) ; Offset 8
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #304,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #11,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="read_config_word"></a>4.15.12 read_config_word</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Read configuration word«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">303</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t read_config_word (int32_t handle, uint8_t reg, uint16_t
*address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function read data from the PCI configuration space of a
given card.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle of the selected PCI device</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Address of the configuration register</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top">Pointer to space for read data

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="read_config_word.html#Bindings_20for_20read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_word"></a>4.15.12.1 Bindings for read_config_word</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#read_config_word">read_config_word</a> (int32_t handle, uint8_t reg, uint16_t
*address);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       address,-(sp) ; Offset 8
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #303,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #11,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="set_interrupt"></a>4.15.13 set_interrupt</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set Hardware Interrupt«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">315</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t set_interrupt ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">To be defined. Not for use by device drivers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20set_interrupt">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20set_interrupt"></a>4.15.13.1 Bindings for set_interrupt</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#set_interrupt">set_interrupt</a> ( int32_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    handle,-(sp)    ; Offset 2
move.w    #315,-(sp)      ; Offset 0
trap      #14             ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="special_cycle"></a>4.15.14 special_cycle</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Generates special cycle«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">313</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t special_cycle ( unit8_t bus, uint32_t data );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function generates a special cycle on the PCI bus.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Bus number</td></tr>

<tr><td nowrap="nowrap" valign="top">data</td>
<td valign="top">Cspecial cycle data

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20special_cycle">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20special_cycle"></a>4.15.14.1 Bindings for special_cycle</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#special_cycle">special_cycle</a> ( unit8_t bus, uint32_t data );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    data,-(sp)    ; Offset 3
move.b    bus,-(sp)     ; Offset 2
move.w    #313,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #7,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="unhook_interrupt"></a>4.15.15 unhook_interrupt</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">» «</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">312</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t unhook_interrupt (int32_t handle);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function removes the driver from the interrupt chain to
which a specific interrupt on the given card is routed. The driver
must turn off interrupt generation on the card before calling this
function.<table>
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top">Device handle

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20unhook_interrupt">Binding</a> &nbsp; <a href="#hook_interrupt">hook_interrupt</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20unhook_interrupt"></a>4.15.15.1 Bindings for unhook_interrupt</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#unhook_interrupt">unhook_interrupt</a> (int32_t handle);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    handle,-(sp)  ; Offset 2
move.w    #312,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="write_config_byte"></a>4.15.16 write_config_byte</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Write configuration byte«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">308</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t write_config_byte (int32_t handle, uint8_t reg, uint8_t
val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function writes data to the PCI configuration space of a
given card.<br><br>

The data is in little endian format, as described in the PCI
specification.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Register number (0,1,2,... for byte access)</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top">Data to write (8 bits)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="write_config_byte.html#Bindings_20for_20write_config_byte">Binding</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_byte"></a>4.15.16.1 Bindings for write_config_byte</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#write_config_byte">write_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.b    val,-(sp)     ; Offset 7
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #308,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="write_config_longword"></a>4.15.17 write_config_longword</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Write configuration longword«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">310</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t write_config_longword (int32_t handle, uint8_t reg,
uint32_t val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function writes data to the PCI configuration space of a
given card.<br><br>

The data is in little endian format, as described in the PCI
specification.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Register number (0,4,8,... for Longword access)</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top">Data to write (32 bits)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="write_config_longword.html#Bindings_20for_20write_config_longword">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_longword"></a>4.15.17.1 Bindings for write_config_longword</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#write_config_longword">write_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    val,-(sp)     ; Offset 7
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #310,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #11,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="write_config_word"></a>4.15.18 write_config_word</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Write configuration word«</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">309</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t write_config_word (int32_t handle, uint8_t reg,
uint16_t val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function writes data to the PCI configuration space of a
given card.<br><br>

The data is in little endian format, as described in the PCI
specification.<table>
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top">Device handle</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top">Register number (0,2,4,... for Word access)</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top">Data to write (16 bits)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">PCI-BIOS</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#PCI-BIOS">PCI-BIOS</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="write_config_word.html#Bindings_20for_20write_config_word">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_word"></a>4.15.18.1 Bindings for write_config_word</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#write_config_word">write_config_word</a> (int32_t handle, uint8_t reg, uint16_t
val);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    val,-(sp)     ; Offset 7
move.b    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #309,-(sp)    ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #9,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="PCI-BIOS_20Error_20codes"></a>4.15.19 PCI-BIOS Error codes</h3>
<p>The following error codes can be returned by the PCI <a href="003.html">BIOS</a>
functions:</p>

<a name="PCI_SUCCESSFUL"></a>
<a name="PCI_FUNC_NOT_SUPPORTED"></a>
<a name="PCI_BAD_VENDOR_ID"></a>
<a name="PCI_DEVICE_NOT_FOUND"></a>
<a name="PCI_BAD_REGISTER_NUMBER"></a>
<a name="PCI_SET_FAILED"></a>
<a name="PCI_BUFFER_TOO_SMALL"></a>
<a name="PCI_GENERAL_ERROR"></a>
<a name="PCI_BAD_HANDLE"></a>

<div align="left">
<table border="1" frame="box">
<tr>
  <td align="left" valign="top">0x00000000</td>
  <td align="left" valign="top">PCI_SUCCESSFUL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFE</td>
  <td align="left" valign="top">PCI_FUNC_NOT_SUPPORTED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFD</td>
  <td align="left" valign="top">PCI_BAD_VENDOR_ID</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFC</td>
  <td align="left" valign="top">PCI_DEVICE_NOT_FOUND</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFB</td>
  <td align="left" valign="top">PCI_BAD_REGISTER_NUMBER</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFA</td>
  <td align="left" valign="top">PCI_SET_FAILED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF9</td>
  <td align="left" valign="top">PCI_BUFFER_TOO_SMALL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF8</td>
  <td align="left" valign="top">PCI_GENERAL_ERROR</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF7</td>
  <td align="left" valign="top">PCI_BAD_HANDLE</td>
</tr>
</table>
</div>

<p>The following error codes are not returned by PCI <a href="003.html">BIOS</a> functions
directly, but are reserved for use by a library which uses these
routines.</p>

<a name="PCI_BIOS_NOT_INSTALLED"></a>
<a name="PCI_BIOS_WRONG_VERSION"></a>

<div align="left">
<table border="1" frame="box">
<tr>
  <td align="left" valign="top">0xFFFFF001</td>
  <td align="left" valign="top">PCI_BIOS_NOT_INSTALLED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFF000</td>
  <td align="left" valign="top">PCI_BIOS_WRONG_VERSION</td>
</tr>
</table>
</div>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00400e.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="004010.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24"></a></body>
</html>

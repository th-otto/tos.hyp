<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>
The documentation for TOS: AES structures
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="008.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="008015.html"><img src="udo_lf.gif" alt="AES function list" title="AES function list" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="009.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24"></a>
<hr>

<h1><a name="AES_20structures"></a>8.22 AES structures</h1>
<ul class="content">
	<li>8.22.1 <a href="#ANI_MOUSE">ANI_MOUSE</a>
	</li>
	<li>8.22.2 <a href="#APPFLAGS">APPFLAGS</a>
	</li>
	<li>8.22.3 <a href="#APFLG">APFLG</a>
	</li>
	<li>8.22.4 <a href="#APPLRECORD">APPLRECORD</a>
	</li>
	<li>8.22.5 <a href="#The_20bit-block_20structure">The bit-block structure</a>
	</li>
	<li>8.22.6 <a href="#CICON">CICON</a>
	</li>
	<li>8.22.7 <a href="#CICONBLK">CICONBLK</a>
	</li>
	<li>8.22.8 <a href="#CLRCAT">CLRCAT</a>
	</li>
	<li>8.22.9 <a href="#DIALOG">DIALOG</a>
	</li>
	<li>8.22.10 <a href="#DITHER_MODE">DITHER_MODE</a>
	</li>
	<li>8.22.11 <a href="#DRV_ENTRY">DRV_ENTRY</a>
	</li>
	<li>8.22.12 <a href="#DRV_INFO">DRV_INFO</a>
	</li>
	<li>8.22.13 <a href="#EVNT">EVNT</a>
	</li>
	<li>8.22.14 <a href="#FNTS_ITEM">FNTS_ITEM</a>
	</li>
	<li>8.22.15 <a href="#FNT_DIALOG">FNT_DIALOG</a>
	</li>
	<li>8.22.16 <a href="#HNDL_OBJ">HNDL_OBJ</a>
	</li>
	<li>8.22.17 <a href="#ICONBLK">ICONBLK</a>
	</li>
	<li>8.22.18 <a href="#LBOX_ITEM">LBOX_ITEM</a>
	</li>
	<li>8.22.19 <a href="#LIST_BOX">LIST_BOX</a>
	</li>
	<li>8.22.20 <a href="#MEDIA_SIZE">MEDIA_SIZE</a>
	</li>
	<li>8.22.21 <a href="#MEDIA_TYPE">MEDIA_TYPE</a>
	</li>
	<li>8.22.22 <a href="#MENU">MENU</a>
	</li>
	<li>8.22.23 <a href="#MFORM">MFORM</a>
	</li>
	<li>8.22.24 <a href="#MN_SET">MN_SET</a>
	</li>
	<li>8.22.25 <a href="#OBJECT">OBJECT</a>
	</li>
	<li>8.22.26 <a href="#PARMBLK">PARMBLK</a>
	</li>
	<li>8.22.27 <a href="#PDLG_HNDL">PDLG_HNDL</a>
	</li>
	<li>8.22.28 <a href="#PDLG_INIT">PDLG_INIT</a>
	</li>
	<li>8.22.29 <a href="#PDLG_RESET">PDLG_RESET</a>
	</li>
	<li>8.22.30 <a href="#PDLG_SUB">PDLG_SUB</a>
	</li>
	<li>8.22.31 <a href="#POPINFO">POPINFO</a>
	</li>
	<li>8.22.32 <a href="#PRN_DIALOG">PRN_DIALOG</a>
	</li>
	<li>8.22.33 <a href="#PRN_ENTRY">PRN_ENTRY</a>
	</li>
	<li>8.22.34 <a href="#PRN_MODE">PRN_MODE</a>
	</li>
	<li>8.22.35 <a href="#PRN_SETTINGS">PRN_SETTINGS</a>
	</li>
	<li>8.22.36 <a href="#PRN_SWITCH">PRN_SWITCH</a>
	</li>
	<li>8.22.37 <a href="#PRN_TRAY">PRN_TRAY</a>
	</li>
	<li>8.22.38 <a href="#RSHDR">RSHDR</a>
	</li>
	<li>8.22.39 <a href="#RSXHDR">RSXHDR</a>
	</li>
	<li>8.22.40 <a href="#SCANX">SCANX</a>
	</li>
	<li>8.22.41 <a href="#SET_ITEM">SET_ITEM</a>
	</li>
	<li>8.22.42 <a href="#SHELTAIL">SHELTAIL</a>
	</li>
	<li>8.22.43 <a href="#SLCT_ITEM">SLCT_ITEM</a>
	</li>
	<li>8.22.44 <a href="#SWINFO">SWINFO</a>
	</li>
	<li>8.22.45 <a href="#TEDINFO">TEDINFO</a>
	</li>
	<li>8.22.46 <a href="#USERBLK">USERBLK</a>
	</li>
	<li>8.22.47 <a href="#UTXT_FN">UTXT_FN</a>
	</li>
	<li>8.22.48 <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a>
	</li>
	<li>8.22.49 <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a>
	</li>
	<li>8.22.50 <a href="#WININFO">WININFO</a>
	</li>
	<li>8.22.51 <a href="#XAESMSG">XAESMSG</a>
	</li>
	<li>8.22.52 <a href="#XDO_INF">XDO_INF</a>
	</li>
	<li>8.22.53 <a href="#XFONTINFO">XFONTINFO</a>
	</li>
	<li>8.22.54 <a href="#XFSL_FILTER">XFSL_FILTER</a>
	</li>
	<li>8.22.55 <a href="#XSHW_COMMAND">XSHW_COMMAND</a>
	</li>
	<li>8.22.56 <a href="#XTED">XTED</a>
	</li>
	<li>8.22.57 <a href="#X_BUF_V2">X_BUF_V2</a>
	</li>
</ul>

<h3><a name="ANI_MOUSE"></a>8.22.1 ANI_MOUSE</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct
{
   int16_t frames;
   int16_t delay;
   <a href="#MFORM">MFORM</a> form[32];
} ANI_MOUSE;
</pre>
<p>See also: <a href="00800c.html#graf_mouse">graf_mouse</a></p>

<h3><a name="APPFLAGS"></a>8.22.2 APPFLAGS</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct
{
   int8_t  name[13];
   int8_t  desc[17];
   <a href="#APFLG">APFLG</a>   flags;
   KEYCODE open_key;
   KEYCODE reserve_key[3];
}  APPFLAGS;
</pre>
<p>See also: <a href="Application.html#x_appl_flags">x_appl_flags</a></p>

<h3><a name="APFLG"></a>8.22.3 APFLG</h3>
<pre>typedef <a href="00f00e.html#union">union</a>
{
   struct
   {
     unsigned multitask    :1;
     unsigned special_types:1;
     unsigned round_buttons:1;
     unsigned kbd_equivs   :1;
     unsigned undo_equivs  :1;
     unsigned off_left     :1;
     unsigned exit_redraw  :1;
     unsigned AES40_msgs   :1;
     unsigned limit_handles:1;
     unsigned limit_memory :1;
     unsigned keep_deskmenu:1;
     unsigned clear_memory :1;
     unsigned maximize_wind:1;
     unsigned unused       :3;   /* Reserved for future use       */
     unsigned mem_limit    :16;  /* Kb to limit memory allocation */
   } s;
   unsigned long l;
} APFLG;
</pre>
<p>See also: <a href="Application.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APPFLAGS">APPFLAGS</a></p>

<h3><a name="APPLRECORD"></a>8.22.4 APPLRECORD</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct
{
    int32_t type;      /* Type of event                  */
    int32_t what;      /* Exact description of the event */
} APPLRECORD
</pre>
<p><b>For the components the following apply:</b></p>

<table>
<tr><td nowrap="nowrap" valign="top"><i>type</i> Meaning</td>
<td valign="top"><i>what</i></td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp; Timer event</td>
<td valign="top">Number of 50-millisecond ticks</td></tr>

<tr><td nowrap="nowrap" valign="top">1&nbsp;&nbsp; Button event</td>
<td valign="top">(high-WORD) Status of mouse buttons (0 = not depressed, 1 =
depressed):<table>
<tr><td nowrap="nowrap" valign="top">Left button:</td>
<td valign="top">0x0001</td></tr>

<tr><td nowrap="nowrap" valign="top">Right button:</td>
<td valign="top">0x0002
</td></tr>
</table>

<br>

(low-WORD) Always 1</td></tr>

<tr><td nowrap="nowrap" valign="top">2&nbsp;&nbsp; Mouse event</td>
<td valign="top">X-coordinate (high-WORD), Y-coordinate (low-WORD) of hotspot</td></tr>

<tr><td nowrap="nowrap" valign="top">3&nbsp;&nbsp; Keyboard event</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">High-Word</td>
<td valign="top">Scancode</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word</td>
<td valign="top">State of 'special' keys (0 = not depressed, 1 = depressed):<table>
<tr><td nowrap="nowrap" valign="top">Right [Shift]:</td>
<td valign="top">0x0001</td></tr>

<tr><td nowrap="nowrap" valign="top">Left [Shift]:</td>
<td valign="top">0x0002</td></tr>

<tr><td nowrap="nowrap" valign="top">[Control]:</td>
<td valign="top">0x0004</td></tr>

<tr><td nowrap="nowrap" valign="top">[Alternate]:</td>
<td valign="top">0x0008
</td></tr>
</table>


</td></tr>
</table>


</td></tr>
</table>

<p><b>Note:</b> Under PC-GEM each event occupies only 6 bytes,
as the component <i>type</i> of APPLRECORD is defined as a int16_t
there.</p>

<p>See also: <a href="Application.html#appl_tplay">appl_tplay</a> &nbsp; <a href="Application.html#appl_trecord">appl_trecord</a></p>

<h3><a name="The_20bit-block_20structure"></a>8.22.5 The bit-block structure</h3>
<a name="BITBLK"></a>
<p>A bit-image can always be used wherever a non-selectable icon
could be placed; the crucial difference is that <i>no mask</i> exists
for a bit-image. This structure is defined as follows:</p>

<pre>typedef struct
{
  int16_t  *bi_pdata;     /* Pointer to the graphics data  */
  int16_t  bi_wb;         /* Width of the image in bytes   */
  int16_t  bi_hl;         /* Height in lines               */
  int16_t  bi_x;          /* X-position, and               */
  int16_t  bi_y;          /* Y-position of top left corner */
  int16_t  bi_color;      /* Colour                        */
} BITBLK;
</pre>
<p><b>Note:</b> The width of a bit-image (component <i>bi_wb</i>)
must always be divisible by 2.</p>

<p>See also: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="008002.html#AES_20object_20types">AES object types</a></p>

<h3><a name="CICON"></a>8.22.6 CICON</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct cicon_data
{
  int16_t num_planes;   /* Number of planes for the following data    */
  int16_t *col_data;    /* Pointer to colour bitmap in standard form  */
  int16_t *col_mask;    /* Pointer to individual colour plane mask    */
  int16_t *sel_data;    /* Pointer to colour bitmap of selected icon  */
  int16_t *sel_mask;    /* Pointer to individual plane mask of the icon */
  struct cicon_data *next_res; /* Pointer to icon of other resolution */
} CICON;
</pre>
<p>See also: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#ICONBLK">ICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a></p>

<h3><a name="CICONBLK"></a>8.22.7 CICONBLK</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct cicon_blk
{
   <a href="#ICONBLK">ICONBLK</a> monoblk;    /* Default: monochrome icons            */
   <a href="#CICON">CICON</a>   *mainlist;  /* Colour icons for various resolutions */
} CICONBLK;
</pre>
<p>See also: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="008002.html#The_20object_20structure">AES object structure</a></p>

<h3><a name="CLRCAT"></a>8.22.8 CLRCAT</h3>
<pre>typedef struct clrcat
{
  int16_t cc_foreground     /* Foreground colour    */
  int16_t cc_background     /* Background colour    */
  int16_t cc_style          /* Fill style           */
  int16_t cc_pattern        /* Fill pattern         */
} CLRCAT;
</pre>
<p>The CLRCAT is used internally by ViewMAX/2 and later to store the
colour categories.</p>

<p>See also: <a href="#X_BUF_V2">X_BUF_V2</a></p>

<h3><a name="DIALOG"></a>8.22.9 DIALOG</h3>
<pre>typedef void *DIALOG;
</pre>
<h3><a name="DITHER_MODE"></a>8.22.10 DITHER_MODE</h3>
<pre>typedef struct _dither_mode
{
   struct _dither_mode  *next;    /* Pointer to successor       */
   int32_t       length;          /* Structure length           */
   int32_t       format;          /* Data format                */
   int32_t       reserved;        /* Reserved                   */
   int32_t       dither_id;       /* Dither ID                  */
   int32_t       color_modes;     /* Colour depths supported    */
   int32_t       reserved1;       /* Reserved                   */
   int32_t       reserved2;       /* Reserved                   */
   int8_t        name[32];        /* Name of the dither process */
} DITHER_MODE;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="DRV_ENTRY"></a>8.22.11 DRV_ENTRY</h3>
<pre>typedef struct _drv_entry
{
   struct _drv_entry *next; /* Pointer to successor  */
} DRV_ENTRY;
</pre>
<h3><a name="DRV_INFO"></a>8.22.12 DRV_INFO</h3>
<pre>typedef struct
{
   int32_t     magic;           /* 'pdnf'                           */
   int32_t     length;          /* Structure length                 */
   int32_t     format;          /* Data format                      */
   int32_t     reserved;        /* Reserved                         */
   int16_t     driver_id;       /* Driver number for the <a href="007.html">VDI</a>        */
   int16_t     driver_type;     /* Driver type                      */
   int32_t     reserved1;       /* Reserved                         */
   int32_t     reserved2;       /* Reserved                         */
   int32_t     reserved3;       /* Reserved                         */
   <a href="#PRN_ENTRY">PRN_ENTRY</a>   *printers;       /* List of printers belonging to    */
                                /* the driver                       */
   <a href="#DITHER_MODE">DITHER_MODE</a> *dither_modes;   /* List of dither processes         */
                                /* supported by the driver          */
   int32_t     reserved4;       /* Reserved                         */
   int32_t     reserved5;       /* Reserved                         */
   int32_t     reserved6;       /* Reserved                         */
   int32_t     reserved7;       /* Reserved                         */
   int32_t     reserved8;       /* Reserved                         */
   int32_t     reserved9;       /* Reserved                         */
   int8_t      device[128];     /* Printer driver output file       */
} DRV_INFO;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="EVNT"></a>8.22.13 EVNT</h3>
<pre>typedef struct
{
    int16_t mwhich;         /* Type of events                     */
    int16_t mx;             /* X-coordinate of the mouse pointer  */
    int16_t my;             /* Y-coordinate of the mouse pointer  */
    int16_t mbutton;        /* Pressed mouse button               */
    int16_t kstate;         /* Status of 'special' keys (kbshift) */
    int16_t key;            /* Scancode of pressed key            */
    int16_t mclicks;        /* Number of mouse clicks             */
    int16_t reserved[9];    /* Reserved                           */
    int16_t msg[16];        /* <a href="00f00a.html#Message">Message</a> buffer                     */
} EVNT;
</pre>
<p>See also: <a href="008014.html#fnts_evnt">fnts_evnt</a> &nbsp; <a href="00800a.html#fslx_evnt">fslx_evnt</a> &nbsp; <a href="008008.html#wdlg_evnt">wdlg_evnt</a></p>

<h3><a name="FNTS_ITEM"></a>8.22.14 FNTS_ITEM</h3>
<pre>typedef struct _fnts_item
{
  struct   _fnts_item  *next; /* Pointer to next font, or 0L (end of list)  */
  <a href="#UTXT_FN">UTXT_FN</a>  display;           /* Pointer to display function for user fonts */
  int32_t  id;                /* Font ID, >= 65536 for user fonts     */
  int16_t  index;             /* Must be 0, as not a <a href="007.html">VDI</a> font         */
  int8_t   mono;              /* Flag for mono-spaced font            */
  int8_t   outline;           /* Flag for vector font                 */
  int16_t  npts;              /* Number of predefined point sizes     */
  int8_t   *full_name;        /* Pointer to the complete name         */
  int8_t   *family_name;      /* Pointer to the family name           */
  int8_t   *style_name;       /* Pointer to the style name            */
  int8_t   *pts;              /* Pointer to field with point sizes    */
  int32_t  reserved[4];       /* Reserved, must be 0                  */
} FNTS_ITEM;
</pre>
<p>See also: <a href="008014.html#fnts_add">fnts_add</a> &nbsp; <a href="008014.html">Font selection</a></p>

<h3><a name="FNT_DIALOG"></a>8.22.15 FNT_DIALOG</h3>
<pre>typedef void *FNT_DIALOG;
</pre>
<h3><a name="HNDL_OBJ"></a>8.22.16 HNDL_OBJ</h3>
<pre>typedef int16_t (cdecl *HNDL_OBJ) ( void *dialog, <a href="#EVNT">EVNT</a> *events, int16_t obj,
                                 int16_t clicks, void *data );
</pre>
<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>dialog</i></td>
<td valign="top">Pointer to a dialog structure. One should not access the
structure directly; the wdlg_xx functions should be used!</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>events</i></td>
<td valign="top">If <i>obj</i> is an object number (>= 0), then <i>events</i>
points to the <a href="#EVNT">EVNT</a> structure that was passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>; otherwise
<i>events</i> is basically 0L and can not be used for addressing</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj</i></td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">>=0:</td>
<td valign="top">Object number</td></tr>

<tr><td nowrap="nowrap" valign="top"><0:</td>
<td valign="top">Function number:<pre> -1 = <a href="#HNDL_INIT">HNDL_INIT</a>    // Initialize dialog
 -2 = <a href="#HNDL_MESG">HNDL_MESG</a>    //
 -3 = <a href="#HNDL_CLSD">HNDL_CLSD</a>    // Dialog window was closed
 -5 = <a href="#HNDL_OPEN">HNDL_OPEN</a>    // Conclude dialog initialisation
 -6 = <a href="#HNDL_EDIT">HNDL_EDIT</a>    // Check character for an edit field
 -7 = <a href="#HNDL_EDDN">HNDL_EDDN</a>    // Character was set in edit field
 -8 = <a href="#HNDL_EDCH">HNDL_EDCH</a>    // Edit field was changed
 -9 = <a href="#HNDL_MOVE">HNDL_MOVE</a>    // Dialog was moved
-10 = <a href="#HNDL_TOPW">HNDL_TOPW</a>    // Dialog window was topped
-11 = <a href="#HNDL_UNTP">HNDL_UNTP</a>    // Dialog window is not active
</pre>

</td></tr>
</table>

<br>

Of these function numbers one only has to react to <a href="#HNDL_CLSD">HNDL_CLSD</a>; all
other events need only be paid attention to when needed</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>clicks</i></td>
<td valign="top">Number of mouse clicks (if <i>obj</i> is an object number).</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>data</i></td>
<td valign="top">If the parameter <i>obj</i> is a positive object number, then
the variable <i>user_data</i> from the <a href="008008.html#wdlg_create">wdlg_create</a> function will be
passed here; otherwise the value depends on the corresponding function
number

</td></tr>
</table>

<p><b>Note:</b> The function is called when an <a href="008002.html#EXIT">EXIT</a> or <a href="008002.html#TOUCHEXIT">TOUCHEXIT</a>
object has been clicked on (in this case <i>obj</i> is a positive
object number) or when an event pertinent to the dialog has occurred
(in that case <i>obj</i> is negative and contains a corresponding
function number (see above)).</p>

<p>The parameters are passed via the stack and the routine may alter
registers d0-d2/a0-a2. If the function is called with an unknown
function number in <i>obj</i>, or one of the above function numbers
is to be ignored, the value 1 must be returned.</p>

<p>See also: <a href="#Example_20for_20HNDL_OBJ">Sample implementation</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="Example_20for_20HNDL_OBJ"></a>8.22.16.1 Example for HNDL_OBJ</h4>
<pre>/* The following code is an example for an implementation of the
   handle_exit function, such as that used as a parameter for
   <a href="008008.html#wdlg_create">wdlg_create</a>, for instance. */

int16_t cdecl handle_exit( void *dialog, <a href="#EVNT">EVNT</a> *events, int16_t obj,
                         int16_t clicks, void *data )
{
    /*
     * Event or object number?
     * All events except <a href="#HNDL_CLSD">HNDL_CLSD</a> are ignored in this example
     */

    if( obj < 0 )
    {
        if( obj == <a href="#HNDL_CLSD">HNDL_CLSD</a> )     /* Closer activated? */
            return( 0 );            /* Finish */
        if( obj == <a href="#HNDL_EDIT">HNDL_EDIT</a> )
        {
                 /* In window-dialogs it may be useful to ignore key
                 combinations with [Control] in input fields, so that
                 keyboard shortcuts such as [Ctrl]-[U], [Ctrl]-[W] or
                 [Ctrl]-[Q] for instance may be evaluated in the event
                 loops of a program. In that case a 0 should be
                 returned after <a href="#HNDL_EDIT">HNDL_EDIT</a> so that the key is not
                 evaluated by <a href="008010.html#objc_edit">objc_edit</a>.
                 */
        }
    }
    else
    {                         /* An object has been selected */
        switch( obj )         /* Initiate action (if needed) */
        {
            case ...
              .
              .
              .
            case MY_<a href="008002.html#EXIT">EXIT</a>_<a href="#OBJECT">OBJECT</a>:    ..... return( 0 );  /* Finish */
        }
    }
    return( 1 ); /* Continue */
}
</pre>
<h4><a name="HNDL_INIT"></a>8.22.16.2 HNDL_INIT</h4>
<p><i>data</i> is the variable passed by <a href="008008.html#wdlg_create">wdlg_create</a>.</p>

<p>If <i>handle_exit</i> returns 0, <a href="008008.html#wdlg_create">wdlg_create</a> does not create a
dialog structure (error).</p>

<p>The variable <i>code</i> is passed in <i>clicks.</i></p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_MESG"></a>8.22.16.3 HNDL_MESG</h4>
<p><i>data</i> is <i>user_data.</i></p>

<p>If <i>handle_exit</i> returns 0, the dialog will be closed -
<a href="008008.html#wdlg_evnt">wdlg_evnt</a> returns 0.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>HNDL_MESG is only passed if a message code between 20 and 39 was
received that is not processed by other opcodes. Is required for
iconification, for instance.</p>

<p><b>Warning:</b> This opcode is only present from <a href="00b.html">MagiC</a> 4.5 of
18.4.96</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_OPEN"></a>8.22.16.4 HNDL_OPEN</h4>
<p><i>data</i> is the variable passed by <a href="008008.html#wdlg_open">wdlg_open</a>.</p>

<p>The variable <i>code</i> is passed in <i>clicks.</i></p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_CLSD"></a>8.22.16.5 HNDL_CLSD</h4>
<p><i>data</i> is <i>user_data.</i></p>

<p>If <i>handle_exit</i> returns 0, the dialog will be closed -
<a href="008008.html#wdlg_evnt">wdlg_evnt</a> returns 0.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_MOVE"></a>8.22.16.6 HNDL_MOVE</h4>
<p><i>data</i> is <i>user_data.</i></p>

<p>If <i>handle_exit</i> returns 0, the dialog will be closed -
<a href="008008.html#wdlg_evnt">wdlg_evnt</a> returns 0.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_TOPW"></a>8.22.16.7 HNDL_TOPW</h4>
<p><i>data</i> is <i>user_data.</i></p>

<p>If <i>handle_exit</i> returns 0, the dialog will be closed -
<a href="008008.html#wdlg_evnt">wdlg_evnt</a> returns 0.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_UNTP"></a>8.22.16.8 HNDL_UNTP</h4>
<p><i>data</i> is <i>user_data.</i></p>

<p>If <i>handle_exit</i> returns 0, the dialog will be closed -
<a href="008008.html#wdlg_evnt">wdlg_evnt</a> returns 0.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDIT"></a>8.22.16.9 HNDL_EDIT</h4>
<p><i>data</i> points to a WORD with the key-code.</p>

<p>If <i>handle_exit</i> returns 1, the key press will be evaluated,
if the return value is 0 it will be ignored.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDDN"></a>8.22.16.10 HNDL_EDDN</h4>
<p><i>data</i> points to a WORD with the key-code.</p>

<p><i>events</i> points to the <a href="#EVNT">EVNT</a> structure passed by <a href="008008.html#wdlg_evnt">wdlg_evnt</a>.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDCH"></a>8.22.16.11 HNDL_EDCH</h4>
<p><i>data</i> points to a WORD with the object number of the new
editable field.</p>

<p>See also: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h3><a name="ICONBLK"></a>8.22.17 ICONBLK</h3>
<pre>typedef struct
{
  uint16_t  *ib_pmask;    /* Pointer to the icon mask           */
  uint16_t  *ib_pdata;    /* Pointer to the icon image          */
  int8_t    *ib_ptext;    /* Pointer to the icon text           */
  uint16_t  ib_char;      /* Character that is to appear in the
                             icon, as well as the foreground
                             and background colour of the Icon  */
  uint16_t  ib_xchar;     /* X-coordinate of the character      */
  uint16_t  ib_ychar;     /* Y-coordinate of the character      */
  uint16_t  ib_xicon;     /* X-coordinate of the icon           */
  uint16_t  ib_yicon;     /* Y-coordinate of the icon           */
  uint16_t  ib_wicon;     /* Width of the icon                  */
  uint16_t  ib_hicon;     /* Height of the icon                 */
  int16_t   ib_xtext;     /* X-coordinate of the text           */
  int16_t   ib_ytext;     /* Y-coordinate of the text           */
  uint16_t  ib_wtext;     /* Width of the text                  */
  uint16_t  ib_htext;     /* Height of the text                 */
  uint16_t  ib_resvd;     /* Reserved                           */
} ICONBLK;
</pre>
<p><b>Notes about individual components:</b></p>

<ul>
<li><p><i>ib_pmask:</i> Pointer to a field of 16-bit values in which
the bit-image of the icon mask is stored. The icon mask determines at
which positions the icon is to be drawn, and which pixels are to
remain transparent. This effect is achieved by first ANDing the icon
background with the bits of the mask and then ORing this with the icon
data.</p></li>
<li><p><b>ib_char:</b><br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Bits</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">15..12</td>
  <td align="left" valign="top">Foreground colour of the icon</td>
</tr>
<tr>
  <td align="left" valign="top">11..08</td>
  <td align="left" valign="top">Background colour of the icon</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;7..&nbsp;0</td>
  <td align="left" valign="top">Character that is to appear in icon</td>
</tr>
</table>
</div>

</p></li>
<li><p><i>ib_resvd:</i> Unused, though it is recorded by most RCS
(<b>R</b>esource <b>C</b>onstruction <b>S</b>et) programs when
writing to the resource file.</p></li>
</ul>

<p>For a colour icon under PC-GEM the following applies: In a
colour icon, <i>ib_pdata</i> and <i>ib_pmask</i> point to <a href="00700d.html#MFDB">MFDB</a>
objects. Otherwise, they point to the lines of the bitmap.</p>

<p>See also: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a></p>

<h3><a name="LBOX_ITEM"></a>8.22.18 LBOX_ITEM</h3>
<pre>typedef struct _lbox_item
{
   struct _lbox_item *next;  /* Pointer to the next entry in the list    */
   int16_t  selected;        /* Specifies whether the object is selected */
   int16_t  data1;           /* Data for the program...                  */
   void     *data2;
   void     *data3;
} LBOX_ITEM;
</pre>
<p>However the structure can well look like the following example
with appropriate casting during the call:</p>

<pre>typedef struct
{
   void     *next;
   int16_t   selected;

   ... From here on to suit the application ...
} LB_EXAMPLE;
</pre>
<p>One only has to ensure that as the first element a pointer to the
successor, and as the second element a WORD specifying whether the
corresponding entry is selected are present.</p>

<p>See also:
<br><a href="00800e.html#lbox_create">lbox_create</a> &nbsp; <a href="00800e.html#lbox_free_list">lbox_free_list</a> &nbsp; <a href="00800e.html#lbox_get_idx">lbox_get_idx</a> &nbsp; <a href="00800e.html#lbox_get_item">lbox_get_item</a> &nbsp;
<a href="00800e.html#lbox_get_items">lbox_get_items</a></p>

<h3><a name="LIST_BOX"></a>8.22.19 LIST_BOX</h3>
<pre>typedef void *LIST_BOX;
</pre>
<h3><a name="MEDIA_SIZE"></a>8.22.20 MEDIA_SIZE</h3>
<p>Description of a paper format.</p>

<pre>typedef struct _media_size
{
   struct _media_size *next;   /* Pointer to successor      */
   int32_t       size_id;      /* <a href="VT_52_terminal.html#Paper">Paper</a> format size ID      */
   int8_t        name[32];     /* Name of the paper format  */
} MEDIA_SIZE;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="MEDIA_TYPE"></a>8.22.21 MEDIA_TYPE</h3>
<p>Description of a paper type/print medium.</p>

<pre>typedef struct _media_type
{
   struct _media_type   *next;    /* Pointer to successor      */
   int32_t              type_id;  /* <a href="VT_52_terminal.html#Paper">Paper</a> format type ID      */
   int8_t               name[32]; /* Name of the paper format  */
} MEDIA_TYPE;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="MENU"></a>8.22.22 MENU</h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *mn_tree;    /* The object tree of the menu             */
    int16_t mn_menu;     /* The parent object of the menu items     */
    int16_t mn_item;     /* The starting menu item                  */
    int16_t mn_scroll;   /* The scroll field status of the menu:    */
                         /*  0  - The menu will not scroll          */
                         /*  >0 - The menu will scroll              */
    int16_t mn_keystate; /* The [CTRL], [ALT], [SHIFT] key state at */
                         /* the time the mouse button was pressed   */
} MENU;
</pre>
<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="00800f.html#menu_attach">menu_attach</a> &nbsp; <a href="00800f.html#menu_popup">menu_popup</a></p>

<h3><a name="MFORM"></a>8.22.23 MFORM</h3>
<p>The structure MFORM sets the appearance of the mouse pointer, and
is defined as follows:</p>

<pre>typedef struct mfstr
{
    int16_t  mf_xhot;       /* X-position <a href="007007.html#hot-spot">hot-spot</a> */
    int16_t  mf_yhot;       /* Y-position <a href="007007.html#hot-spot">hot-spot</a> */
    int16_t  mf_nplanes;    /* Number of planes    */
    int16_t  mf_fg;         /* Mask colour         */
    int16_t  mf_bg;         /* Pointer colour      */
    int16_t  mf_mask[16];   /* Mask form           */
    int16_t  mf_data[16];   /* Pointer form        */
} MFORM;
</pre>
<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="00800c.html#graf_mouse">graf_mouse</a></p>

<h3><a name="MN_SET"></a>8.22.24 MN_SET</h3>
<pre>typedef struct
{
    int32_t display;    /* Submenu display delay          */
    int32_t drag;       /* Submenu drag delay             */
    int32_t delay;      /* <a href="00a002.html#Single-click">Single-click</a> scroll delay      */
    int32_t speed;      /* Continuous scroll delay        */
    int16_t height;     /* Menu scroll height (in items)  */
} MN_SET;
</pre>
<p>The delay values are measured in milliseconds.</p>

<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="00800f.html#menu_settings">menu_settings</a></p>

<h3><a name="OBJECT"></a>8.22.25 OBJECT</h3>
<pre>typedef struct
{
   int16_t    ob_next;   /* The next object               */
   int16_t    ob_head;   /* First child                   */
   int16_t    ob_tail;   /* Last child                    */
   uint16_t   ob_type;   /* Object type                   */
   uint16_t   ob_flags;  /* Manipulation flags            */
   uint16_t   ob_state;  /* Object status                 */
   void       *ob_spec;  /* More under object type        */
   int16_t    ob_x;      /* X-coordinate of the object    */
   int16_t    ob_y;      /* Y-coordinate of the object    */
   int16_t    ob_width;  /* Width of the object           */
   int16_t    ob_height; /* Height of the object          */
} OBJECT;
</pre>
<table>
<tr><td nowrap="nowrap" valign="top"><i>ob_next:</i></td>
<td valign="top">Number of the following object of the same generation or - if
it is the last element of the generation - of the parent object</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>ob_head:</i></td>
<td valign="top">Number of the first child of the object, if none -1</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>ob_next:</i></td>
<td valign="top">Number of the last child of the object, if none -1</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>ob_type:</i></td>
<td valign="top"> Object type of the AES</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>ob_flags:</i></td>
<td valign="top"> Object flags of the AES</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>ob_state:</i></td>
<td valign="top"> AES object stati

</td></tr>
</table>

<p>See also: <a href="008002.html#The_20object_20structure">AES object structure</a></p>

<h3><a name="PARMBLK"></a>8.22.26 PARMBLK</h3>
<pre>typedef struct
{
   <a href="#OBJECT">OBJECT</a>   *pb_tree;        /* Pointer to the object tree         */
   int16_t  pb_obj;          /* <a href="indexudo.html">Index</a> of the object                */
   int16_t  pb_prevstate;    /* Previous object status             */
   int16_t  pb_currstate;    /* New object status                  */
   int16_t  pb_x;            /* X-position of the object           */
   int16_t  pb_y;            /* Y-position of the object           */
   int16_t  pb_w;            /* Width of the object                */
   int16_t  pb_h;            /* Height of the object               */
   int16_t  pb_xc;           /* X-position of the clipping region  */
   int16_t  pb_yc;           /* Y-position of the clipping region  */
   int16_t  pb_wc;           /* Width of the clipping region       */
   int16_t  pb_hc;           /* Height of the clipping region      */
   int32_t  pb_parm;         /* Parameter of <a href="#USERBLK">USERBLK</a> structure     */
} PARMBLK;
</pre>
<p><b>Note:</b> The object only needs to be redrawn if the old and
new states are identical; otherwise an 'update' of the object tree
suffices. Furthermore, the following points should be respected:</p>

<ul>
<li><p> A private function must return to the AES in data register
d0 which aspects of the object status still have to be updated. With
this it is not absolutely necessary to program out the code for
inverting the object in a private output function. Generally one would
want to process some bits of the object status oneself, and leave
others to the AES.</p></li>
<li><p> The function receives the PARMBLK pointer on the stack, and
hence must be declared in Pure-C as 'cdecl'.</p></li>
<li><p> A complete redraw of the object is required only if the compo
nents <i>pb_prevstate</i> and <i>pb_currstate</i> are identical;
otherwise only the obects status has changed (for example by being
clicked on).</p></li>
<li><p> A private function is executed de facto as a sub-program of
the AES, hence one should take care with regard to stack usage.
Furthermore, one can of course make <i>no</i> further AES calls,
since the AES is <i>not</i> re-entrant. On the other hand, calls
of the VDI input functions are permitted here.</p></li>
<li><p> The component <i>pb_parm</i> serves to pass to one's private
function further information (such as a pointer to a string, perhaps).</p></li>
<li><p> One should not stray too far from the original appearance of
GEM. Rounded rectangles or italic texts certainly do not match the
normal appearance of a GEM application.</p></li>
</ul>

<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="#USERBLK">USERBLK</a></p>

<h3><a name="PDLG_HNDL"></a>8.22.27 PDLG_HNDL</h3>
<pre>typedef int32_t (cdecl *PDLG_HNDL)( struct _prn_settings *settings,
                                 struct _pdlg_sub *sub,
                                 int16_t exit_obj );
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_INIT"></a>8.22.28 PDLG_INIT</h3>
<pre>typedef int32_t (cdecl *PDLG_INIT) (struct _prn_settings *settings,
                                 struct _pdlg_sub *sub );
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_RESET"></a>8.22.29 PDLG_RESET</h3>
<pre>typedef int32_t (cdecl *PDLG_RESET) ( struct _prn_settings *settings,
                                   struct _pdlg_sub *sub );
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_SUB"></a>8.22.30 PDLG_SUB</h3>
<p>Sub-dialog for setting device.</p>

<pre>typedef struct _pdlg_sub
{
   struct _pdlg_sub *next;      /* Pointer to successor in the list */
   int32_t     length;          /* Structure length                 */
   int32_t     format;          /* Data format                      */
   int32_t     reserved;        /* Reserved                         */
   void        *drivers;        /* Only for internal dialogs        */
   int16_t     option_flags;    /* Flags                            */
   int16_t     sub_id;          /* Sub-dialog ID                    */
   <a href="#DIALOG">DIALOG</a>      *dialog;         /* Pointer to structure of window
                                   dialog, or 0L                    */
   <a href="#OBJECT">OBJECT</a>      *tree;           /* Pointer to assembled object tree */
   int16_t     index_offset;    /* <a href="indexudo.html">Index</a> offset of the sub-dialog   */
   int16_t     reserved1;       /* Reserved                         */
   int32_t     reserved2;       /* Reserved                         */
   int32_t     reserved3;       /* Reserved                         */
   int32_t     reserved4;       /* Reserved                         */
   <a href="#PDLG_INIT">PDLG_INIT</a>   init_dlg;        /* Initialisation function          */
   <a href="#PDLG_HNDL">PDLG_HNDL</a>   do_dlg;          /* Handling function                */
   <a href="#PDLG_RESET">PDLG_RESET</a>  reset_dlg;       /* Reset function                   */
   int32_t     reserved5;       /* Reserved                         */
   <a href="#OBJECT">OBJECT</a>      *sub_icon;       /* Pointer to icon for the list box */
   <a href="#OBJECT">OBJECT</a>      *sub_tree;       /* Pointer to object tree of sub-dialog */
   int32_t     reserved6;       /* Reserved                         */
   int32_t     reserved7;       /* Reserved                         */
   int32_t     private1;        /* Dialog's private information 1   */
   int32_t     private2;        /* Dialog's private information 2   */
   int32_t     private3;        /* Dialog's private information 3   */
   int32_t     private4;        /* Dialog's private information 4   */
} PDLG_SUB;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a></p>

<h3><a name="POPINFO"></a>8.22.31 POPINFO</h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *tree;     /* <a href="009001.html#Popup">Popup</a> menu               */
    int16_t  obnum;    /* Current object of <tree> */
} POPINFO;
</pre>
<p><b>Note:</b> The component <i>tree</i> points to an object tree
which might serve as input for <a href="00800b.html#form_popup">form_popup</a>, for instance. This means
that the box should contain as object 0 a <a href="008002.html#G_BOX">G_BOX</a> or <a href="008002.html#G_IBOX">G_IBOX</a> which is
covered completely by the other objects. Objects that are not
selectable should be assigned a <a href="008002.html#DISABLED">DISABLED</a> state, as in a dropdown menu.</p>

<p>All selectable objects must have the state <a href="008002.html#SELECTABLE">SELECTABLE</a>. In
addition, for using with G_POPUP, all selectable objects must be of
the type <a href="008002.html#G_STRING">G_STRING</a> (or <a href="008002.html#G_SHORTCUT">G_SHORTCUT</a>) or <a href="008002.html#G_BUTTON">G_BUTTON</a>, and start with two
spaces, the latter due to the tick that is set automatically by
<a href="00800b.html#form_button">form_button</a> or <a href="00800b.html#form_do">form_do</a>!</p>

<p>It is important that <i>ob_x</i> and <i>ob_y</i> of object 0 of
the menu is specified relative to the G_POPUP object, i.e. usually
they will both be 0. It is recommended that a shadow or a frame of
width -1 is specified.</p>

<p>See also: <a href="00b.html">MagiC</a> &nbsp; <a href="008002.html#G_POPUP">G_POPUP</a></p>

<h3><a name="PRN_DIALOG"></a>8.22.32 PRN_DIALOG</h3>
<pre>typedef void *PRN_DIALOG;
</pre>
<h3><a name="PRN_ENTRY"></a>8.22.33 PRN_ENTRY</h3>
<pre>typedef struct _prn_entry
{
   struct _prn_entry *next;          /* Pointer to next device description*/
   int32_t     length;               /* Structure length                  */
   int32_t     format;               /* Data format                       */
   int32_t     reserved;             /* Reserved                          */
   int16_t     driver_id;            /* Driver ID                         */
   int16_t     driver_type;          /* Driver type                       */
   int32_t     printer_id;           /* Printer ID                        */
   int32_t     printer_capabilities; /* Printer capabilities              */
   int32_t     reserved1;            /* Reserved                          */
   int32_t     flags;                /* Various flags                     */
   struct _pdlg_sub  *sub_dialogs;   /* Pointer to list of sub-dialogs    */
                                     /* for this printer                  */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  setup_panel;          /* Initialize sub-dialog at printer  */
                                     /* change                            */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  close_panel;          /* Close sub-dialog at printer change*/
   <a href="#PRN_MODE">PRN_MODE</a>    *modes;               /* List of available resolutions     */
   <a href="#MEDIA_SIZE">MEDIA_SIZE</a>  *papers;              /* List of available paper formats   */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *input_trays;         /* List of feed trays                */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *output_trays;        /* List of output trays              */
   int8_t      name[32];             /* Name of the printer               */
} PRN_ENTRY;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_MODE"></a>8.22.34 PRN_MODE</h3>
<p>Description of a print mode.</p>

<pre>typedef struct _prn_mode
{
   struct _prn_mode *next;         /* Pointer to the next print mode  */
   int32_t     mode_id;            /* Mode ID (index within the file) */
   int16_t     hdpi;               /* Horizontal resolution in dpi    */
   int16_t     vdpi;               /* Vertical resolution in dpi      */
   int32_t     mode_capabilities;  /* Mode capabilities               */
   int32_t     color_capabilities; /* Colour capabilities             */
   int32_t     dither_flags;       /* Flags specifying whether the
                                      corresponding colour mode is
                                      accessible with or without
                                      dithering                        */
   <a href="#MEDIA_TYPE">MEDIA_TYPE</a>  *paper_types;       /* Suitable paper types             */
   int32_t     reserved;           /* Reserved                         */
   int8_t      name[32];           /* Mode name                        */
} PRN_MODE;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_SETTINGS"></a>8.22.35 PRN_SETTINGS</h3>
<pre>typedef struct _prn_settings
{
   int32_t  magic;            /* 'pset'                              */
   int32_t  length;           /* (+) Structure length                */
   int32_t  format;           /* Structure type                      */
   int32_t  reserved;         /* Reserved                            */
   int32_t  page_flags;       /* (+) Flags, inc. even/odd pages:
                                  0x0001 = Only pages with even number
                                  0x0002 = Only pages with odd number*/
   int16_t  first_page;       /* (+) First page to print (min. 1)    */
   int16_t  last_page;        /* (+) Last page to print (max. 9999)  */
   int16_t  no_copies;        /* (+) Number of copies                */
   int16_t  orientation;      /* (+) Page orientation:
                                  0x0000 =  Orientation unknown and
                                            not adjustable
                                  0x0001 = Output in portrait format
                                  0x0002 = Output in landscape format*/
   int32_t  scale;            /* (+) Scaling: 0x10000L = 100%        */
   int16_t  driver_id;        /* (+) <a href="Application.html#VDI_20device_20number">VDI device number</a>               */
   int16_t  driver_type;      /* Type of the selected driver         */
   int32_t  driver_mode;      /* Flags, inc. for background printing */
   int32_t  reserved1;        /* Reserved                            */
   int32_t  reserved2;        /* Reserved                            */
   int32_t  printer_id;       /* Printer ID number                   */
   int32_t  mode_id;          /* Mode ID number                      */
   int16_t  mode_hdpi;        /* Horizontal resolution in dpi        */
   int16_t  mode_vdpi;        /* Vertical resolution in dpi          */
   int32_t  quality_id;       /* Printing mode (hardware-dependent
                                 quality, e.g. Microweave or Econofast)*/
   int32_t  color_mode;       /* Colour mode                         */
   int32_t  plane_flags;      /* Flags for colour planes to be output
                                 (e.g. cyan only)                    */
   int32_t  dither_mode;      /* Rasterizing (dithering) process     */
   int32_t  dither_value;     /* Parameter for the dithering process */
   int32_t  size_id;          /* <a href="VT_52_terminal.html#Paper">Paper</a> format                        */
   int32_t  type_id;          /* <a href="VT_52_terminal.html#Paper">Paper</a> type (normal, glossy)         */
   int32_t  input_id;         /* <a href="VT_52_terminal.html#Paper">Paper</a> feed tray                     */
   int32_t  output_id;        /* <a href="VT_52_terminal.html#Paper">Paper</a> output tray                   */
   int32_t  contrast;         /* Contrast:   0x10000L = normal       */
   int32_t  brightness;       /* Brightness: 0x1000L  = normal       */
   int32_t  reserved3;        /* Reserved                            */
   int32_t  reserved4;        /* Reserved                            */
   int32_t  reserved5;        /* Reserved                            */
   int32_t  reserved6;        /* Reserved                            */
   int32_t  reserved7;        /* Reserved                            */
   int32_t  reserved8;        /* Reserved                            */
   int8_t   device[128];      /* Filename for the printout           */
   #ifdef __PRINTING__
   TPrint   mac_settings;     /* Setting of the Mac printer driver   */
   #else
   struct
   {
      uint8_t inside[120];
   } mac_settings;
   #endif
} PRN_SETTINGS;
</pre>
<p><b>Note:</b> The structure elements marked with (+) can be read
out by the application. All other entries should <i>not</i> be
accessed. Data such as the printer resolution or number of colours
should <i>not</i> be taken from the setting structure, but inquired
for from the printer at the start of the printout (it would be
possible, for instance, that due to a memory shortage the printer
driver is forced to use a lower resolution compared to that entered in
PRN_SETTINGS).</p>

<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_open">pdlg_open</a></p>

<h3><a name="PRN_SWITCH"></a>8.22.36 PRN_SWITCH</h3>
<pre>typedef int32_t (cdecl *PRN_SWITCH) ( struct _drv_entr *drivers,
                                   struct _prn_settings *settings,
                                   struct _prn_entry *old_printer,
                                   struct _prn_entry *new_printer );
</pre>
<p><b>Note:</b> The component <i>old_printer</i> can also be 0L!</p>

<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_TRAY"></a>8.22.37 PRN_TRAY</h3>
<p>Description of a feed/output tray.</p>

<pre>typedef struct _prn_tray
{
   struct _prn_tray  *next;    /* Pointer to successor              */
   int32_t           tray_id;  /* Number of the feed or output tray */
   int8_t            name[32]; /* Name of the tray                  */
} PRN_TRAY;
</pre>
<p>See also: <a href="008005.html">Print dialogs</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="RSHDR"></a>8.22.38 RSHDR</h3>
<a name="Resource_20header"></a>
<a name="Header_20of_20a_20Resource_20file"></a>
<pre>typedef struct
{
   uint16_t rsh_vrsn;      /* Null                              */
   uint16_t rsh_object;    /* Position of the object field      */
   uint16_t rsh_tedinfo;   /* Position of the <a href="#TEDINFO">TEDINFO</a> structs   */
   uint16_t rsh_iconblk;   /* Position of the <a href="#ICONBLK">ICONBLK</a> structs   */
   uint16_t rsh_bitblk;    /* Position of the <a href="008016.html#BITBLK">BITBLK</a> structs    */
   uint16_t rsh_frstr;     /* Position of the free strings      */
   uint16_t rsh_string;    /* Unused                            */
   uint16_t rsh_imdata;    /* Position of image data            */
   uint16_t rsh_frimg;     /* Position of the free images       */
   uint16_t rsh_trindex;   /* Position of the object tree table */
   uint16_t rsh_nobs;      /* Total number of objects           */
   uint16_t rsh_ntree;     /* Total number of trees             */
   uint16_t rsh_nted;      /* Total number of <a href="#TEDINFO">TEDINFO</a> structs   */
   uint16_t rsh_nib;       /* Total number of <a href="#ICONBLK">ICONBLK</a> structs   */
   uint16_t rsh_nbb;       /* Total number of <a href="008016.html#BITBLK">BITBLK</a> structs    */
   uint16_t rsh_nstring;   /* Total number of strings           */
   uint16_t rsh_nimages;   /* Total number of images            */
   uint16_t rsh_rssize;    /* Total bytes in resource           */
} RSHDR;
</pre>
<p><b>Note:</b> All position specifications are to be understood as
relative to the start of the file.</p>

<p>A word about the 'free strings': These include not just the
character strings containing the data for alert boxes etc., but also
all other strings that a program uses for its work. An example of this
would be the filename or a file to be read in, or an entry that is
altered with <a href="00800f.html#menu_text">menu_text</a> in a menu.</p>

<a name="Resource_20files_2C_20size_20of"></a>
<p>This header is followed by the actual resource data. One should
note here that a resource file can have a total size of <i>64 kbyte
maximum</i>, due to the use of 16-bit values as pointers. Files of
this format can be saved by all RCS (<b>R</b>esource
<b>C</b>onstruction <b>S</b>et) programs.</p>

<p>Users of the programs Interface and RSM (Resource Master) can also
work with resource files > 64 kbyte. The operating system <a href="00b.html">MagiC</a> as of
version 3 also supports resource files larger than 64 kbyte; loading
of the resource is performed with <a href="008011.html#rsrc_load">rsrc_load</a> as usual, the rest is
handled quite transparently by the system.</p>

<p>See also: <a href="008011.html#rsrc_rcfix">rsrc_rcfix</a> &nbsp; <a href="#RSXHDR">RSXHDR</a></p>

<h3><a name="RSXHDR"></a>8.22.39 RSXHDR</h3>
<pre>typedef struct
{
  uint16_t rsh_vrsn;     /* Version number, should be 3 for new format  */
  uint16_t rsh_extvrsn;  /* Not used,                                   */
                         /* initialized to 'IN' for Interface,          */
                         /* 'RM' for ResourceMaster                     */
  uint32_t rsh_object;   /* Offset to <a href="#OBJECT">OBJECT</a> structures from file start */
  uint32_t rsh_tedinfo;  /* Offset to <a href="#TEDINFO">TEDINFO</a> structures                */
  uint32_t rsh_iconblk;  /* Offset to <a href="#ICONBLK">ICONBLK</a> structures                */
  uint32_t rsh_bitblk;   /* Offset to <a href="008016.html#BITBLK">BITBLK</a> structures                 */
  uint32_t rsh_frstr;    /* Offset to string pointer table              */
  uint32_t rsh_string;   /* Offset to string data                       */
  uint32_t rsh_imdata;   /* Offset to image data                        */
  uint32_t rsh_frimg;    /* Offset to image pointer table               */
  uint32_t rsh_trindex;  /* Offset to tree pointer table                */
  uint32_t rsh_nobs;     /* Number of OBJECTs in the file               */
  uint32_t rsh_ntree;    /* Number of object trees in the file          */
  uint32_t rsh_nted;     /* Number of TEDINFOs in the file              */
  uint32_t rsh_nib;      /* Number of ICONBLKs in the file              */
  uint32_t rsh_nbb;      /* Number of BITBLKs in the file               */
  uint32_t rsh_nstring;  /* Number of free strings in the file          */
  uint32_t rsh_nimages;  /* Number of free images in the file           */
  uint32_t rsh_rssize;   /* In the newer format files this value can be
                            used as an offset to the extension array    */
} RSXHDR;
</pre>
<p>See also: <a href="008011.html#rsrc_load">rsrc_load</a> &nbsp; <a href="#RSHDR">RSHDR</a></p>

<h3><a name="SCANX"></a>8.22.40 SCANX</h3>
<pre>typedef struct
{
    int8_t   scancode;
    int8_t   nclicks;
    int16_t  objnr;
} SCANX;
</pre>
<p><b>Note:</b> The structure contains the assignment for the key
with the scancode <i>scancode</i>, which when pressed performs an
<i>nclicks</i> times mouse click on the object with the index
<i>objnr.</i> The end of the table is marked by a scancode of NULL.</p>

<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="00b.html">MagiC</a> &nbsp; <a href="#XDO_INF">XDO_INF</a> &nbsp; <a href="010002.html">Scancode table</a></p>

<h3><a name="SET_ITEM"></a>8.22.41 SET_ITEM</h3>
<pre>typedef int16_t (cdecl *SET_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                struct _lbox_item *item,
                                int16_t obj_index, void *user_data,
                                <a href="010009.html#GRECT">GRECT</a> *rect, int16_t first );
</pre>

<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top"><i>box</i></td>
  <td align="left" valign="top">points to the list box structure</td>
</tr>
<tr>
  <td align="left" valign="top"><i>tree</i></td>
  <td align="left" valign="top">points to the object tree of the dialog</td>
</tr>
<tr>
  <td align="left" valign="top"><i>item</i></td>
  <td align="left" valign="top">points to the <a href="#LBOX_ITEM">LBOX_ITEM</a> structure of the entry to be set</td>
</tr>
<tr>
  <td align="left" valign="top"><i>obj_index</i></td>
  <td align="left" valign="top">is the number of the object to be set</td>
</tr>
<tr>
  <td align="left" valign="top"><i>user_data</i></td>
  <td align="left" valign="top">is the pointer passed by lbox_create</td>
</tr>
<tr>
  <td align="left" valign="top"><i>rect</i></td>
  <td align="left" valign="top">is the pointer to the <a href="010009.html#GRECT">GRECT</a> for the object redraw or 0L</td>
</tr>
<tr>
  <td align="left" valign="top"><i>first</i></td>
  <td align="left" valign="top">contains the number of the first visible item for Slider B</td>
</tr>
</table>
</div>

<p>For a list box that only contains text strings, <set> is typically
a function that copies a string pointed to by the <a href="#LBOX_ITEM">LBOX_ITEM</a> structure
into the object <i>obj_index</i>.</p>

<p><i>rect</i> is 0L when a redraw of the dialog box is executed or
when <a href="00800e.html#lbox_update">lbox_update</a> has been called. <i>rect</i> is not 0L when the user
has selected or deselected an object, and points to the <a href="010009.html#GRECT">GRECT</a> for the
redraw.</p>

<p>The return value is the number of the start object for
<a href="008010.html#objc_draw">objc_draw</a>/<a href="008008.html#wdlg_redraw">wdlg_redraw</a>.</p>

<p>For entries in the list box that consist of several objects it is
sometimes sensible to reduce the redraw rectangle when selecting/
deselecting an object, or to alter the start object, to prevent
unnecessary drawing operations and/or unnecessary flicker. In most
cases the list box routines call the function <a href="008010.html#objc_draw">objc_draw</a>/<a href="008008.html#wdlg_redraw">wdlg_redraw</a>
after <set> to display the altered contents.</p>

<p><i>first</i> contains the number of the first visible item for
Slider B if the list box has two sliders. For a (vertical) list box
with text strings and two sliders, when calling <a href="00800e.html#lbox_create">lbox_create</a>, for
instance, one enters the number of visible characters in
<i>visible_b</i>, the total string length in <i>entries_b</i> and
the index of the first visible character in <i>first_b</i>. If the
text is scrolled horizontally, <set> is called for all visible strings
and the affected parts of the screen are redrawn or moved. If the list
box has only one slider, <i>first</i> is always 0.</p>

<p>See also: <a href="00800e.html">List boxes</a> &nbsp; <a href="00800e.html#lbox_create">lbox_create</a></p>

<h3><a name="SHELTAIL"></a>8.22.42 SHELTAIL</h3>
<pre>typedef struct
{
    int16_t dummy;       /* A NULL-WORD                 */
    int32_t magic;       /* 'SHEL', if it's a shell     */
    int16_t isfirst;     /* First call of the shell     */
    int32_t lasterr;     /* Last error                  */
    int16_t wasgr;       /* Program was a graphic-app.  */
} SHELTAIL;
</pre>
<p><b>Note:</b> This information is conveyed to an alternative
desktop by <a href="00b.html">MagiC</a> at program launch (can be obtained by <a href="008012.html#shel_read">shel_read</a>). If
the shell returns a negative error code, then MAGXDESK will be
reactivated.</p>

<p>If <i>isfirst</i> is set then the status is to be read from
something like DESKTOP.INF, if <i>isfirst</i> is not set then one
takes the temporary file or shell-buffer.</p>

<p><i>lasterr</i> is the return value of the program running
previously. If this was a GEM program then the error will already
have been displayed in an alert box. It is well known that the
LONGword is negative if the error occurred with <a href="00500b.html#Pexec">Pexec</a> itself; a
program return value always has the high-WORD 0.</p>

<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="008012.html#shel_wdef">shel_wdef</a></p>

<h3><a name="SLCT_ITEM"></a>8.22.43 SLCT_ITEM</h3>
<pre>typedef void (cdecl *SLCT_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                 struct _lbox_item *item,
                                 void *user_data, int16_t obj_index,
                                 int16_t last_state );
</pre>
<p>The following apply:</p>

<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>box</i></td>
<td valign="top">points to the list box structure</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>tree</i></td>
<td valign="top">points to the object tree of the dialog</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>item</i></td>
<td valign="top">points to the <a href="#LBOX_ITEM">LBOX_ITEM</a>-structure of the selected entry</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>user_data</i></td>
<td valign="top">is the pointer passed by lbox_create</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj_index</i></td>
<td valign="top">is the number of the selected object. For a double-click the
top bit is set, similar to <a href="00800b.html#form_do">form_do</a>. If it is 0, it signifies that no
object is assigned to this entry; it is not visible. Normally this is
only the case when one is scrolling and by selecting a new object the
(now no longer visible) selection has to be cleared.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>last_state</i></td>
<td valign="top">is the previous status of the object. <i>last_state</i> can
also have the same value as <i>item->selected.</i> In that case one
can normally quit the function immediately.

</td></tr>
</table>

<p>See also: <a href="00800e.html#lbox_create">lbox_create</a></p>

<h3><a name="SWINFO"></a>8.22.44 SWINFO</h3>
<pre>typedef struct
{
    int8_t  *string;     /* Perhaps '<a href="002.html">TOS</a>|KAOS|MAG!X'            */
    int16_t  num;        /* <a href="indexudo.html">Index</a> of current character string   */
    int16_t  maxnum;     /* Maximum permitted num               */
} SWINFO;
</pre>
<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="008002.html#G_SWBUTTON">G_SWBUTTON</a></p>

<h3><a name="TEDINFO"></a>8.22.45 TEDINFO</h3>
<p>The TEDINFO structure is used to describe a text object more
exactly, and is defined as follows:</p>

<pre>typedef struct
{
    int8_t    *te_ptext;          /* Pointer to a string              */
    int8_t    *te_ptmplt;         /* Pointer to the string template   */
    int8_t    *te_pvalid;         /* Pointer to the validation string */
    int16_t    te_font;           /* Font type                        */
    int16_t    te_fontid;         /* GDOS Font ID                     */
    int16_t    te_just;           /* <a href="00f00e.html#Text_20alignment">Text alignment</a>:
                                      0 = Ranged left
                                      1 = Ranged right
                                      2 = Centred                     */
    int16_t    te_color;          /* Colour                           */
    int16_t    te_fontsize;       /* GDOS font size in points         */
    int16_t    te_thickness;      /* Border width                     */
    int16_t    te_txtlen;         /* Maximum length of the text       */
    int16_t    te_tmplen;         /* Length of the string template    */
} TEDINFO;
</pre>
<p>The following matters should be noted for this:</p>

<ul>
<li><p><i>te_ptext:</i> If the first character is an 'at' symbol
(@@), then all following characters will be taken to be place holders,
and the string initially output will consist of space characters.
Hence the 'at' symbol may never be placed at the start of an editable
field!</p></li>
<li><p><i>te_ptmplt:</i> Template. This is used only for <a href="008002.html#G_FTEXT">G_FTEXT</a> and
<a href="008002.html#G_FBOXTEXT">G_FBOXTEXT</a>, i.e. <a href="008002.html#G_TEXT">G_TEXT</a> and <a href="008002.html#G_BOXTEXT">G_BOXTEXT</a> can have a NULL-pointer here.
During output, all '_' characters in the template will be replaced
successively with the characters in <i>te_ptext</i>, i.e. a mixed
character string will be formed. So in general the template will have
as many '_' characters as the length of the buffer for
<i>te_ptext</i> (without the terminating NULLbyte). The template can
also contain other characters, which will be displayed but cannot be
overwritten.</p></li>
<li><p><i>te_pvalid:</i> String that contains for each character in
<i>te_ptext</i> validation characters that provide information about
the type of character permitted at the matching string position. The
following apply:<table>
<tr><td nowrap="nowrap" valign="top">Character</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">1 - 9</td>
<td valign="top">Accept any digit from 0 to that number. This is handy for doing
octal ('7') or binary ('1') validation.
<br>(Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">9</td>
<td valign="top">Only digits 0..9</td></tr>

<tr><td nowrap="nowrap" valign="top">A</td>
<td valign="top">Only uppercase (capital) letters A..Z and space</td></tr>

<tr><td nowrap="nowrap" valign="top">a</td>
<td valign="top">only Buchstaben/Leerzeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">N</td>
<td valign="top">Only upper and lowercase letters and space</td></tr>

<tr><td nowrap="nowrap" valign="top">n</td>
<td valign="top">Digits 0..9, uppercase letters A..Z, and space</td></tr>

<tr><td nowrap="nowrap" valign="top">F</td>
<td valign="top">All characters valid for a GEMDOS filename, and '*', '?' and
':'.</td></tr>

<tr><td nowrap="nowrap" valign="top">f</td>
<td valign="top">All characters valid for a GEMDOS filename, without '*', '?'
and ':'.</td></tr>

<tr><td nowrap="nowrap" valign="top">h</td>
<td valign="top">Hexadecimal character (Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">H</td>
<td valign="top">Hexadecimal character; lowercase a..f keys are converted to
keys A..F in uppercase (Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">P</td>
<td valign="top">All characters valid for a GEMDOS pathname plus '\', ':', '?',
'*'</td></tr>

<tr><td nowrap="nowrap" valign="top">p</td>
<td valign="top">Similar to 'P', but without the characters '?' and '*'</td></tr>

<tr><td nowrap="nowrap" valign="top">m</td>
<td valign="top">All characters that are valid for a long filename; i.e. all
characters except <a href="008002.html#control">control</a> characters (ASCII < 32), and also without
':' and '\'. At present, this code is only supported by <a href="00b.html">MagiC</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">X</td>
<td valign="top">All characters</td></tr>

<tr><td nowrap="nowrap" valign="top">x</td>
<td valign="top">All characters, lowercase letters are converted to uppercase
(Geneva)

</td></tr>
</table>

</p></li>
<li><p><i>te_font:</i>
<br>3 = Standard monospaced system font
<br>5 = Small monospaced system font<br><br>

For further information, see below.</p></li>
<li><p><i>te_fontid:</i>
<br>For further information, see below.</p></li>
<li><p><i>te_color:</i> For the colour of the bounding rectangle, the
following assignments apply:<table>
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">12..15</td>
<td valign="top">Border colour (0..15)</td></tr>

<tr><td nowrap="nowrap" valign="top">08..11</td>
<td valign="top">Text colour (0..15)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top">Text (0 = transparent, 1 = opaque))</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4..&nbsp;6</td>
<td valign="top">Intensity<table>
<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp;&nbsp; =</td>
<td valign="top">Hollow</td></tr>

<tr><td nowrap="nowrap" valign="top">1..6 =</td>
<td valign="top">Increasing intensity</td></tr>

<tr><td nowrap="nowrap" valign="top">7&nbsp;&nbsp;&nbsp; =</td>
<td valign="top">Solid area
</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0..&nbsp;3</td>
<td valign="top">Inner colour (0..15)

</td></tr>
</table>

</p></li>
<li><p><i>te_thickness:</i> For the border frame, the following
values are valid:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Value</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;0</td>
  <td align="left" valign="top">No border</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;1..&nbsp;128</td>
  <td align="left" valign="top">Border lies 1 to 128 pixels within the object</td>
</tr>
<tr>
  <td align="left" valign="top">-1..-127</td>
  <td align="left" valign="top">Border lies 1 to 127 pixels outside of the object</td>
</tr>
</table>
</div>

</p></li>
</ul>

<a name="GDOS_20fonts_20in_20dialogs"></a>
<a name="Dialogs_2C_20GDOS_20fonts_20in"></a>
<a name="Fonts_20in_20dialogs"></a>
<p><b>Note:</b> The components <i>te_fontid</i> and
<i>te_fontsize</i> were previously reserved. As of AES Version
4.1 it is possible to use any GDOS fonts for TEDINFO objects.</p>

<p>For this one should specify with the component <i>te_font</i> the
type of the font. The following apply:</p>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top"><i>te_font</i></td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">SpeedoGDOS font</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">SpeedoGDOS font (monospaced)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">GDOS bitmap font</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Normal system font</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">Small system font</td>
</tr>
</table>
</div>

<p>To use values 0 and 1 of <i>te_font</i>, <a href="VDI_fundamentals.html#SpeedoGDOS">SpeedoGDOS</a> or a
substitute (such as <a href="VDI_fundamentals.html#NVDI">NVDI</a>) has to be <a href="004011.html#installed">installed</a> on the system.</p>

<p>For values in the region 0..2 of <i>te_font</i> one can then set
with the components <i>te_fontid</i> or <i>te_fontsize</i> the
desired font and the desired point size.</p>

<p>The simplest way to check the presence of the new possibilities is
to call <a href="Application.html#_25apgi_13">appl_getinfo</a> (opcode 13).</p>

<p>See also:
<br><a href="008001.html">About the AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="#OBJECT">OBJECT</a> &nbsp; <a href="#XTED">XTED</a> &nbsp; <a href="00b007.html">Scrollable input fields</a></p>

<h3><a name="USERBLK"></a>8.22.46 USERBLK</h3>
<pre>typedef struct
{
   int16_t cdecl (*ub_code)(<a href="#PARMBLK">PARMBLK</a> *parmblock);
   int32_t ub_parm;
} USERBLK;
</pre>
<p><b>Note:</b> The function <i>ub_code</i> is called for each call
of <a href="008010.html#objc_draw">objc_draw</a> and <a href="008010.html#objc_change">objc_change</a> for the corresponding object. The
component <i>ub_parm</i> can be looked on as an optional parameter.</p>

<h3><a name="UTXT_FN"></a>8.22.47 UTXT_FN</h3>
<p>This function is declared as follows:</p>

<pre>typedef void (cdecl *UTXT_FN) (int16_t x, int16_t y, int16_t *clip_rect,
                               int32_t id, int32_t pt, int32_t ratio,
                               int8_t *string);
</pre>
<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="008014.html#fnts_add">fnts_add</a> &nbsp; <a href="#FNTS_ITEM">FNTS_ITEM</a> &nbsp; <a href="008014.html">Font selection</a></p>

<h3><a name="WINFRAME_HANDLER"></a>8.22.48 WINFRAME_HANDLER</h3>
<p>Passing structure for linking in</p>

<pre>typedef struct {
  int16_t   version;                  /* Version number of structure  */
  int32_t   wsizeof;                  /* <a href="00f008.html#Size">Size</a> of the WINDOW-structure */
  int16_t   whshade;                  /* Height of the shaded window  */
  void      (*wbm_create)( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_skind) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_ssize) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sslid) ( <a href="#WININFO">WININFO</a> *w, int16_t vertical );
  void      (*wbm_sstr)  ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sattr) ( <a href="#WININFO">WININFO</a> *w, int16_t chbits );
  void      (*wbm_calc)  ( int16_t kind, int16_t *fg );
  int16_t   (*wbm_obfind)( <a href="#WININFO">WININFO</a> *w, int16_t x, int16_t y );
} WINFRAME_HANDLER;
</pre>
<p>See also:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WININFO">WININFO</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a></p>

<h3><a name="WINFRAME_SETTINGS"></a>8.22.49 WINFRAME_SETTINGS</h3>
<p>Passing structure for <a href="008002.html#global">global</a> window settings</p>

<pre>typedef struct {
  int16_t   flags;
  int16_t   h_inw;
  void      *finfo_inw;
} WINFRAME_SETTINGS;
</pre>
<p>Bits of <i>flags</i>:
<br>#define NO_BDROP 1</p>

<p>See also:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WININFO">WININFO</a></p>

<h3><a name="WININFO"></a>8.22.50 WININFO</h3>
<p>WINDOW-structure for <a href="00b.html">MagiC</a>-kernel</p>

<pre>typedef struct {
  int16_t   state;
  int16_t   attr;
  void      *own;         /* (APPL *)                     */
  int16_t   kind;         /* from <a href="008009.html#wind_create">wind_create</a>()           */
  char      *name;        /* Pointer to title line        */
  char      *info;        /* Pointer to Info line         */
  <a href="010009.html#GRECT">GRECT</a>     curr;
  <a href="010009.html#GRECT">GRECT</a>     prev;
  <a href="010009.html#GRECT">GRECT</a>     full;
  <a href="010009.html#GRECT">GRECT</a>     work;
  <a href="010009.html#GRECT">GRECT</a>     overall;      /* Outline                      */
  <a href="010009.html#GRECT">GRECT</a>     unic;
  <a href="010009.html#GRECT">GRECT</a>     min;          /* Minimum size                 */
  int16_t   oldheight;    /* Old height of shading        */
  int16_t   hslide;       /* Horizontal slider position   */
  int16_t   vslide;       /* Vertical slider position     */
  int16_t   hslsize;      /* Horizontal slider size       */
  int16_t   vslsize;      /* Vertical slider size         */
  void      *wg;          /* Rectangle list               */
  void      *nextwg;      /* Next rectangle of the list   */
  int16_t   whdl;
  <a href="#OBJECT">OBJECT</a>    tree[N_OBJS];
  int16_t   is_sizer;
  int16_t   is_info;
  int16_t   is_rgtobjects;
  int16_t   is_botobjects;
  <a href="#TEDINFO">TEDINFO</a>   ted_name;
  <a href="#TEDINFO">TEDINFO</a>   ted_info;
} WININFO;
</pre>
<p>Bits of <i>state</i>:
<br>#define OPENED 1
<br>#define COVERED 2
<br>#define ACTIVE 4
<br>#define LOCKED 8
<br>#define ICONIFIED 32
<br>#define SHADED 64</p>

<p>See also:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a></p>

<h3><a name="XAESMSG"></a>8.22.51 XAESMSG</h3>
<p>This structure is defined as follows:</p>

<pre>typedef struct
{
   int16_t  dst_apid;       /* ID of target application  */
   int16_t  unique_flg;     /* Overwrite messages?       */
   void     *attached_mem;  /* Pointer to memory block   */
   int16_t  *msgbuf;        /* <a href="00f00a.html#Message">Message</a> buffer            */
} XAESMSG;
</pre>
<p><b>Note:</b> The component <i>unique_flg</i> specifies if
kindred messages (i.e. those with the same message type msgbuf[0]) are
to be overwritten by the new message.</p>

<p>If <i>attached_mem</i> is not NULL, it is used to specify a
memory block allocated with <a href="00500c.html#Malloc">Malloc</a> that contains the extended message
information. The length of this block is arbitrary and is of no
interest to the system - for instance it could be passed as the first
LONGword of the block, or in <i>msgbuf</i> [4,5]. The system
allocates the memory block to the destination application and passes
its address in msgbuf[6,7].</p>

<p><b>Important:</b> The called application must assume that
<i>msgbuf[6,7]</i> are destroyed after a call of <a href="Application.html#appl_write">appl_write</a>. The
system reserves the right to copy the contents of the memory block
elsewhere and to release the passed block. The caller may <i>no
longer access</i> the block after an appl_write call, and may on no
account release it!</p>

<p>If <a href="Application.html#appl_write">appl_write</a> returns an error code, then the block has
<i>not</i> been passed and still belongs to the calling application.
An error arises when:</p>

<ul>
<li><p>The destination application is invalid (non-existant or frozen)</p></li>
<li><p>The message buffer of the destination application is full</p></li>
<li><p>The destination application is not a process (e.g. the <a href="008002.html#The_20screen-manager">SCRENMGR</a>
and an attached memory block has been specified</p></li>
</ul>

<p>See also: <a href="008001.html">About the AES</a> &nbsp; <a href="Application.html#appl_write">appl_write</a> &nbsp; <a href="002002.html">GEM</a></p>

<h3><a name="XDO_INF"></a>8.22.52 XDO_INF</h3>
<pre>typedef struct
{
    <a href="#SCANX">SCANX</a> *unsh;    /* Tables for non-[Shift] combinations   */
    <a href="#SCANX">SCANX</a> *shift;   /* Tables for [Shift] combinations       */
    <a href="#SCANX">SCANX</a> *ctrl;    /* Tables for [Control] combinations     */
    <a href="#SCANX">SCANX</a> *alt;     /* Tables for [Alternate] combinations   */
    void  *resvd;   /* Reserved   */
} XDO_INF;
</pre>
<p><b>Note:</b> This structure contains pointers to tables that
assign to a scancode an object index of the dialog box. This makes it
simple to service dialogs completely via the keyboard. The parameter
<i>resvd</i> is reserved for future use, and must always be NULL.</p>

<p>See also:
<br><a href="008001.html">About the AES</a> &nbsp; <a href="00800b.html#form_keybd">form_keybd</a> &nbsp; <a href="00800b.html#form_xdo">form_xdo</a> &nbsp; <a href="00b.html">MagiC</a> &nbsp; <a href="010002.html">Scancode table</a></p>

<h3><a name="XFONTINFO"></a>8.22.53 XFONTINFO</h3>
<pre>typedef struct
{
   int16_t font_id;
   int16_t point_size;
   int16_t gadget_wid;
   int16_t gadget_ht;
} XFONTINFO;
</pre>
<p>See also: <a href="Application.html#x_appl_font">x_appl_font</a></p>

<h3><a name="XFSL_FILTER"></a>8.22.54 XFSL_FILTER</h3>
<pre>typedef int16_t (cdecl XFSL_FILTER) (int8_t *path, int8_t *name, <a href="005014.html#XATTR">XATTR</a> *xa);
</pre>
<p>See also: <a href="00800a.html#fslx_do">fslx_do</a> &nbsp; <a href="00800a.html#fslx_open">fslx_open</a></p>

<h3><a name="XSHW_COMMAND"></a>8.22.55 XSHW_COMMAND</h3>
<pre>typedef struct
{
   int8_t  *command;
   int32_t limit;
   int32_t nice;
   int8_t  *defdir;
   int8_t  *env;
} XSHW_COMMAND;
</pre>
<p>See also: <a href="008012.html#shel_write">shel_write</a></p>

<h3><a name="XTED"></a>8.22.56 XTED</h3>
<p>This structure is required in connection with scroll-capable
editable text fields.</p>

<pre>typedef struct _xted
{
   int8_t  *xte_ptmplt;
   int8_t  *xte_pvalid;
   int16_t xte_vislen;
   int16_t xte_scroll;
} XTED;
</pre>
<p>See also: <a href="00b007.html">Scrollable input fields</a> &nbsp; <a href="#TEDINFO">TEDINFO</a></p>

<h3><a name="X_BUF_V2"></a>8.22.57 X_BUF_V2</h3>
<a name="ABLE_GETINFO"></a>
<a name="ABLE_PROP"></a>
<a name="ABLE_WTREE"></a>
<a name="ABLE_X3D"></a>
<a name="ABLE_XSHL"></a>
<a name="ABLE_PROP2"></a>
<a name="ABLE_EMSDESK"></a>
<a name="ABLE_XBVSET"></a>
<pre>typedef struct x_buf_v2
{
int16_t  buf_len   /* Length of the structure, including this WORD       */
                   /* Future versions of this structure (X_BUF_V3 etc.)  */
                   /* may be bigger                                      */
int16_t  arch      /* 16 for 16-bit <a href="008.html">AES</a>, 32 for hypothetical 32-bit <a href="008.html">AES</a>  */
<a href="#CLRCAT">CLRCAT</a>   *cc       /* Address of an array of 16 <a href="#CLRCAT">CLRCAT</a> structures -      */
                   /* this is so that they can be read by a program; in  */
                   /* ViewMAX, the colours could be set but not reread   */
<a href="#OBJECT">OBJECT</a>   *w_active /* Address of an object tree (19 elements) used to    */
                   /* draw window elements; included so a program can    */
                   /* change symbols on window buttons                   */
int8_t   *info     /* Address of a 0-terminated ASCII string (at most    */
                   /* 40 characters, no newlines) describing the <a href="008.html">AES</a>     */
int32_t  abilities /* A bitmapped field describing what optional         */
                   /* functions this <a href="008.html">AES</a> provides:                       */
/* ABLE_GETINFO  1    bit 0 : xapp_getinfo supported                     */
/* ABLE_PROP     2    bit 1 : prop_get, prop_put and prop_del supported  */
/* ABLE_WTREE    4    bit 2 : <a href="008009.html#wind_get">wind_get</a> and <a href="008009.html#wind_set">wind_set</a> can change glyphs    */
/* ABLE_X3D      8    bit 3 : <a href="002002.html">GEM</a>/5 3D using <a href="008002.html#DRAW3D">DRAW3D</a>                      */
/* ABLE_XSHL    16    bit 4 : xshl_getshell & xshl_putshell              */
/* ABLE_PROP2   32    bit 5 : prop_gui_get, prop_gui_set                 */
/* ABLE_EMSDESK 64    bit 6 : xgrf_dtimage supports EMS                  */
/* ABLE_XBVSET 128    bit 7 : Supports 32 disc drives                    */
} X_BUF_V2;
</pre>
<p>An initialized X_BUF_V2 is one in which all members are 0 except
<i>buf_len.</i> This initialized buffer is then passed to <a href="Application.html#appl_init">appl_init</a>.
On return, if <i>arch</i> is 0 then the structure was not filled in
by the AES; otherwise it was. The <i>buf_len</i> field may be
reduced if the AES was expecting an earlier version of the
structure (i.e. X_BUF_V1); this should not be a problem because the
structures are forward and backward compatible.</p>

<p>See also: <a href="Application.html#appl_init">appl_init</a></p>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="008.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="008015.html"><img src="udo_lf.gif" alt="AES function list" title="AES function list" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="009.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24"></a></body>
</html>

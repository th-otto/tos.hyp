<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>
The documentation for TOS: System functions
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00500d.html"><img src="udo_lf.gif" alt="Network functions" title="Network functions" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00500f.html"><img src="udo_rg.gif" alt="Directory functions" title="Directory functions" border="0" width="24" height="24"></a>
<hr>

<h1><a name="System_20functions"></a>5.14 System functions</h1>
<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#Salert">Salert</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top">Outputs alerts or error-messages.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Sconfig">Sconfig</a>&nbsp;&nbsp;</td>
<td valign="top">Obtains/Sets operating system configuration.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Shutdown">Shutdown</a>&nbsp;</td>
<td valign="top">Kills all processes, syncs file-systems then halts or reboots
the system.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Slbclose">Slbclose</a>&nbsp;</td>
<td valign="top"> Closes a <a href="00b017.html">shared library</a></td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Slbopen">Slbopen</a>&nbsp;&nbsp;</td>
<td valign="top"> Opens a shared library.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Srealloc">Srealloc</a>&nbsp;</td>
<td valign="top"> Allocates screen memory.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Ssync">Ssync</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Synchronises all mounted file-systems.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Ssystem">Ssystem</a>&nbsp;&nbsp;</td>
<td valign="top"> Controls cookie jar, memory access and various system
settings.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#STEFcntrl">STEFcntrl</a></td>
<td valign="top"> <a href="00e003.html">STEmulator</a> control functions.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Super">Super</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Obtains or alters supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Suptime">Suptime</a>&nbsp;&nbsp;</td>
<td valign="top"> Obtains the current uptime and load averages for the system.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Sversion">Sversion</a>&nbsp;</td>
<td valign="top"> Obtains the version number of GEMDOS.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Syield">Syield</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Releases CPU for other processes.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Sysconf">Sysconf</a>&nbsp;&nbsp;</td>
<td valign="top"> Checks operating system configuration.

</td></tr>
</table>

<p>See also: <a href="005009.html">File functions</a> &nbsp; <a href="00500b.html">Process functions</a></p>

<h3><a name="Salert"></a>5.14.1 Salert</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Salert« - Output alert or error-message.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">316</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Salert ( int8_t *msg );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Salert outputs an alert or error-message that is
written to the alert pipeline U:\PIPE\ALERT.<br><br>

The message <i>msg</i> should not contain any escape or control
characters, linefeeds etc. It should be a simple one-line
NULL-terminated character string alert- or error-message.<br><br>

The function formats the message itself and sends it to the user.
The exact format of the output however depends on the system
configuration in use.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function has no direct result.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Available when a 'MiNT' cookie with a version of at least 0.98
exists.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Salert">Binding</a> &nbsp; <a href="005010.html#Cconws">Cconws</a> &nbsp; <a href="005004.html">Test for pipes</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Salert"></a>5.14.1.1 Bindings for Salert</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">void <a href="#Salert">Salert</a> ( int8_t *msg );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       msg          ; Offset 2
move.w    #316,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Sconfig"></a>5.14.2 Sconfig</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Sconfig« - Configuration of parts of the operating system.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">51</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Sconfig ( int16_t mode, int32_t flags );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Sconfig permits the configuration of parts of the
operating system. The following apply:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"><b>Action</b><table>
<tr><td nowrap="nowrap" valign="top">0 =</td>
<td valign="top">Obtain configuration</td></tr>

<tr><td nowrap="nowrap" valign="top">1 =</td>
<td valign="top">Set configuration</td></tr>

<tr><td nowrap="nowrap" valign="top">2 =</td>
<td valign="top">Get pointer to <a href="005014.html#DOSVARS">DOSVARS</a> structure</td></tr>

<tr><td nowrap="nowrap" valign="top">3 =</td>
<td valign="top">Reserved; <a href="00b.html">MagiC</a> 3.00</td></tr>

<tr><td nowrap="nowrap" valign="top">4 =</td>
<td valign="top">For <a href="00b013.html#WBDAEMON">WBDAEMON</a>; <a href="00b.html">MagiC</a> 4.01</td></tr>

<tr><td nowrap="nowrap" valign="top">5 =</td>
<td valign="top">Reserved; <a href="00b.html">MagiC</a> 4.01</td></tr>

<tr><td nowrap="nowrap" valign="top">6 =</td>
<td valign="top">Reserved; <a href="00b.html">MagiC</a> 4.01
</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">flags</td>
<td valign="top"><b>Configuration as bit-vector:</b><table>
<tr><td nowrap="nowrap" valign="top">Bit-0 =</td>
<td valign="top">Path-checking on</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-1 =</td>
<td valign="top">Insert mode for GEMDOS and dialog boxes</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-2 =</td>
<td valign="top">Reserved</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-3 =</td>
<td valign="top">Reserved</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-4 =</td>
<td valign="top"><a href="00b013.html#Fastload">Fastload</a> for diskette off</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-5 =</td>
<td valign="top">TOS-compatibility on</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-6 =</td>
<td valign="top"><a href="00b00f.html#Smart_20redraw">Smart redraw</a> off</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-7 =</td>
<td valign="top">Grow-/Shrinkboxes off</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-8 =</td>
<td valign="top">No pause after TOS programs</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-9 =</td>
<td valign="top">Reserved</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-10 =</td>
<td valign="top">Pulldown menus</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-11 =</td>
<td valign="top">Floppy background operation
</td></tr>
</table>


</td></tr>
</table>

<br><br>

<b>Note:</b> Set bits switch the relevant function on, cleared
bits switch in off again.(!nl) Bit 11 is only available as of MagiC
3.0. The setting of the configuration is only possible with
TOS-compatibility <i>switched off</i>.<br><br>

The function is also present in KAOS, though with a somewhat
different assignment of the bit-vector. For <i>mode</i>, KAOS 1.2
only knows the first two subfunctions.<table>
<tr><td nowrap="nowrap" valign="top">Bit-0 =</td>
<td valign="top">Path-checking on</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-1 =</td>
<td valign="top">Disk change simulation in desktop on</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-2 =</td>
<td valign="top">Break on; CTRL-C interrogation at every DOS call</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-3 =</td>
<td valign="top">CTRL-C interrogation off; for character-oriented functions</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-4 =</td>
<td valign="top"><a href="00b013.html#Fastload">Fastload</a> for diskette off</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-5 =</td>
<td valign="top">TOS-compatibility on (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-6 =</td>
<td valign="top"><a href="00b00f.html#Smart_20redraw">Smart redraw</a> off (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-7 =</td>
<td valign="top">Grow-/shrinkboxes off (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-8 =</td>
<td valign="top">No pause after TOS programs (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-9 =</td>
<td valign="top">Reserved (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-10 =</td>
<td valign="top">Pulldown menus (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-11..30 =</td>
<td valign="top">Reserved (as of KAOS 1.4.2)</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-31 =</td>
<td valign="top">Has to be 0, else error! (as of KAOS 1.4.2)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns, depending on the parameter <i>mode</i>,
the currently valid configuration or a pointer to a <a href="005014.html#DOSVARS">DOSVARS</a> structure.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">As of KAOS Version 1.2, and <a href="00b.html">MagiC</a> Version 1.0.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Sconfig">Binding</a> &nbsp; <a href="#Sysconf">Sysconf</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Sconfig"></a>5.14.2.1 Bindings for Sconfig</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Sconfig">Sconfig</a> ( int16_t mode, int32_t flags );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    flags,-(sp)  ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #51,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Shutdown"></a>5.14.3 Shutdown</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Shutdown« - Kill all processes, sync file-systems then halt
or reboot the system.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">337 (0x0151)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Shutdown ( int32_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Shutdown kills all processes, syncs file-systems
then halts or reboots the system.<a name="SHUT_HALT"></a>
<br><br>

On <i>mode</i> equal to SHUT_HALT (0L), the system will shut
down, then enter a halted condition.<a name="SHUT_BOOT"></a>
<br><br>

On <i>mode</i> equal to SHUT_BOOT (1L), the system will reboot
the machine after shutting everything down.<a name="SHUT_COLD"></a>
<br><br>

On <i>mode</i> equal to SHUT_COLD (2L), the system will act the
same as with the SHUT_BOOT mode, except that a cold start rather than
the warm start will be performed. SHUT_COLD mode is recognized as of
FreeMiNT version 1.15.5; older versions of the kernel will treat the
SHUT_COLD mode as SHUT_BOOT.<a name="SHUT_POWER"></a>
<br><br>

On <i>mode</i> equal to SHUT_POWER (3L), the system will turn the
power off. The only hardware that supports it at present is CT60. If
the hardware does not support it, SHUT_HALT will be performed.
SHUT_POWER mode is recognized as of FreeMiNT version 1.16a; older
versions of the kernel will treat the SHUT_POWER mode as SHUT_COLD.<br><br>

All other values of <i>mode</i> are reserved for future
definition.<br><br>

Older versions of MiNT contained a bug that might cause the system
to crash if you called Shutdown while both <a href="002002.html">GEM</a> <a href="008.html">AES</a> and virtual console
daemon were present.<br><br>

You need root privileges to shut the system down.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns a negative GEMDOS error-code if it fails. On success
this call obviously never returns.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">As of the first in MultiTOS integrated MiNT version 1.04.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Shutdown">Binding</a> &nbsp; <a href="#Ssync">Sync</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Shutdown"></a>5.14.3.1 Bindings for Shutdown</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">void <a href="#Shutdown">Shutdown</a> ( int32_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    mode,-(sp)   ; Offset 2
move.w    #337,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Slbclose"></a>5.14.4 Slbclose</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Slbclose« - Close a <a href="00b017.html">shared library</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">23 (0x017)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Slbclose( SHARED_LIB *sl );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Slbclose closes a shared library.<br><br>

The parameter <i>sl</i> is the descriptor that is obtained with
Slbclose.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="005003.html#E_OK">E_OK</a> = All OK, version number of the library, else a negative
GEMDOS error-number.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">As of MagiC 5.20 and FreeMiNT 1.15.4.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Slbclose">Binding</a> &nbsp; <a href="#Slbopen">Slbopen</a> &nbsp; <a href="00b017.html">Shared libraries</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Slbclose"></a>5.14.4.1 Bindings for Slbclose</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Slbclose">Slbclose</a>( SHARED_LIB *sl );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       sl           ; Offset 2
move.w    #23,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Slbopen"></a>5.14.5 Slbopen</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Slbopen« - Open a <a href="00b017.html">shared library</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">22 (0x016)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Slbopen( int8_t *name, int8_t *path, int32_t min_ver,
SHARED_LIB *sl, SLB_EXEC *fn );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Slbopen opens a shared library.<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">name</td>
<td valign="top">The name of the library, in capitals, incl. extension (".SLB").
The library name is the filename as well.</td></tr>

<tr><td nowrap="nowrap" valign="top">path</td>
<td valign="top">Path where the library is first looked for (the path must be
terminated in MagiC 5.20 with '\'; this is no longer necessary in
MagiC 6). If the parameter is NULL, or the library was not found in
the specified bath, then it will be looked for in the XTENSION
folder.(!nl) From MagiC 6 onwards the environmental variable SLBPATH
will be evaluated. As in PATH, it contains a list of the search paths,
each separated by ';'. If the variable is defined, then no extra
search will be made in the XTENSION folder.<br><br>

With FreeMiNT an attempt will be made to load the library from the
current directory if <i>path</i> is NULL.</td></tr>

<tr><td nowrap="nowrap" valign="top">min_ver</td>
<td valign="top">Lowest required version number of the library</td></tr>

<tr><td nowrap="nowrap" valign="top">sl</td>
<td valign="top">Pointer to the descriptor</td></tr>

<tr><td nowrap="nowrap" valign="top">fn</td>
<td valign="top">Pointer to the function pointer

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">>= 0</td>
<td valign="top">All OK, version number of the library</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="005003.html#ERANGE">ERANGE</a></td>
<td valign="top">Version number too low</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="005003.html#EACCDN">EACCDN</a></td>
<td valign="top">Library already opened by the process</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="005003.html#EFILNF">EFILNF</a></td>
<td valign="top">Library not found</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="005003.html#ENSMEM">ENSMEM</a></td>
<td valign="top">Insufficient memory available

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">As of MagiC 5.20 and FreeMiNT 1.15.4.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Slbopen">Binding</a> &nbsp; <a href="#Slbclose">Slbclose</a> &nbsp; <a href="00b017.html">Shared libraries</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Slbopen"></a>5.14.5.1 Bindings for Slbopen</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Slbopen">Slbopen</a>( int8_t *name, int8_t *path, int32_t min_ver,
SHARED_LIB *sl, SLB_EXEC *fn );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       fn           ; Offset 18
pea       sl           ; Offset 14
move.l    minver,-(sp) ; Offset 10
pea       path         ; Offset 6
pea       name         ; Offset 2
move.w    #22,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #22,sp       ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Srealloc"></a>5.14.6 Srealloc</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Srealloc« - Allocate screen memory.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">21</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Srealloc ( int32_t len );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The GEMDOS routine Srealloc allocates a block of length
<i>len</i> bytes for the screen memory.<br><br>

The screen memory is a block of the ST-RAM whose owner is the boot
process. The address of the screen memory (logbase or physbase) is not
affected by this function.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns (if <i>len</i> has the value -1) the
maximum possible size of the screen memory.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of GEMDOS 0.30 (TOS 4).</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Srealloc">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Srealloc"></a>5.14.6.1 Bindings for Srealloc</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Srealloc">Srealloc</a> ( int32_t len );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    len,-(sp)    ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Ssync"></a>5.14.7 Ssync</h3>
<a name="Sync"></a>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Ssync« - Synchronise all mounted file-systems.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">336 (0x0150)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Ssync ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Ssync synchronises all mounted file-systems.<br><br>

<b>Warning:</b> In MiNT this function is designated as Sync.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"><a href="00b.html">MagiC</a> as of Version 4.01, and under all MiNT versions
integrated with MultiTOS.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Ssync">Binding</a> &nbsp; <a href="#Shutdown">Shutdown</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ssync"></a>5.14.7.1 Bindings for Ssync</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">void <a href="#Ssync">Ssync</a> ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #336,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Ssystem"></a>5.14.8 Ssystem</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Ssystem« - Control cookie jar, memory access and various
system settings.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">340 (0x0154)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Ssystem ( int16_t mode, int32_t arg1, int32_t arg2 );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The Ssystem call has been designed to make your life easier.
Using this you can get some closer control of the system and the
kernel itself. Via this call the kernel now supports e.g. an easy
cookie jar management and provides a safe access to supervisor memory.
It's strictly encouraged to access GEMDOS variables and system
vectors via the Ssystem, because this way is considered safe for
multi-user setups.<br><br>

<i>arg1</i> and <i>arg2</i> are LONG parameters specific to a
particular mode. If a mode doesn't use a parameter, it is usually
ignored, but should be set to zero for future compatibility.
<i>mode</i> specifies a particular action as follows:<table>
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top">Meaning<a name="S_INQUIRE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_INQUIRE(0xffff)</td>
<td valign="top">Returns a zero if the kernel supports Ssystem. You can expect
the function to be present if MiNT version at least 1.15 is detected.<a name="S_OSNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSNAME(0x0000)</td>
<td valign="top">Identifies the operating system type. Returned LONGword
contains a 32-bit positive number, which interpreted as an ASCII
string gives a 4-character ID. For MiNT the returned value is
0x4d694e54 ('MiNT').<a name="S_OSXNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSXNAME(0x0001)</td>
<td valign="top">Identifies the subtype of the operating system. If this call
returns zero or a negative value, that means that no subtype is
available. Otherwise the returned value, when interpreted as an ASCII
string, gives a 4-character subtype ID. For FreeMiNT, being a
derivative of the MiNT, the returned value is 0x46726565 ('Free').<br><br>

If a subtype ID is less than 4 characters long, it should be
padded with zeros.<a name="S_OSVERSION"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSVERSION(0x0002)</td>
<td valign="top">Identifies the exact operating system version. Returned
LONGword contains a 32-bit positive version number encoded as follows:<table>
<tr><td nowrap="nowrap" valign="top">Bits</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top">Some printable character to characterize the current version,
e.g.<table>
<tr><td nowrap="nowrap" valign="top">0x61</td>
<td valign="top">(`a') if alpha release,</td></tr>

<tr><td nowrap="nowrap" valign="top">0x62</td>
<td valign="top">(`b') if beta release.
</td></tr>
</table>

<br>

For official releases you will always find a value of 0 here.</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top">Patchlevel (0x55 for pl 88)</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top">Minor version number (0x0e for x.14)</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top">Major version number ($01 for 1.xx)

</td></tr>
</table>

<br><br>

Definition of an official release: every release for which a value
of 0 is returned in bits 0-7...<a name="S_OSHEADER"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSHEADER(0x0003)</td>
<td valign="top">Allows accessing the @{<a href="002.html">TOS</a> ignore} header so as to get some
information from it. Current implementation permits access to the
first 256 LONGwords of the header. The address of the required
LONGword, relative to the start address of the TOS header, has to
be specified as <i>arg1</i>. Only even values are allowed (bit 0 of
the @{I}arg1@{0} is masked out by the kernel). A whole LONGword is
returned always.<a name="S_OSBUILDDATE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSBUILDDATE(0x0004)</td>
<td valign="top">Returns a 32-bit positive value with the build date encoded as
follows:<table>
<tr><td nowrap="nowrap" valign="top">Bits</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-15</td>
<td valign="top">Binary year ($07dd for 1998)</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top">Binary month ($0c for December)</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top">Binary day of the month

</td></tr>
</table>

<a name="S_OSBUILDTIME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSBUILDTIME(0x0005)</td>
<td valign="top">Returns a 32-bit positive value with the build time encoded as
follows:<table>
<tr><td nowrap="nowrap" valign="top">Bits</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top">Binary seconds</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top">Binary minutes</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top">Binary hours</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top">Day of week

</td></tr>
</table>

<br><br>

Day of week has 1 for Monday, 2 for Tuesday... 7 for Sunday.<br><br>

The call should never return a zero in these bits, but if it does,
it should be interpreted as Sunday.<a name="S_OSCOMPILE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSCOMPILE(0x0006)</td>
<td valign="top">Returns a 32-bit positive value specifying the primary CPU type
the kernel has been compiled for. Encoding:<table>
<tr><td nowrap="nowrap" valign="top">Bits</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top">Binary minor CPU ID</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top">Binary major CPU ID</td></tr>

<tr><td nowrap="nowrap" valign="top">16-31</td>
<td valign="top">Reserved for future definition

</td></tr>
</table>

<br><br>

The major ID identifies a particular series of processors.
Currently only a value of $00 is defined and it is assigned to
Motorola 68k series. Other values of this field are reserved for
future definition.<br><br>

The minor CPU ID interpretation depends on the major ID. For 68k
series, values are as follows:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0x00</td>
  <td align="left" valign="top">68000</td>
</tr>
<tr>
  <td align="left" valign="top">0x0a</td>
  <td align="left" valign="top">68010</td>
</tr>
<tr>
  <td align="left" valign="top">0x14</td>
  <td align="left" valign="top">68020</td>
</tr>
<tr>
  <td align="left" valign="top">0x1e</td>
  <td align="left" valign="top">68030</td>
</tr>
<tr>
  <td align="left" valign="top">0x28</td>
  <td align="left" valign="top">68040</td>
</tr>
<tr>
  <td align="left" valign="top">0x3c</td>
  <td align="left" valign="top">68060</td>
</tr>
</table>
</div>

<br><br>

This is not the same as the <a href="003007.html#Cookie_2C_20_CPU">_CPU</a> cookie value. The _CPU
cookie specifies the CPU physically present in the machine, while the
S_OSCOMPILE indicates the processor type selected at the time when the
system was compiled. In other words, running a 68000-compiled kernel
will return a 0x00 here, even if the machine is running 68040 or
something.<a name="S_OSFEATURES"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSFEATURES(0x0007)</td>
<td valign="top">Returns a 32-bit positive value specifying the state of kernel
features. Encoding:<table>
<tr><td nowrap="nowrap" valign="top">Bits</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"><a href="005005.html#Memory_20protection">Memory protection</a> (1 = turned on)</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top">Virtual memory (1 = turned on)</td></tr>

<tr><td nowrap="nowrap" valign="top">2-31</td>
<td valign="top">Reserved for future usage

</td></tr>
</table>

<br><br>

This call has an informative purpose only and you cannot toggle
anything with it.<a name="S_GETCOOKIE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETCOOKIE(0x0008)</td>
<td valign="top">Fetches required information from the cookie jar.</p>
<ol>
<li><p>If <i>arg1</i> is a value bigger than 65535 (0xffff), it is
interpreted as a tag ID. The cookie jar is searched for such a tag,
then if the tag is found, the corresponding slot value is returned, or
-1 otherwise.</p></li>
<li><p>If <i>arg1</i> is a value between 1 and 65535, it is
interpreted as a slot number, not a tag ID. Then the corresponding tag
ID is fetched and returned, or a value of -1 if the specified slot is
free or does not exist at all (a slot number past the end of the
cookie jar was specified). The first slot in the cookie jar is
considered number 1.</p></li>
<li><p>If <i>arg1</i> is equal to zero, then the cookie jar is
searched for the NULL cookie, and the corresponding slot value is
returned.</p></li>
</ol>

<br><br>

The place where the value fetched from the cookie jar will be
returned is defined by <i>arg2</i>. If this is a zero, the call
returns its values in the GEMDOS return value (d0). If <i>arg2</i>
is not a zero, it is interpreted as a pointer to a memory location
where the slot tag or its value should be written to. The return value
is 0 (<a href="005003.html#E_OK">E_OK</a>) if everything went OK, or -1 otherwise.<br><br>

This behaviour (where <i>arg2</i> != NULL) is not implemented in
MiNT versions below 1.14.8.<a name="S_SETCOOKIE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETCOOKIE(0x0009)</td>
<td valign="top">Places a tag ID specified by <i>arg1</i> with the value of
<i>arg2</i> in the cookie jar. If a slot with the specified tag ID
already exists, it will be replaced with the new value. <a href="003007.html#NULL-cookie">NULL-cookie</a> is
reallocated automatically and its value is adjusted. If there are no
more free slots, no action is performed and <a href="005003.html#ENOMEM">ENOMEM</a> is returned
instead.<br><br>

S_SETCOOKIE requires root euid, <a href="005003.html#EACCES">EACCES</a> is returned otherwise and
no action is performed.<br><br>

The call refuses to place a cookie (a value of -1 is returned)
whose tag id contains a zero-byte.<a name="S_GETLVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETLVAL(0x000a)</td>
<td valign="top">Fetches and returns a LONGword from the address of supervisor
area specified as a 16-bit, even, unsigned integer value passed as
<i>arg1</i>. Bit 0 and bits 16-31 are masked out (ignored). The call
returns a zero if the value at the specified address has to be
"hidden" from reading. Currently the hidden values are the initial PC
value and the initial stack pointer value stored at 0x00000000 and
0x00000004 respectively. Reading a hidden value may require root euid.<br><br>

If the desired address is LONGword aligned, LONGwords can be also
retrieved from the supervisor area using <a href="About_the_BIOS.html#Setexc">Setexc</a>.<a name="S_GETWVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETWVAL(0x000b)</td>
<td valign="top">Fetches and returns a word from the address of supervisor area
specified as a 16-bit, even, unsigned integer value passed as
<i>arg1</i>. Bit 0 and bits 16-31 are masked out (ignored). The call
returns a zero if the value at the specified address has to be
"hidden" from reading. Currently the hidden values are the initial PC
value and the initial stack pointer value stored at 0x00000000 and
0x00000004 respectively. Reading a hidden value may require root euid.<a name="S_GETBVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETBVAL(0x000c)</td>
<td valign="top">Fetches and returns a byte from the address of supervisor area
specified as a 16-bit unsigned integer value passed as <i>arg1</i>.
Bits 16-31 are masked out (ignored). The call returns a zero if the
value at the specified address has to be "hidden" from reading.
Currently the hidden values are the initial PC value and the initial
stack pointer value stored at 0x00000000 and 0x00000004 respectively.
Reading a hidden value may require root euid.<a name="S_SETLVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETLVAL(0x000d)</td>
<td valign="top">Places a LONGword value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bit 0 and bits 16-31 of
the <i>arg1</i> are masked out (ignored). Since this call is designed
to manipulate operating system variables located within the supervisor
area (first 32k), it is restricted to root euid and returns <a href="005003.html#EACCES">EACCES</a> if
called by an unprivileged process.<a name="S_SETWVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETWVAL(0x000e)</td>
<td valign="top">Places a word value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bit 0 and bits 16-31 of
the <i>arg1</i> are masked out (ignored). Since this call is designed
to manipulate operating system variables located within the supervisor
area (first 32k), it is restricted for root euid and returns <a href="005003.html#EACCES">EACCES</a> if
called by an unprivileged process.<a name="S_SETBVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETBVAL(0x000f)</td>
<td valign="top">Places a byte value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bits 16-31 of the
<i>arg1</i> are masked out (ignored). Since this call is designed to
manipulate operating system variables located within the supervisor
area (first 32k), it is restricted for root euid and returns <a href="005003.html#EACCES">EACCES</a> if
called by an unprivileged process.<a name="S_SECLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SECLEVEL(0x0010)</td>
<td valign="top">Resets the current security level to a value specified by
<i>arg1</i>. Valid levels are as follows:<br><br>

0: none of hardware specific system calls are restricted. This is
a 'MultiTOS compatibility' mode.<br><br>

1: BIOS and XBIOS calls require root privileges; any call
except <a href="004012.html#Supexec">Supexec</a> and <a href="#Super">Super</a> returns <a href="005003.html#EACCES">EACCES</a> if called by an unprivileged
process. This does not apply to <a href="About_the_BIOS.html#Setexc">Setexc</a>, which sends <a href="005007.html#SIGSYS">SIGSYS</a> to the
caller if a change of an exception vector was attempted.<br><br>

2: as above, with except that Supexec and Super generates
SIGSYS in order to kill the calling process.<br><br>

On values bigger than 2, <a href="005003.html#EACCES">EACCES</a> is returned. If <i>arg1</i> is
equal to -1, the current security level value is returned.<br><br>

The call absolutely needs root privileges - user processes cannot
even inquire the current security level value.<a name="S_RUNLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_RUNLEVEL(0x0011)</td>
<td valign="top">Reserved for future definition.<a name="S_TSLICE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_TSLICE(0x0012)</td>
<td valign="top">Allows setting/interrogating the global timeslice value.
Values are exactly the same as for SLICES keyword in mint.cnf. If
<i>arg1</i> is equal to -1, the call returns the current global
timeslice value.<br><br>

Setting the timeslice requires root privileges.<a name="S_FORCEFASTLOAD"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_FORCEFASTLOAD(0x0013)</td>
<td valign="top">Allows changing the interpretation of the FASTLOAD bit in the
program header.<br><br>

On Ssystem(S_FORCEFASTLOAD, 0L, 0L); the program header bit will
be used as before, this is actually equal to FASTLOAD=NO in mint.cnf.<br><br>

On Ssystem(S_FORCEFASTLOAD, 1L, 0L); , the program header bit will
be ignored and fastload will be forced for all programs.<br><br>

<i>arg1</i> = -1 allows interrogation of the current state of
this variable.<br><br>

You need root privileges to toggle the FASTLOAD mode.<a name="S_SYNCTIME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SYNCTIME(0x0014)</td>
<td valign="top">Allows interrogation or changing the global file-system sync
time. The default value is 5 sec.<br><br>

If <i>arg1</i> is a positive value, it is interpreted as a new
sync time value.<br><br>

If <i>arg1</i> is equal to -1, the current sync time value will
be returned.<br><br>

To be able to change the file-system sync time you must have root
privileges.<a name="S_BLOCKCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_BLOCKCACHE(0x0015)</td>
<td valign="top">A positive value of <i>arg1</i> ranging from 0 to 100
specifies the percentage of file-system cache to be filled with linear
reads, as in the PERCENTAGE keyword in the mint.cnf file. A negative
value of <i>arg1</i> returns the currently set percentage value.<br><br>

Root privileges are required to use this mode.<a name="S_FLUSHCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_FLUSHCACHE(0x0016)</td>
<td valign="top">Invalidates CPU cache entries. <i>arg1</i> is a pointer to the
memory area whose cache entries should be invalidated, <i>arg2</i> is
the size of the area in bytes. Passing -1 as <i>arg2</i> invalidates
all cache entries. If the CPU features separate instruction and data
caches, both are flushed.<br><br>

This call automatically recognizes caches in 68020/030/040/060 and
handles them as appropriate. The 68060 branch cache is automatically
invalidated too. On 68000/68010 calling this mode has no effect. This
mode is in fact just an interface to the MiNT function cpush used
internally by the system.<br><br>

Root privileges are NOT required to use this mode.<a name="S_CTRLCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CTRLCACHE(0x0017)</td>
<td valign="top">Provides an universal (among 68k family members) way of
controlling the CPU on-chip caches. <i>arg1</i>, referenced as Cache
Control Word (CCW), is a bit-field where each bit enables (if 1) or
disables (if 0) a particular function of CPU caches. <i>arg2</i>,
referenced as Cache Control Mask (CCM), is a bit-mask where you define
(by setting appropriate bits to 1) which bits of the Cache Control
Word should be actually taken into account and written into the Cache
Control Register (CACR). This is the control mode of the S_CTRLCACHE.<br><br>

In inquire mode you can pass -1 as either argument. If the CCW is
-1, the call returns a LONGword reflecting the actual state of the
caches.<br><br>

If the CCM is -1, a default bit-mask is returned, where any bit
set indicates that a cache function defined by the same bit in the
Cache Control Word is valid for the processor the MiNT is currently
running on.<br><br>

If both arguments are negative, the call simply returns <a href="005003.html#E_OK">E_OK</a> if it
is valid at all, or <a href="005003.html#ENOSYS">ENOSYS</a> otherwise. This is the acknowledge mode of
the S_CTRLCACHE.<br><br>

Bits in either argument are defined as follows:<table>
<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top">Enable instruction cache</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top">Enable data cache</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top">Enable branch cache</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top">Freeze instruction cache</td></tr>

<tr><td nowrap="nowrap" valign="top">4</td>
<td valign="top">Freeze data cache</td></tr>

<tr><td nowrap="nowrap" valign="top">5</td>
<td valign="top">Instruction burst enable</td></tr>

<tr><td nowrap="nowrap" valign="top">6</td>
<td valign="top">Data burst enable</td></tr>

<tr><td nowrap="nowrap" valign="top">7</td>
<td valign="top">Enable write allocate</td></tr>

<tr><td nowrap="nowrap" valign="top">8</td>
<td valign="top">Instruction cache full mode enable</td></tr>

<tr><td nowrap="nowrap" valign="top">9</td>
<td valign="top">Instruction cache read/write allocate enable</td></tr>

<tr><td nowrap="nowrap" valign="top">10</td>
<td valign="top">Data cache full mode enable</td></tr>

<tr><td nowrap="nowrap" valign="top">11</td>
<td valign="top">Data cache read/write allocate enable</td></tr>

<tr><td nowrap="nowrap" valign="top">12</td>
<td valign="top">Invalidate branch cache</td></tr>

<tr><td nowrap="nowrap" valign="top">13</td>
<td valign="top">Invalidate branch cache user entries</td></tr>

<tr><td nowrap="nowrap" valign="top">14</td>
<td valign="top">Enable CPUSH invalidate</td></tr>

<tr><td nowrap="nowrap" valign="top">15</td>
<td valign="top">Enable store buffer</td></tr>

<tr><td nowrap="nowrap" valign="top">16-31</td>
<td valign="top">Reserved for future definition

</td></tr>
</table>

<br><br>

Note that no processor currently supports all of these functions
and some (68000 and 68010) have no on-chip caches at all. To figure
out what functions are valid for the actual CPU used, you should first
request the default bit-mask using the inquire mode described above.
Your program should save this mask, logically AND the <i>arg2</i>
with it, then pass the result as the Cache Control Mask for a control
mode call.<br><br>

Also note that the above bit definition does not exactly reflect
the function and even position of actual bits in the physical Cache
Control Register. The bits of either argument are arbitrarily assigned
to particular cache functions, but their position and state are
converted by the system before the Cache Control Register is written
and after it is read, so that the user program can see always the same
functions assigned to bits as above regardless of the physical
configuration of the Cache Control Register.<br><br>

Since changing cache configuration is global and may severely
affect system performance, root privileges are needed to use
S_CTRLCACHE control mode.<a name="S_INITIALTPA"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_INITIALTPA(0x0018)</td>
<td valign="top">A positive non-zero value of <i>arg1</i> defines the default
amount of memory (in bytes) allocated for TPA space, as in the
INITIALMEM keyword of the mint.cnf file. A negative value allows one
to interrogate the value currently set. A value of 0 is illegal and
will cause the call to fail and return <a href="005003.html#EBADARG">EBADARG</a>. Note that even if you
define a very small value, like 1 or 2 bytes, the system will round
this up to the smallest size of a memory block possible to allocate.<br><br>

Root privileges are required to use this mode.<a name="S_CAD"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CAD(0x0019)</td>
<td valign="top">Reserved for future definition.<a name="S_CLOCKMODE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CLOCKMODE(0x0064)</td>
<td valign="top">S_CLOCKMODE(0x0064) S_CLOCKMODE called with an <i>arg1</i> of
-1 inquires the kernel's notion of the hardware system clock. If the
command returns a zero, the hardware clock is considered to tick in
UTC; if it returns a positive non-zero value, it is considered to tick
in local time. Any other positive value of <i>arg1</i> sets the
current clock mode. On a 0 it is reset to UTC, or to local time
otherwise.<br><br>

Although this call will never really change the setting of the
hardware clock, due to the changed interpretation the clock seems to
warp; don't play around too much with it.<a name="S_KNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_KNAME(0x0384)</td>
<td valign="top"><i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the full name and version of the
system kernel. If the memory buffer is not long enough to hold the
entire string, the string is truncated down to the buffer size.<a name="S_CNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CNAME(0x038e)</td>
<td valign="top"><i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the full name of the compiler used
to compile the system kernel. If the memory buffer is not long enough
to hold the entire string, the string is truncated down to the buffer
size.<a name="S_CVERSION"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CVERSION(0x038f)</td>
<td valign="top"><i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the version of the compiler used to
compile the system kernel. If the memory buffer is not long enough to
hold the entire string, the string is truncated down to the buffer
size.<a name="S_CDEFINES"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CDEFINES(0x0390)</td>
<td valign="top"><i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written containing the compile time definitions
(switches) used while compiling the system kernel. If the memory
buffer is not long enough to hold the entire string, the string is
truncated down to the buffer size.<a name="S_COPTIM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_COPTIM(0x0391)</td>
<td valign="top"><i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written containing the compile time optimization
options used while compiling the system kernel. If the memory buffer
is not long enough to hold the entire string, the string is truncated
down to the buffer size.<a name="S_DEBUGLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DEBUGLEVEL(0x03e8)</td>
<td valign="top">S_DEBUGLEVEL called with an <i>arg1</i> of -1 inquires the
kernel's current debug level. Any other positive value will set the
current debug level. If it is a zero, the kernel will not output any
debugging information, except for fatal error-messages. The higher the
debug level, the more MiNT will spew about what it is doing.<br><br>

Note that special debug kernels will output more information than
an ordinary distribution kernel.<br><br>

Root privileges are needed to change the debug level.<a name="S_DEBUGDEV"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DEBUGDEV(0x03e9)</td>
<td valign="top">S_DEBUGDEV called with an <i>arg1</i> of -1 inquires the
current BIOS device to output the debug information to. The order
of defined BIOS devices is as follows:<ul>
<li>0, printer</li>
<li>1, AUX:</li>
<li>2, console (default)</li>
<li>3, MIDI</li>
<li>4, keyboard</li>
<li>5, raw screen</li>
</ul>

<br><br>

Any positive value of <i>arg1</i>, ranging from 0 to 9, will
redirect the debug information output to an appropriate BIOS
device. Notice however, that setting device 4 (keyboard) as a debug
device does not make much sense and may produce undesired results. The
system does not restrict this in any way though, just assuming that
you know what you're doing.<br><br>

Root privileges are needed to change the debug device.<a name="S_TIOCMGET"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_TIOCMGET(0x54f8)</td>
<td valign="top">This mode is reserved for the internal and exclusive usage of
the MiNT Library.

</td></tr>
</table>

<br><br>

Ssystem was first introduced as of MiNT version 1.14.6, but it is
considered fully functional as of MiNT version 1.15.0 release.<br><br>

The S_OSHEADER opcode should be only used for fetching the TOS
version number when running MiNT versions below 1.15.0 release.<br><br>

The S_FLUSHCACHE, S_CTRLCACHE, S_DEBUGLEVEL and S_DEBUGDEV are
supported as of MiNT version 1.15.1 release.<br><br>

You should never use Ssystem(S_TIOCMGET, ...); in your own
programs.<br><br>

The Ssystem behaviour does not depend on the S_SECLEVEL settings.<br><br>

Any values returned by the kernel on reserved fields should be
considered undocumented and no software should rely on them.<br><br>

It's strictly encouraged to access GEMDOS variables and system
vectors via the Ssystem, because this way is considered safe for
multi-user setups. For example, you can access the cookie jar pointer
using the call Ssystem(S_GETLVAL, 0x05a0, NULL), though if
TOS-compatibility is the issue you should rather use (2, -1).<br><br>

Prior to any further Ssystem usage, your application should first
check if the kernel supports this call. If it does, the Ssystem(-1,
0L, 0L); should return a zero.<br><br>

Ssystem is used and supported by the MiNT Library as of patchlevel
48.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Available when a 'MiNT' cookie with a version of at least 1.15
exists.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Ssystem">Binding</a> &nbsp; <a href="00500a.html#Tgettimeofday">Tgettimeofday</a> &nbsp; <a href="00500a.html#Tsettimeofday">Tsettimeofday</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ssystem"></a>5.14.8.1 Bindings for Ssystem</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Ssystem">Ssystem</a> ( int16_t mode, int32_t arg1, int32_t arg2 );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    arg2,-(sp)   ; Offset 8
move.l    arg1,-(sp)   ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #340,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
lea       $0c(sp),sp   ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="STEFcntrl"></a>5.14.9 STEFcntrl</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»STEFcntrl« - <a href="00e003.html">STEmulator</a> nolink [<a href="008002.html#control">control</a> functions]).</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">24000 (0x5DC0)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t STEFcntrl ( int16_t func, int32_t special1, int32_t
special2 );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"><br><br>

SET_INFOTEXT (1)
<br>special1 = (int8_t *) Pointer to new info-line
<br>special2 = (int8_t *) Pointer to old info-line<br><br>

The string pointed to be <i>special1</i> will be adopted as the
new info-line in the status-line of the <a href="00e003.html">STEmulator</a>. A value of NULL
switches back to the standard display again.<br><br>

If a valid pointer to a buffer is passed in <i>special2</i>, this
will contain the old text of the info-line after the function call.
With NULL, nothing happens.<br><br>

SET_WINDOWTITLE (2)
<br>special1 = (int8_t *) Pointer to new title-line
<br>special2 = (int8_t *) Pointer to old title-line<br><br>

The string pointed to by <i>special1</i> will be adopted as the
new title-line of the <a href="00e003.html">STEmulator</a> window.<br><br>

If a valid pointer to a buffer is passed in <i>special2</i>, this
will contain the old text of the window title after the function call.
With NULL, nothing happens.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="005003.html#EINVFN">EINVFN</a> = Unknown function.
<br><a href="005003.html#ERANGE">ERANGE</a> = Invalid parameter.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"><a href="00e003.html">STEmulator</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20STEFcntrl">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20STEFcntrl"></a>5.14.9.1 Bindings for STEFcntrl</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#STEFcntrl">STEFcntrl</a> ( int16_t func, int32_t special1, int32_t
special2 );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    special2,-(sp)   ; Offset 8
move.l    special1,-(sp)   ; Offset 4
move.w    func,-(sp)       ; Offset 2
move.w    #24000,-(sp)     ; Offset 0
trap      #1               ; <a href="005.html">GEMDOS</a>
lea       $0c(sp),sp       ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Super"></a>5.14.10 Super</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»supervisor« - Switch supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">32 (0x0020)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Super ( void *stack );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The GEMDOS routine Super switches between user- and
supervisor-mode, or interrogates the current operating<br><br>

The address of the supervisor stack may be altered during
switching. If one passes the value 1 for the parameter <i>stack</i>,
then the current mode will be interrogated. The value 0 switches
between user- and supervisor-mode. All other values will be regarded
as the new address for the supervisor stack. In the supervisor-mode
one can access all protected memory blocks.<br><br>

<b>Note:</b> With regard to future operating system versions, you
should avoid use of the Super function. This function gives rise to
major problems in conjunction with virtual memory and interruptible
(and re-entrant) file-systems in a multitasking system. If neccesary,
alter your code so that you can use the BIOS function <a href="004012.html#Supexec">Supexec</a>.<br><br>

For MiNT the following applies:
<br>If you are in SECURELEVEL > 1, you must have root privileges to
get into supervisor-mode. If you don't have them and call Super, the
<a href="005007.html#SIGSYS">SIGSYS</a> signal (12) will be raised.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> If the state is to be obtained, one gets the value 0 for the
user-mode and -1 for the supervisor-mode. Else the function returns
the address of the old supervisor stack, provided one had switched to
the supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All GEMDOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="Super.html#Bindings_20for_20Super">Binding</a> &nbsp; <a href="004012.html#Supexec">Supexec</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Super"></a>5.14.10.1 Bindings for Super</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Super">Super</a> ( void *stack );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       stack        ; Offset 2
move.w    #32,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h4><a name="Note_20for_20the_20use_20of_20the_20GEMDOS_20function_20Super"></a>5.14.10.2 Note for the use of the GEMDOS function Super</h4>
<p>The function Super in switching to the supervisor-mode sets the
Super stack pointer to the user-stack of the program. This can be
fatal, as the program can not know how large a super stack block has
to be. Too small a stack can lead to faulty behaviour, crashes or
similar. The super stack no longer lies in a block that is possibly
protected by memory protection mechanisms, so it can be destroyed by
the program.</p>

<p>A part of the user stack could have been laid-off by virtual
memory mechanisms. A laid-off super stack as seen from the processor
means that the MC-680x0 processor can no longer save its CPU status to
the super stack as usual for exceptions, and then stop intentionally.
No applications programmer should be so arrogant as to burden the
system with any kind of restriction to the supervisor stack size.</p>

<p><b>See also:</b> <a href="005.html">GEMDOS</a> &nbsp; <a href="004012.html#Supexec">Supexec</a></p>

<h3><a name="Suptime"></a>5.14.11 Suptime</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Suptime« - Return the current uptime and load averages from
the system.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">319 (0x013f)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Suptime ( int32_t *uptime, int32_t *loadaverage );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Suptime returns the current uptime and load
averages from the system.<br><br>

<i>uptime</i> is a pointer to a LONG value that will be filled
with the current amount of seconds elapsed since the last reboot.<br><br>

<i>loadaverage</i> is a pointer to a three LONGword array, that
will be filled with the current load averages (for the last 1, 5 and
15 minutes).<br><br>

The load average value is calculated using the following formula:<br><br>

sum += (new_load - old_load) * LOAD_SCALE;
<br>load_avg = sum / MAX_SIZE;<br><br>

where LOAD_SCALE is 2048, MAX_SIZE is the number of 5 second
periods in the specified amount of time (12 for 1 min., 60 for 5 min.
and 180 for 15 min). new_load is the number of currently running
processes, old_load is the number of processes running previous time.
A 'running' process is considered the one which is put onto run or
ready queue.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns <a href="005003.html#E_OK">E_OK</a> if successful, or a negative GEMDOS error-code
otherwise (actually it may be only <a href="005003.html#ENOSYS">ENOSYS</a> if the call is not
supported...).</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Available when a 'MiNT' cookie with a version of at least 1.11
exists.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Suptime">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Suptime"></a>5.14.11.1 Bindings for Suptime</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Suptime">Suptime</a> ( int32_t *uptime, int32_t *loadaverage );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       loadaverage  ; Offset 6
pea       uptime       ; Offset 4
move.w    #48,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
lea       $0a(sp),sp   ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Sversion"></a>5.14.12 Sversion</h3>
<a name="GEMDOS_2C_20Version_20number"></a>
<a name="Version_20number_20of_20the_20GEMDOS"></a>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Operating system version« - Obtain the number of the current
GEMDOS version.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">48</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">uint16_t Sversion ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The GEMDOS routine Sversion obtains the version number of the
GEMDOS. At the present time, the following versions are known:<table>
<tr><td nowrap="nowrap" valign="top">Version</td>
<td valign="top">Explanation</td></tr>

<tr><td nowrap="nowrap" valign="top">0.13</td>
<td valign="top">Found in TOS 1.00 and 1.02. This version distinguishes
itself with several errors, so should not be used any more.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.14</td>
<td valign="top">Number of the Turbo-DOS, which was issued for a short time by
Atari with hard drives. Fast, but also very unsafe. KAOS 1.2.x also
has this version number.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.15</td>
<td valign="top">Found in TOS 1.04 and 1.06. This version is relatively fast
and stable.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.16</td>
<td valign="top">KAOS 1.4.x</td></tr>

<tr><td nowrap="nowrap" valign="top">0.17</td>
<td valign="top">Found in TOS 1.62. The difference from version 0.15 lies
only in the fact that the patch program POOLFIX3.PRG is no longer
required.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.19</td>
<td valign="top">Normally found in TOS 2.01, 2.05, 2.06, 3.01, 3.05, 3.06.
This version was mainly extended by functions for managing alternate
memory, and is also reported by MagiC up to Version 6.10.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.20</td>
<td valign="top"> TOS 2.06 up to 2.95 and TOS 3.06 have the GEMDOS
version 0.20. Only change known so far: Media with only one FAT are
supported.)
<br>MagiC 6.20 returns also 0.20.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.30</td>
<td valign="top"> TOS 4.00 bis 4.04, also MultiTOS 1.00 and 1.08.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.31</td>
<td valign="top"> Milan-TOS 4.05. <a href="00500c.html#Mxalloc">Mxalloc</a> ignores bit 2 to 15 of mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">0.32</td>
<td valign="top"> Milan-TOS 4.08, Release 08.07.1999</td></tr>

<tr><td nowrap="nowrap" valign="top">0.33</td>
<td valign="top"> Milan-TOS 4.08, Release 15.06.2001</td></tr>

<tr><td nowrap="nowrap" valign="top">0.40</td>
<td valign="top">FreeMiNT

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the named version number, in the
following manner:<table>
<tr><td nowrap="nowrap" valign="top">Low byte :</td>
<td valign="top">Main version number</td></tr>

<tr><td nowrap="nowrap" valign="top">High byte :</td>
<td valign="top">Minor version number

</td></tr>
</table>

<br><br>

The value is BCD coded.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All GEMDOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="#Bindings_20for_20Sversion">Binding</a> &nbsp; <a href="#Sysconf">Sysconf</a> &nbsp; <a href="010007.html">TOS list</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Sversion"></a>5.14.12.1 Bindings for Sversion</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">uint16_t <a href="#Sversion">Sversion</a> ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #48,-(sp)    ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Syield"></a>5.14.13 Syield</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Syield« - Release CPU for other processes.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">255</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Syield ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">By calling the Syield function a process releases the CPU, so
that it can be allocated to other processes (possibly earlier than
planned).<br><br>

<b>Note:</b> Under <a href="00b.html">MagiC</a> this function directly calls the AES
routine <a href="Application.html#appl_yield">appl_yield</a>, and will be ignored in the Auto folder.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">In MagiC as of Version 3.0, and when the MiNT cookie is
present.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Syield">Binding</a> &nbsp; <a href="00500b.html#Pause">Pause</a> &nbsp; <a href="005009.html#Fselect">Fselect</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Syield"></a>5.14.13.1 Bindings for Syield</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">void <a href="#Syield">Syield</a> ( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #255,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Sysconf"></a>5.14.14 Sysconf</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Sysconf« - Obtain information about the operating system
configuration.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">290</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Sysconf ( int16_t n );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The function Sysconf returns information about the capabilities
(or the configuration) of the operating system. With the parameter
<i>n</i> various values can be interrogated:<table>
<tr><td nowrap="nowrap" valign="top">n</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top">Max. legal value for n itself</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top">Max. value of memory regions per process</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top">Max. length of command line string for <a href="00500b.html#Pexec">Pexec</a></td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;2</td>
<td valign="top">Max. number of open files per process</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;3</td>
<td valign="top">Max. number of supplementary groups per process</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4</td>
<td valign="top">Max. number pf processes per user

</td></tr>
</table>

<br><br>

A return value of 0xfffffff (2^31 - 1) means that the
corresponding value is unlimited.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <b>Return value:</b> The function returns the information
specified by the parameter <i>n</i>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">As of the first in MultiTOS integrated MiNT version 1.04.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#System_20functions">System functions</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"><a href="Sysconf.html#Bindings_20for_20Sysconf">Binding</a> &nbsp; <a href="00500f.html#Dpathconf">Dpathconf</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Sysconf"></a>5.14.14.1 Bindings for Sysconf</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Sysconf">Sysconf</a> ( int16_t n );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    n,-(sp)      ; Offset 2
move.w    #290,-(sp)   ; Offset 0
trap      #1           ; <a href="005.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>


</td></tr>
</table>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00500d.html"><img src="udo_lf.gif" alt="Network functions" title="Network functions" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00500f.html"><img src="udo_rg.gif" alt="Directory functions" title="Directory functions" border="0" width="24" height="24"></a></body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>
The documentation for TOS: Special commands
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="004011.html"><img src="udo_lf.gif" alt="Sound routines" title="Sound routines" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="004013.html"><img src="udo_rg.gif" alt="Keyboard functions" title="Keyboard functions" border="0" width="24" height="24"></a>
<hr>

<h1><a name="Special_20commands"></a>4.18 Special commands</h1>
<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#Blitmode">Blitmode</a></td>
<td valign="top">Gets or changes blitter configuration.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#CacheCtrl">CacheCtrl</a></td>
<td valign="top">CPU cache management.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#CJar">CJar</a></td>
<td valign="top">Creates, interrogates and removes cookies.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dbmsg">Dbmsg</a></td>
<td valign="top">Outputs debug message.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Janus">Janus</a></td>
<td valign="top">Makes the "<a href="#Janus">Janus</a>" emulator available.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Puntaes">Puntaes</a></td>
<td valign="top">Switches off <a href="008.html">AES</a> in ROM.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Random">Random</a></td>
<td valign="top">Generates a random number.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Ssbrk">Ssbrk</a></td>
<td valign="top">Reserves memory (only used internally).</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Supexec">Supexec</a></td>
<td valign="top">Starts routine in supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Trapper">Trapper</a></td>
<td valign="top">Hooks into system functions.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#WdgCtrl">WdgCtrl</a></td>
<td valign="top">Sets the hardware watchdog.

</td></tr>
</table>

<p>See Also: <a href="004010.html">Interface programming</a></p>

<h3><a name="Blitmode"></a>4.18.1 Blitmode</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»blitter mode« - Blitter-chip configuration</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">64</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int16_t Blitmode( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">Blitmode is an XBIOS routine to switch on the blitter or to
verify its existence. If the parameter <i>mode</i> has the value -1
then one obtains the state of the blitter chip. All other values
configure the blitter:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">0 = Blitter off</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = Blitter on</td>
</tr>
<tr>
  <td align="right" valign="top">1-14</td>
  <td align="left" valign="top">Reserved</td>
</tr>
<tr>
  <td align="right" valign="top">15</td>
  <td align="left" valign="top">Must always be 0</td>
</tr>
</table>
</div>

<br><br>

<b>Note:</b> According to Atari the function may be used without
checking the TOS version (although it is not present in TOS
1.0, for instance). This is possible due to a side-effect in the
<a href="the_system_vectors.html#Dispatcher_2C_20XBIOS">dispatcher of the XBIOS</a>. However, it is better not to rely on this, as the
corresponding trap may be diverted by other programs, so that the
correct value may not be returned.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the properties of the blitter chip by the
set bits:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">0: Blitter off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">0: Blitter not present</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter present</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">15</td>
  <td align="left" valign="top">Always 0</td>
</tr>
</table>
</div>

<br><br>

All further bits are reserved.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Officially this function is present only as of TOS Version
1.02.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Blitmode">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Blitmode"></a>4.18.1.1 Bindings for Blitmode</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Blitmode">Blitmode</a>( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mode,-(sp)   ; Offset 2
move.w    #64,-(sp)    ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="CacheCtrl"></a>4.18.2 CacheCtrl</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»CacheCtrl« - CPU cache management</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">160</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t CacheCtrl( int16_t OpCode, int16_t Param );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS routine CacheCtrl serves for the management of the
CPU cache.<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">OpCode</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Return 0 to check that function is implemented</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Flush data cache</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Flush instruction cache</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Flush data and instruction cache</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Inquire data cache mode</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">Activation/deactivation of the data cache</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, switch off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, switch on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Write-back of the caches if necessary</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">Inquire instruction cache mode</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">Activation/deactivation of the command cache</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, switch off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, switch on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Write-back of the caches if necessary</td>
</tr>
</table>
</div>

<br><br>

<b>Note:</b>
<br>Under the CT60 XBIOS, OpCode 5/7 has the same effect :
<br><i>Param</i>: 0 = disable all caches.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = enable all caches.
<br>All caches are: Data cache, store buffer, branch cache,
instruction cache.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> If successful the function returns the value 0, or <a href="003006.html#EBADRQ">EBADRQ</a> when
a value larger than seven is passed for <i>OpCode.</i><br><br>

As an alternative the driver "CPU Cache Control Driver v1.10" by
Robert Federle and Thomas Tempelmann is available for other computers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">The function ist available on the Milan from TOS 4.06, in
CT60 XBIOS as of Version v0.98a.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20CacheCtrl">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20CacheCtrl"></a>4.18.2.1 Bindings for CacheCtrl</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#CacheCtrl">CacheCtrl</a>( int16_t OpCode, int16_t Param );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    Param,-(sp)  ; Offset 4
move.w    OpCode,-(sp) ; Offset 2
move.w    #160,-(sp)   ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="CJar"></a>4.18.3 CJar</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»CJar« - Creation, interrogation and removal of cookies</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">17226 (0x434A)</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t CJar( int16_t mode, int32_t cookie, int32_t *value );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS routine CJar offers a simple way of creating,
interrogating and removing cookies.<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Meaning</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top">Mode 0:
<br>Obtains the value of a cookie and stores it at the specified
address. If one passed a NULL-pointer for <i>value</i>, then only the
existence of the cookie will be checked. If presence of the cookie is
established, the call returns 0x6172 (="CJar_OK"), or a different
value otherwise.<br>


<br><br>

Mode 1:
<br>Creates a new cookie. In this case, <i>value</i> points to a
longword whose contents are copied into the cookie jar. If
<i>value</i> is NULL (zero), then a value of zero is entered into the
cookie jar. If the cookie already exists, the old value is
overwritten.
<br>This mode returns $6172 (="CJar_OK") if the addition was
successful or -1 if the addition failed due to lack of room in the
cookie jar.<br>


<br><br>

Mode 2:
<br>Removes the cookie <i>cookie</i> from the jar. The value of
<i>value</i> is immaterial. If the removal was successful the return
will be "CJar_OK", or another value otherwise.<br>

Is only available if the system extension Liberty (cookie 'Lity')
is <a href="004011.html#installed">installed</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">cookie</td>
<td valign="top">Cookie identifier</td></tr>

<tr><td nowrap="nowrap" valign="top">value</td>
<td valign="top">Address of the buffer in which the data is to be stored.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> If successful the function returns the value CJar_OK (0x6172).</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">The function is available when the cookie 'CJar' ($434A6172) is
present. This is created by JARxxx (Cookie Jar Manager) or by Liberty.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20CJar">Binding</a> &nbsp; <a href="00500e.html#S_GETCOOKIE">Cookie function</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20CJar"></a>4.18.3.1 Bindings for CJar</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#CJar">CJar</a>( int16_t mode, int32_t cookie, int32_t *value );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       value          ; Offset 8
move.l    cookie,-(sp)   ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #17226,-(sp)   ; Offset 0
trap      #14            ; Call <a href="004.html">XBIOS</a>
lea       12(sp),sp      ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Dbmsg"></a>4.18.4 Dbmsg</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dbmsg« - Output debug message</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">11</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Dbmsg( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">Dbmsg allows special debugging messages to be sent to a
resident debugger application.<br><br>

<i>srsrvd</i> is currently reserved and should always be 5.<br><br>

<i>msg_num</i> is the message number which you want to send to
the debugging host. Values of 0x0000 to 0xEFFF are reserved for
applications to define. Values of 0xF000 to 0xFFFF are reserved for
special debugging messages. If <i>msg_num</i> is in the application
defined range, it and the int32_t contained in <i>msg_arg</i> will be
displayed by the debugger and the application will be halted. If
<i>msg_num</i> is between 0xF001 and 0xF0FF inclusive then
<i>msg_arg</i> is interpreted as a character pointer pointing to a
string to be output by the debugger and debugging to halt. The string
length is determined by the low byte of <i>msg_num</i>.
<br><br><br>

If <i>msg_num</i> is <a href="00f00d.html#DB">DB</a>_NULLSTRING (0xF000), the string will be
output until a NULL is reached.
<br><br><br>

If <i>msg_num</i> is <a href="00f00d.html#DB">DB</a>_COMMAND (0xF100), <i>msg_arg</i> is
interpreted as a character pointer to a string containing a debugger
command. The command format is specific to the debugger which you are
running. A useful example of this format when running under the Atari
debugger allows a string to be output to the debugger without
terminating debugging as shown in the following example:<br><br>

Dbmsg( 5, <a href="00f00d.html#DB">DB</a>_COMMAND, "echo 'Debugging <a href="00f00a.html#Message">Message</a>';g" );<br><br>

The Atari Debugger only understands the value <a href="00f00d.html#DB">DB</a>_COMMAND (0xF100)
for <i>msg_num</i> as of version 3. Though it is normally harmless to
run an application with embedded debugging messages when no debugger
is present in the system, distribution versions of applications should
have these instructions removed.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Only if a resident debugger was loaded, which supports this
call. The only debugger that currently supports this call is the Atari
debugger.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Dbmsg">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dbmsg"></a>4.18.4.1 Bindings for Dbmsg</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dbmsg">Dbmsg</a>( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    msg_arg,-(sp)  ; Offset 6
move.w    msg_num,-(sp)  ; Offset 4
move.w    srsrvd,-(sp)   ; Offset 2
move.w    #11,-(sp)      ; Offset 0
trap      #14            ; Call <a href="004.html">XBIOS</a>
addq.l    #10,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Janus"></a>4.18.5 Janus</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Janus« - Make the "Janus" emulator available.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">43</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Janus( int16_t mode )</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function makes the hardware emulator "Janus" available.
According to an article in <i>ST-Computer</i> 1996-04 p. 44, the
following may be achieved with this:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="right" valign="top">mode</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">Obtain the active parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">Switch to first parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">Switch to second parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">256</td>
  <td align="left" valign="top">Quit Janus</td>
</tr>
</table>
</div>

<br><br>

<b>Note:</b> All statements without any guarantees, as the
article is not very detailed.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Unknown, or see above.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">Only with hardware emulator Janus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="Janus.html#Bindings_20for_20Janus">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Janus"></a>4.18.5.1 Bindings for Janus</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Janus">Janus</a>( int16_t mode )</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mode,-(sp)    ; Offset 2
move.w    #43,-(sp)     ; Offset 0
trap      #14           ; Call <a href="004.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Puntaes"></a>4.18.6 Puntaes</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»punt AES« - Switch off <a href="008.html">AES</a> in ROM</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">39</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void Puntaes( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS function Puntaes switches off the <a href="008.html">AES</a> part of the
operating system. The <a href="008.html">AES</a> will start only if the "os_magic" in
<a href="010009.html#OSHEADER">OSHEADER</a> has the magic number 0x87654321. Puntaes sets the flag back
(if possible) and reboots the system. Note that the call is only valid
with disk-loaded <a href="008.html">AES</a>'s.<br><br>

<b>Hint: </b> As of <a href="00b.html">MagiC</a> 4.00 the function is changed.

<ul>
<li><p>long <a href="004004.html#xbios">xbios</a> ( 39, 'AnKr', 4, long key )
<br>Get cookie
<br>Return the pointer from the cookie <i>key</i> or 0L if the cookie
is not present.</p></li>
<li><p><a href="004004.html#xbios">xbios</a> ( 39, 'AnKr', 5 )
<br>????</p></li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All TOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="Puntaes.html#Bindings_20for_20Puntaes">Binding</a> &nbsp; <a href="00500e.html#S_GETCOOKIE">Cookie function</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Puntaes"></a>4.18.6.1 Bindings for Puntaes</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Puntaes">Puntaes</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #39,-(sp)    ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Random"></a>4.18.7 Random</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»random generator« - Random number generator</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">17</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Random( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS routine Random returns a 24-bit random number
(based on a clock in the computer).<br><br>

<b>Note:</b> With this function we are <i>not</i> dealing with a
hardware random number generator, but with a software version, which
uses the following algorithm:<pre>X = (X * 3.1415926...) + 1
</pre>
<br><br>

The return value is X shifted by 8 bits to the right, i.e. using
the lower three bytes of the returned int32_t. Incidentally, the
behaviour for the complete number is pretty good, the inquiry of
individual bits in the sense of reduced randomness is however
<i>not</i> advisable.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a 24-bit random number.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All TOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Random">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Random"></a>4.18.7.1 Bindings for Random</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#Random">Random</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #17,-(sp)    ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Ssbrk"></a>4.18.8 Ssbrk</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set memory break point« - Reserve memory</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">1</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">void *Ssbrk( int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS routine Ssbrk reserves memory at the top of RAM.
The number of bytes must be passed in <i>count.</i> This function
must be called prior to the initialization of <a href="005001.html">GEMDOS</a>, and should
therefore <i>not</i> be used by application programs. In all the
Atari ROM versions this function is implemented only as a dummy
routine.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the start address of the allocated memory
segment.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All TOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Ssbrk">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ssbrk"></a>4.18.8.1 Bindings for Ssbrk</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void *<a href="#Ssbrk">Ssbrk</a>( int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)  ; Offset 2
move.w    #1,-(sp)     ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Supexec"></a>4.18.9 Supexec</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»supervisor execute« - Start routine in supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">38</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t Supexec( int32_t (*func)( ) );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">The XBIOS routine Supexec executes a user-defined routine in
supervisor-mode. <i>func</i> is the address of the function to be
called in supervisor-mode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the int32_t value returned by the user
function.</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">All TOS versions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Supexec">Binding</a> &nbsp; <a href="00500e.html#Super">Super</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Supexec"></a>4.18.9.1 Bindings for Supexec</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#Supexec">Supexec</a>( int32_t (*func)( ) );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       func         ; Offset 2
move.w    #38,-(sp)    ; Offset 0
trap      #14          ; Call <a href="004.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>


</td></tr>
</table>

<h3><a name="Trapper"></a>4.18.10 Trapper</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Trapper« - Hook into system functions.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">555</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t <a href="004004.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">With the aid of Trapper, other programs can hook themselves
simply and effectively before and after system calls - even completely
replace them - or add new system calls to the system.<br><br>

With Trapper we are dealing with an external program! To be found
at: http://www.mani.de/<br><br>

More information in the instructions to be found there.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"></td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">The function is only present on computers on which the program
Trapper has been <a href="004011.html#installed">installed</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20Trapper">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20Trapper"></a>4.18.10.1 Bindings for Trapper</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="004004.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea (a2)                  ; <a href="002.html">TOS</a> does not save A2 in traps
move.l    function,-(sp)  ; Offset 8
move.w    opcode,-(sp)    ; Offset 6
move.w    install,-(sp)   ; Offset 4
move.w    layer,-(sp)     ; Offset 2
move.w    #555,-(sp)      ; Offset 0
trap      #14             ; Call <a href="004.html">XBIOS</a>
lea       12(sp),sp       ; Correct stack
move.l    (sp)+,a2        ; restore A2
</pre>


</td></tr>
</table>

<h3><a name="WdgCtrl"></a>4.18.11 WdgCtrl</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»WdgCtrl« - Set the hardware watchdog.</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top">161</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top">int32_t WdgCtrl ( int16_t OpCode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">This function disables or activates the hardware watchdog.<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Value</td>
</tr>
<tr>
  <td align="left" valign="top">OpCode</td>
  <td align="left" valign="top">0x0000 - Return 0 to check that WdgCtrl is</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;present</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x1234 - Enable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0xdead - Disable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x4242 - Re-trigger watchdog</td>
</tr>
</table>
</div>

<br><br>

<b>Note:</b> The function is only meant for the hardware of the
Milan 2.1. The version however exists only as a special version and is
not freely available.</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top"><a href="005003.html#E_OK">E_OK</a> (0)</td>
<td valign="top">- OK</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="003006.html#EUNDEV">EUNDEV</a> (-15)</td>
<td valign="top">- No watchdog present</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="003006.html#EBADRQ">EBADRQ</a> (-5)</td>
<td valign="top">- Unimplemented OpCode

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top">The function is present from MilanTOS with the date 2002-06-09
onwards.</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"><a href="#Special_20commands">Special commands</a></td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"><a href="#Bindings_20for_20WdgCtrl">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20for_20WdgCtrl"></a>4.18.11.1 Bindings for WdgCtrl</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"><br><br>

int32_t <a href="#WdgCtrl">WdgCtrl</a> ( int16_t OpCode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea (a2)                  ; <a href="002.html">TOS</a> does not save A2 in traps
move.w    OpCode,-(sp)    ; Offset 2
move.w    #161,-(sp)      ; Offset 0
trap      #14             ; Call <a href="004.html">XBIOS</a>
lea       4(sp),sp        ; Correct stack
move.l    (sp)+,a2        ; restore A2
</pre>


</td></tr>
</table>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="004011.html"><img src="udo_lf.gif" alt="Sound routines" title="Sound routines" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="004013.html"><img src="udo_rg.gif" alt="Keyboard functions" title="Keyboard functions" border="0" width="24" height="24"></a></body>
</html>

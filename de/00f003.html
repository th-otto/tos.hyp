<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Drag&Drop-Protokoll
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="00f.html"><img src="udo_up.gif" alt="Protokolle" title="Protokolle" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00f002.html"><img src="udo_lf.gif" alt="BubbleGEM" title="BubbleGEM" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00f004.html"><img src="udo_rg.gif" alt="Document-History-Protokoll" title="Document-History-Protokoll" border="0" width="24" height="24"></a>
<hr>

<h1><a name="Drag_26Drop-Protokoll"></a>15.3 Drag&Drop-Protokoll</h1>
<a name="Protokoll_2C_20Drag_26Drop-"></a>
<p>Das Drag&Drop-Protokoll wurde von Atari für das Multi-<a href="002.html">TOS</a>
entwickelt. Es handelt sich dabei um ein sehr flexibles Protokoll,
welches nicht selbst Bestandteil des Betriebssystems ist, und daher
auch unter anderen Betriebssystemvarianten eingesetzt werden könnte,
wenn diese Multitasking und <a href="00b00b.html#Pipes">Pipes</a> unterstützen.</p>

<p>AES-Nachrichtenwerden in diesem Protokoll nur dazu benutzt, um die
Kommunikationspartner zusammenzubringen; die gesamte restliche
Datenübertragung erfolgt über eine <i>Pipe</i>, auf die man mit den
gewohnten Dateifunktionen des GEMDOS zugreifen kann.</p>

<p><b>Um eine Drag&Drop-Kommunikation zu beginnen</b>, legt man in
dem Verzeichnis U:\PIPE eine Datei mit dem Namen 'DRAGDROP.xx' an,
wobei ein x jeweils für die Buchstaben A bis Z stehen kann. Dadurch
könnten theoretisch bis zu 676 gleichzeitige Drag&Drop-Vorgänge
stattfinden, was sicherlich ausreichen sollte. Zum Anlegen der Pipe
sollte man die Funktion <a href="005009.html#Fcreate">Fcreate</a> verwenden, da diese eine ordentliche
Fehlermeldung zurückliefert wenn eine gleichnamige Pipe bereits
existieren sollte. Darüberhinaus sollte beim Anlegen der Pipe das
<i>Hidden-Bit</i> (Bit-1) gesetzt werden: dadurch enthält die
lesende Seite ein End-of-File (EOF), wenn die andere Seite der Pipe
geschlossen wird.</p>

<p>Anschließend wird die Nachricht <a href="008007.html#AP_DRAGDROP">AP_DRAGDROP</a> an den Empfänger
geschickt. Da keine Rückmeldung auf diese Mitteilung vorgesehen ist,
muß sich der Sender der Funktion Fselect bedienen, um festzustellen,
ob jemand auf der Gegenseite die Pipe zum Lesen geöffent hat und
empfangsbereit ist. Atari empfiehlt in diesem Zusammenhang ein
Time-Out von drei bis vier Sekunden.</p>

<p><b>Achtung:</b> Der Sender ist leider <i>nicht</i> in der Lage
im voraus festzustellen, ob die Ziel-Applikation das
Drag&Drop-Protokoll überhaupt unterstützt. Daher ist es möglich,
daß der Anwender erst nach Ablauf der Time-Out-Zeit eine
entsprechende Mitteilung erhält. Aus diesem Grund sollten alle
Applikationen, die das Protokoll <i>nicht</i> unterstützen, eine
<a href="#D_26D-Listing_1">negative Bestätigung</a> zurückschicken, damit die lästige Wartezeit entfällt. Falls
der Empfänger hingegen zur Aufnahme der Daten bereit ist, sollte er
die Kennung <a href="00f003.html#DD_OK">DD_OK</a> (mit dem Wert 0) zurückschicken.</p>

<p>Als nächstes müssen sich beide Parteien über die Art der zu
verschickenden Daten einigen; Kernpunkt des Drag&Drop-Protokolls sind
nämlich unterschiedliche <a href="#Drag_26Drop_2C_20Datentypen_20f_C3_BCr">Arten von Datentypen</a>, die als vier Zeichen lange
Buchstabenfolgen dargestellt werden. Dazu schickt der Empfänger eine
<i>nach Präferenz sortierte</i> Liste von acht für ihn brauchbaren
Datentypen an den Sender. Eine Textverarbeitung könnte auf diese Art
z.B. mitteilen, daß sie Dateien im Rich-Text-Format (RTF) und
ASCII-Format unterstützt, und dabei ersteren den Vorzug gibt.
<b>Wichtig:</b> Wenn weniger als acht Datentypen verstanden werden, muss
der Rest der Liste mit Null-Bytes aufgefüllt werden, so daß immer
genau 32 Bytes übermittelt werden.</p>

<p>Der Sender kann dann anhand der vom Empfänger übermittelten
Liste entscheiden, welches Datenformat verwendet werden soll. Dabei
dient die übermittelte Liste jedoch nur als Richtlinie; der Sender
kann also durchaus eine andere Reihenfolge benutzen oder auch noch
andere Formate anbieten.</p>

<p><b>Die Übermittlung der eigentlichen Daten erfolgt dann in den
folgenden Schritten:</b></p>

<a name="Drag_26Drop_2C_20Header_20bei"></a>
<ul>
<li><p>Zuerst wird ein Header übermittelt, der alle Informationen
über die Daten - ihr Format und ihre Länge - enthält. Der
Empfänger kann darauf dann entsprechend reagieren. Der Header ist wie
folgt aufgebaut:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">Position</td>
  <td align="left" valign="top">Länge</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">2 Bytes</td>
  <td align="left" valign="top">Länge des Headers</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">4 Bytes</td>
  <td align="left" valign="top">Datentyp (z.B. ARGS)</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">4 Bytes</td>
  <td align="left" valign="top">Länge der zu übertragenden Daten</td>
</tr>
<tr>
  <td align="center" valign="top">10</td>
  <td align="left" valign="top">variabel(n)</td>
  <td align="left" valign="top">Name der Daten (null-terminiert)</td>
</tr>
<tr>
  <td align="center" valign="top">10+n</td>
  <td align="left" valign="top">variabel</td>
  <td align="left" valign="top">Dateiname (null-terminiert)</td>
</tr>
</table>
</div>

<br><br>

Da die Länge des Headers mit angegeben werden muss, ist dieser
für zukünftige Zwecke leicht erweiterbar.</p></li>
<li><p>Nachdem er den Header eingelesen hat, kann der Empfänger auf
diesen reagieren. So kann er beispielsweise dem Sender mitteilen, daß
er mit dem vorgeschlagenen Datenformat einverstanden ist, oder nicht.
Dies geschieht durch Senden von verschiedenen <a href="#Drag_26Drop_2C_20Status_20Bytes_20f_C3_BCr">Status-Bytes</a>.</p></li>
<li><p> Sobald der Empfänger mit <a href="00f003.html#DD_OK">DD_OK</a> geantwortet hat, wird mit der
Übertragung der Daten begonnen; dabei werden genau so viele Bytes
geschrieben, wie im Header angegeben wurden, und anschließend die
Pipe geschlossen.</p></li>
</ul>

<p><b>Wichtiger Hinweis:</b> Normalerweise wird ein Prozess vom
Kernel terminiert, wenn er in eine Pipe schreibt, die von niemandem
zum Lesen geöffnet ist. Dies läßt sich verhindern, indem man das
Signal <a href="005007.html#SIGPIPE">SIGPIPE</a> ignoriert. Ferner sollte keiner der beiden Partner ein
<a href="008009.html#wind_update">wind_update</a> benutzen, da es sonst u.U. zu einem <b>Deadlock</b>
kommen könnte, wenn eine der beiden Seiten versucht eine
Bildschirmausgabe (z.B. eine Alertbox) zu machen.</p>

<a name="Drag_26Drop_2C_20Quelltext_20f_C3_BCr"></a>
<p><b>Tip:</b> Ein Beispiel-Quelltext zum Drag&Drop-Protokoll
befindet sich z.B. in der Zeitschrift <i>ST-Computer</i> (Ausgabe
12/1993).</p>

<p>Querverweis:
<br><a href="00f001.html">AV-Protokoll</a> <a href="002002.html">GEM</a> <a href="00a002.html">Style-Guidelines</a> <a href="005004.html">Test auf Pipes</a> <a href="00f008.html">OLGA-Protokoll</a></p>

<h3><a name="D_26D-Listing_1"></a>15.3.1 D&D-Listing_1</h3>
<pre>/* Das folgende Programmfragment signalisiert dem Sender
   des Drag&Drop-Protokolls, daß das eigene Programm
   dieses Protokoll nicht versteht. */

#define <a href="008007.html#AP_DRAGDROP">AP_DRAGDROP</a>   63
#define <a href="00f003.html#DD_NAK">DD_NAK</a>         1

/* wir befinden uns nun in der Event-Schleife;
   msg ist der <a href="00f00a.html#Message">Message</a>-Puffer. */

case <a href="008007.html#AP_DRAGDROP">AP_DRAGDROP</a>:
{
    static BYTE pipename[] = "U:\\PIPE\\DRAGDROP.AA";
    LONG fd;

    pipename[18] = msg[7] & 0x00ff;
    pipename[17] = (msg[7] & 0xff00) >> 8;

    fd = <a href="005009.html#Fopen">Fopen</a> (pipename, 2);
    if (fd >= 0)
    {
        BYTE c = <a href="00f003.html#DD_NAK">DD_NAK</a>;

        <a href="005009.html#Fwrite">Fwrite</a> ((WORD) fd, 1, &c);
        <a href="005009.html#Fclose">Fclose</a> ((WORD) fd);
    }
}
break;
</pre>
<h3><a name="Drag_26Drop_2C_20Datentypen_20f_C3_BCr"></a>15.3.2 Drag&Drop, Datentypen für</h3>
<p><a href="00f00e.html#Datentypen">Datentypen</a> werden innerhalb des Drag&Drop-Protokolls durch eine
vier Zeichen lange Buchstabenfolge repräsentiert. Die folgende Liste
enthält die zur Zeit definierten <a href="00f00e.html#Datentypen">Datentypen</a>:</p>

<dl>
<dt><b>ARGS</b></dt>
<dd>
<p>steht für eine <i>Kommandozeile</i>, also i.a. einen oder
mehrere Datei- oder Verzeichnisnamen, die voneinander durch
Leerzeichen getrennt sind. Für Dateinamen die selbst Leerzeichen
enthalten, ist eine Sonderbehandlung notwendig. Dazu wird der
Dateiname in <i>einfache</i> Anführungsstriche eingeschlossen, und
jeder Anführungsstrich, der im Namen auftritt, durch einen doppelten
ersetzt.</p>

<p><b>Beispiel:</b></p>

<pre>Aus (!I)Eric's file(!i) würde (!I)'Eric''s file'(!i).
</pre>
</dd>
<dt><b>PATH</b></dt>
<dd>
<p>ist reserviert, um Informationen über das vom Benutzer
gewählte Zielobjekt zu erfragen. Die Übertragung läuft in diesem
Fall in die <i>umgekehrte</i> Richtung; d.h. der Sender liest genau
so viele Bytes wie angegeben. Hierzu muß der Empfänger nach dem
Senden von <a href="00f003.html#DD_OK">DD_OK</a> direkt die Daten übermitteln. Diese sollten den
vollständigen Pfadnamen bzw. Dateinamen des Zielfensters (mit '\'
terminiert) enthalten.</p>

</dd>
<dt><b>.XXX</b></dt>
<dd>
<p>steht für eine Extension (eines Dateinamens).
<b>Beispiele:</b></p>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">.IMG</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Grafikdaten im <a href="VDI_fundamentals.html#Das_20XIMG-Format_20f_C3_BCr_20Pixelbilder">XIMG-Format</a></td>
</tr>
<tr>
  <td align="center" valign="top">.<a href="002002.html">GEM</a></td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Grafikdaten im <a href="VDI_fundamentals.html#Metafile-Format">Metafile-Format</a></td>
</tr>
<tr>
  <td align="center" valign="top">.TXT</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Texte im <a href="010001.html">ASCII-Format</a></td>
</tr>
<tr>
  <td align="center" valign="top">.RTF</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Texte im Rich-Text-Format</td>
</tr>
</table>
</div>

</dd>
</dl>

<p>Querverweis: <a href="#Drag_26Drop-Protokoll">Drag&Drop-Protokoll</a></p>

<h3><a name="Drag_26Drop_2C_20Status_20Bytes_20f_C3_BCr"></a>15.3.3 Drag&Drop, Status Bytes für</h3>
<a name="DD_OK"></a>
<a name="DD_NAK"></a>
<a name="DD_EXT"></a>
<a name="DD_LEN"></a>
<a name="DD_TRASH"></a>
<a name="DD_PRINTER"></a>
<a name="DD_CLIPBOARD"></a>
<p>Die folgende Liste enthält alle Status-Bytes, die innerhalb einer
Drag&Drop-Kommunikation anfallen können:</p>

<pre>#define DD_OK         0    /* Ok, - weitermachen                */
#define DD_NAK        1    /* Drag&Drop abbrechen               */
#define DD_EXT        2    /* Datenformat wird nicht akzeptiert */
#define DD_LEN        3    /* Wunsch nach weniger Daten         */
#define DD_TRASH      4    /* Ziel ist ein Papierkorb-Icon      */
#define DD_PRINTER    5    /* Ziel ist ein Drucker-Icon         */
#define DD_CLIPBOARD  6    /* Ziel ist ein Klemmbrett-Icon      */
</pre>
<p>Alle anderen Werte sind für zukünftige Erweiterungen reserviert.</p>

<p><b>Hinweis:</b> Das Status-Byte DD_EXT wird verschickt, wenn der
Empfänger das angebotene Datenformat nicht mag. Der Sender wird
daraufhin einen neuen Header mit einem anderen Datenformat schicken,
oder seinerseits die Übertragung abbrechen. Dies kann sich solange
wiederholen, bis sich Sender und Empfänger auf ein Format geeinigt
haben, oder bis feststeht, daß es keine Möglichkeit der
Verständigung gibt.</p>

<p>Querverweis: <a href="#Drag_26Drop-Protokoll">Drag&Drop-Protokoll</a></p>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="00f.html"><img src="udo_up.gif" alt="Protokolle" title="Protokolle" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00f002.html"><img src="udo_lf.gif" alt="BubbleGEM" title="BubbleGEM" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00f004.html"><img src="udo_rg.gif" alt="Document-History-Protokoll" title="Document-History-Protokoll" border="0" width="24" height="24"></a></body>
</html>

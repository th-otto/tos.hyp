<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: DSP-Programmierung
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00400a.html"><img src="udo_lf.gif" alt="Druckerfunktionen" title="Druckerfunktionen" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00400c.html"><img src="udo_rg.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24"></a>
<hr>

<h1><a name="DSP-Programmierung"></a>4.11 DSP-Programmierung</h1>
<p>Auf dem Falcon stehen die folgenden Routinen zur Programmierung
des digitalen Signalprozessors DSP-56001 zur Verfügung:</p>

<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Available">Dsp_Available</a></td>
<td valign="top">Freien Speicher ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a></td>
<td valign="top">Byteweiser Datentransfer.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a></td>
<td valign="top">Datentransfer mit Handshake.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a></td>
<td valign="top">Transfer von DSP-Worten (max. 4 Byte Länge).</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_BlkWords">Dsp_BlkWords</a></td>
<td valign="top">Wortweiser Datentransfer.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_DoBlock">Dsp_DoBlock</a></td>
<td valign="top">Datentransfer zum DSP.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a></td>
<td valign="top">Bootprogramm für DSP laden.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_ExecProg">Dsp_ExecProg</a></td>
<td valign="top">DSP-Programm starten.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a></td>
<td valign="top">Unterprogramme löschen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a></td>
<td valign="top">Identifikation erfragen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_GetWordSize">Dsp_GetWordSize</a></td>
<td valign="top">Länge von DSP-Worten ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Hf0">Dsp_Hf0</a></td>
<td valign="top">Bit 3 des HSR setzen bzw. löschen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Hf1">Dsp_Hf1</a></td>
<td valign="top">Bit 4 des HSR setzen bzw. löschen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Hf2">Dsp_Hf2</a></td>
<td valign="top">Bit 3 des HCR ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Hf3">Dsp_Hf3</a></td>
<td valign="top">Bit 4 des HCR ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_HStat">Dsp_HStat</a></td>
<td valign="top">Wert des ISR-Registers ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a></td>
<td valign="top">Unterprogrammkennung ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_InStream">Dsp_InStream</a></td>
<td valign="top">Datentransfer zum DSP via Interrupt.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_IOStream">Dsp_IOStream</a></td>
<td valign="top">Datentransfer vom und zum DSP via Interrupt.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_LoadProg">Dsp_LoadProg</a></td>
<td valign="top">DSP-Programm laden und starten.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a></td>
<td valign="top">Unterprogramm installieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Lock">Dsp_Lock</a></td>
<td valign="top">Verfügbarkeit des DSP ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a></td>
<td valign="top">LOD- in Binärformat konvertieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a></td>
<td valign="top">Datentransfer vom und zum DSP.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_OutStream">Dsp_OutStream</a></td>
<td valign="top">Datentransfer vom DSP via Interrupt.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a></td>
<td valign="top">Übertragungsroutinen entfernen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a></td>
<td valign="top">Identifikation erteilen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Reserve">Dsp_Reserve</a></td>
<td valign="top">Speicher reservieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a></td>
<td valign="top">Unterprogramm ausführen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_SetVectors">Dsp_SetVectors</a></td>
<td valign="top">Eigene Übertragungsroutinen installieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_TriggerHC">Dsp_TriggerHC</a></td>
<td valign="top">Host Command ausführen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Dsp_Unlock">Dsp_Unlock</a></td>
<td valign="top">DSP freigeben.

</td></tr>
</table>

<p>Querverweis: <a href="004010.html">Schnittstellenprogrammierung</a></p>

<h3><a name="Dsp_Available"></a>4.11.1 Dsp_Available</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Available« - Ermitteln des freien x und y Speichers</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">106</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_Available( int32_t *xavailable, int32_t *yavailable );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Available ermittelt den freien X- und
Y-Speicher. Freier Speicher beginnt stets an der physikalischen
Adresse 0. Die unteren 64 Worte sind für Interrupt-Vektoren
reserviert.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Available">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp;
<a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Available"></a>4.11.1.1 Bindings für Dsp_Available</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_Available">Dsp_Available</a>( int32_t *xavailable, int32_t *yavailable );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       yavailable   ; Offset 6
pea       xavailable   ; Offset 2
move.w    #106,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_BlkBytes"></a>4.11.2 Dsp_BlkBytes</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_BlkBytes« - byteweiser Datentransfer zum DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">124</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_BlkBytes( void *data_in, int32_t size_in, void
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert <i>size_in</i> vorzeichenlose Bytes aus
dem Puffer <i>data_in</i> zum DSP. Nachdem alle Daten übertragen
wurden, wartet die Prozedur bis die Daten verarbeitet wurden. Dann
werden <i>size_out</i> 8-Bit-DSP-Worte in den Puffer <i>data_out</i>
zurückkopiert, unabhängig davon, wie viel Daten wirklich vorliegen.
Sollen keine Daten gesendet werden, muß man <i>size_in</i> auf Null
setzen. Gleiches gilt für das Empfangen, in diesem Fall wird
<i>size_out</i> Null zugewiesen. <i>size_in</i> und <i>size_out</i>
sind auf 64 KByte begrenzt. Daten werden nur ausgetauscht, wenn der
DSP-Prozeß dazu bereit ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_BlkBytes">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_BlkBytes"></a>4.11.2.1 Bindings für Dsp_BlkBytes</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a>( void *data_in, int32_t size_in, void *data_out,
int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #124,-(sp)      ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_BlkHandShake"></a>4.11.3 Dsp_BlkHandShake</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»DspBlkHandShake« - Datentransfer zum DSP mit Handshake</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">97</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_BlkHandShake( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert <i>size_in</i> DSP-Worte aus dem Puffer
<i>data_in</i> zum DSP. Nachdem alle Daten übertragen wurden, wartet
die Funktion bis die Daten verarbeitet wurden. Dann werden
<i>size_out</i> DSP-Worte in den Puffer <i>data_out</i>
zurückkopiert, unabhängig davon, wieviel Daten wirklich vorliegen.
Sollen keine Daten gesendet werden, muß man <i>size_in</i> auf Null
setzen. Gleiches gilt für das Empfangen, in diesem Fall wird
<i>size_out</i> Null zugewiesen. <i>size_in</i> und <i>size_out</i>
sind auf 64 KByte begrenzt. Daten werden nur ausgetauscht, wenn der
DSP-Prozeß dazu bereit ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_BlkHandShake">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_BlkHandShake"></a>4.11.3.1 Bindings für Dsp_BlkHandShake</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a>( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #97,-(sp)       ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_BlkUnpacked"></a>4.11.4 Dsp_BlkUnpacked</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_BlkUnpacked« - Datentransfer von maximal 4 Bytes langen
DSP-Worten</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">98</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_BlkUnpacked( int32_t *data_in, int32_t size_in,
int32_t *data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Diese Funktion arbeitet nur mit DSP-Worten, die höchstens 4
Byte lang sind. Die Länge der DSP-Worte kann mit <a href="#Dsp_GetWordSize">Dsp_GetWordSize</a>
bestimmt werden. <i>data_in</i> und <i>data_out</i> sind
LONG-Felder. <i>size_in</i> und <i>size_out</i> beziehen sich auf
die Größe der Felder in Langworten. Je nach DSP-Wortlänge werden
nur die unteren Bytes LONGs übertragen. Die Funktion kopiert
<i>size_in</i> DSP-Worte aus dem Puffer <i>data_in</i> zum DSP.
Nachdem alle Daten übertragen wurden, wartet die Funktion bis die
Daten verarbeitet wurden. Dann werden <i>size_out</i> DSP-Worte in
den Puffer data_out zurückkopiert, unabhängig davon, wieviel Daten
wirklich vorliegen. Sollen keine Daten gesendet werden, muß man
<i>size_in</i> auf Null setzen. Gleiches gilt für das Empfangen, in
diesem Fall wird <i>size_out</i> Null zugewiesen. <i>size_in</i> und
<i>size_out</i> sind auf 64 KByte begrenzt.
<br>Es wird nicht garantiert, daß die höherwertigen Bytes der
empfangenen LONGs Null sind, wenn die DSP-Wortlänge kleiner als 4
ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_BlkUnpacked">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_BlkUnpacked"></a>4.11.4.1 Bindings für Dsp_BlkUnpacked</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a>( int32_t *data_in, int32_t size_in, int32_t
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #98,-(sp)       ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_BlkWords"></a>4.11.5 Dsp_BlkWords</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_BlkWords« - wortweiser Datentransfer zum DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">123</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_BlkWords( void *data_in, int32_t size_in, void
*data_out, int32_T size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert <i>size_in</i> vorzeichenbehaftete
16-Bit-Worte aus dem Puffer <i>data_in</i> zum DSP. Die Worte werden
vor der Übertragung vorzeichenrichtig auf DSP-Wortbreite erweitert.
Nachdem alle Daten übertragen wurden, wartet die Funktion bis die
Daten verarbeitet wurden. Dann werden <i>size_out</i>
16-Bit-DSP-Worte in den Puffer <i>data_out</i> zurückkopiert,
unabhängig davon, wieviel Daten wirklich vorliegen. Sollen keine
Daten gesendet werden, muß man <i>size_in</i> auf Null setzen.
Gleiches gilt für das Empfangen, in diesem Fall wird <i>size_out</i>
Null zugewiesen. <i>size_in</i> und <i>size_out</i> sind auf 64
KByte begrenzt. Daten werden nur ausgetauscht, wenn der DSP-Prozeß
dazu bereit ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_BlkWords">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_BlkWords"></a>4.11.5.1 Bindings für Dsp_BlkWords</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_BlkWords">Dsp_BlkWords</a>( void *data_in, int32_t size_in, void *data_out,
int32_T size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #123,-(sp)      ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_DoBlock"></a>4.11.6 Dsp_DoBlock</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_DoBlock« - Datentransfer zum DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">96</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_DoBlock( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert <i>size_in</i> DSP-Worte aus dem Puffer
<i>data_in</i> zum DSP. Nachdem alle Daten übertragen wurden, wartet
die Funktion bis die Daten verarbeitet wurden. Dann werden
<i>size_out</i> DSP-Worte in den Puffer <i>data_out</i>
zurückkopiert, unabhängig davon, wieviel Daten wirklich vorliegen.
Sollen keine Daten gesendet werden, muß man <i>size_in</i> auf Null
setzen. Gleiches gilt für das Empfangen, in diesem Fall wird
<i>size_out</i> Null zugewiesen. <i>size_in</i> und <i>size_out</i>
sind auf 64 KByte begrenzt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_DoBlock">Binding</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_DoBlock"></a>4.11.6.1 Bindings für Dsp_DoBlock</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_DoBlock">Dsp_DoBlock</a>( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #96,-(sp)       ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_ExecBoot"></a>4.11.7 Dsp_ExecBoot</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_ExecBoot« - Bootprogramm für DSP laden</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">110</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_ExecBoot( int8_t *codeptr, int32_t codesize, int16_t
ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_ExecBoot lädt ein Boot-Programm in die 512
Worte des internen DSP-Speichers. Vor dem Laden wird ein Reset auf dem
DSP ausgeführt. Das DSP-Programm muß im Binär-Format vorliegen. Der
Parameter <i>codeptr</i> zeigt auf den Programmstart. Die Länge des
Programms wird durch den Parameter <i>codesize</i> bestimmt.
<i>ability</i> identifiziert das Programm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_ExecBoot">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_ExecBoot"></a>4.11.7.1 Bindings für Dsp_ExecBoot</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>( int8_t *codeptr, int32_t codesize, int16_t
ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    ability,-(sp)  ; Offset 10
move.l    codesize,-(sp) ; Offset  6
pea       codeptr        ; Offset  2
move.w    #110,-(sp)     ; Offset  0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
lea       $C(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_ExecProg"></a>4.11.8 Dsp_ExecProg</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_ExecProg« - DSP Programm starten</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">109</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_ExecProg( int8_t *codeptr, int32_t codesize, int16_t
ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_ExecProg startet das im Binär-Format an der
Stelle <i>codeptr</i> vorliegende DSP-Programm der Länge codesize.
Seine Größe darf den durch <a href="#Dsp_Reserve">Dsp_Reserve</a> reservierten Speicher nicht
überschreiten. Der Parameter <i>ability</i> identifiziert das
Programm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_ExecProg">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_ExecProg"></a>4.11.8.1 Bindings für Dsp_ExecProg</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_ExecProg">Dsp_ExecProg</a>( int8_t *codeptr, int32_t codesize, int16_t
ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    ability,-(sp)  ; Offset 10
move.l    codesize,-(sp) ; Offset  6
pea       codeptr        ; Offset  2
move.w    #109,-(sp)     ; Offset  0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
lea       $C(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_FlushSubroutines"></a>4.11.9 Dsp_FlushSubroutines</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_FlushSubroutines« - Unterprogramme aus dem Speicher des
DSP entfernen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">115</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_FlushSubroutines( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_FlushSubroutines entfernt alle Unterprogramme
aus dem DSP-Speicher und erhöht somit den verfügbaren freien
Speicher.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_FlushSubroutines">Binding</a> &nbsp; <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a> &nbsp; <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a> &nbsp;
<a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_FlushSubroutines"></a>4.11.9.1 Bindings für Dsp_FlushSubroutines</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #115,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_GetProgAbility"></a>4.11.10 Dsp_GetProgAbility</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_GetProgAbility« - Identifikation eines Prozesses
ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">114</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_GetProgAbility( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_GetProgAbility erteilt einem DSP-Prozeß eine
Identifikation, mittels derer man feststellen kann, ob der zum Prozeß
gehörige Code bereits im DSP vorhanden ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die für den Prozess gültige Kennung
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_GetProgAbility">Binding</a> &nbsp; <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_GetProgAbility"></a>4.11.10.1 Bindings für Dsp_GetProgAbility</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #114,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_GetWordSize"></a>4.11.11 Dsp_GetWordSize</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_GetWordSize« - Länge eines DSP Wortes ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">103</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_GetWordSize( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_GetWordSize ermittelt die Größe in Byte, die
ein DSP-Wort lang ist. Diese Funktion ist notwendig, um die Puffer
für die Datenübertragung ausreichend zu dimensionieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die Größe eines DSP-Wortes zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_GetWordSize">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_GetWordSize"></a>4.11.11.1 Bindings für Dsp_GetWordSize</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_GetWordSize">Dsp_GetWordSize</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #103,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Hf0"></a>4.11.12 Dsp_Hf0</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Hf0« - Bit 3 des HSR setzen bzw. löschen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">119</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Hf0( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Hf0 ermittelt bzw. setzt den Wert des Bits 3
des HSR. Der Parameter <i>flag</i> hat die folgende Bedeutung:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">flag</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;0</td>
  <td align="left" valign="top">Bit 3 des HSR löschen</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;1</td>
  <td align="left" valign="top">Bit 3 des HSR setzen</td>
</tr>
<tr>
  <td align="center" valign="top">-1</td>
  <td align="left" valign="top">Bit 3 des HSR unverändert lassen</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert von Bit-3 des HSR zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Hf0">Binding</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Hf0"></a>4.11.12.1 Bindings für Dsp_Hf0</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Hf0">Dsp_Hf0</a>( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    flag,-(sp)   ; Offset 2
move.w    #119,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Hf1"></a>4.11.13 Dsp_Hf1</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Hf1« - Bit 4 des HSR setzen bzw. löschen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">120</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Hf1( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Hf1 ermittelt bzw. setzt den Wert des Bits 4
des HSR. Der Parameter <i>flag</i> hat die folgende Bedeutung:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">flag</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;0</td>
  <td align="left" valign="top">Bit 4 des HSR löschen</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;1</td>
  <td align="left" valign="top">Bit 4 des HSR setzen</td>
</tr>
<tr>
  <td align="center" valign="top">-1</td>
  <td align="left" valign="top">Bit 4 des HSR unverändert lassen</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert von Bit-4 des HSR zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Hf1">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Hf1"></a>4.11.13.1 Bindings für Dsp_Hf1</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Hf1">Dsp_Hf1</a>( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    flag,-(sp)   ; Offset 2
move.w    #120,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Hf2"></a>4.11.14 Dsp_Hf2</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Hf2« - Bit 3 des HCR ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">121</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Hf2( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Hf2 ermittelt den Wert des Bits 3 des HCR.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert von Bit-3 des HCR zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Hf2">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Hf2"></a>4.11.14.1 Bindings für Dsp_Hf2</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Hf2">Dsp_Hf2</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #121,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Hf3"></a>4.11.15 Dsp_Hf3</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Hf3« - Bit 4 des HCR ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">122</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Hf3( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Hf3 ermittelt den Wert des Bits 4 des HCR.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert von Bit-4 des HCR zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Hf3">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Hf3"></a>4.11.15.1 Bindings für Dsp_Hf3</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Hf3">Dsp_Hf3</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #122,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_HStat"></a>4.11.16 Dsp_HStat</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_HStat« - Wert des ISR Registers ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">125</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int8_t Dsp_HStat( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_HStat ermittelt den Wert des ISR-Registers.
Somit kann man feststellen, ob Daten empfangen oder gesendet werden
können.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert des ISR-Registers zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_HStat">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_HStat"></a>4.11.16.1 Bindings für Dsp_HStat</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int8_t <a href="#Dsp_HStat">Dsp_HStat</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #125,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_InqSubrAbility"></a>4.11.17 Dsp_InqSubrAbility</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_InqSubrAbility« - Ermitteln der Kennung eines
Unterprogramms</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">117</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_InqSubrAbility( int16_t ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_InqSubrAbility bestimmt die Kennung des
Unterprogramms mit der Funktionalität <i>abilitiy.</i></td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die Kennung des Unterprogramms zurück.
Ein Rückgabewert von Null bedeutet, daß sich das entsprechende
Unterprogramm nicht im DSP-Speicher befindet; in diesem Fall muß das
Unterprogramm über Dsp_LoadSubroutine installiert werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_InqSubrAbility">Binding</a> &nbsp; <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_InqSubrAbility"></a>4.11.17.1 Bindings für Dsp_InqSubrAbility</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a>( int16_t ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    ability,-(sp)  ; Offset 2
move.w    #117,-(sp)     ; Offset 0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp          ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_InStream"></a>4.11.18 Dsp_InStream</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_InStream« - Datentransfer zum DSP via Interrupt</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">99</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_InStream( int8_t *data_in, int32_t block_size, int32_t
num_blocks, int32_t *blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert mittels DSP-Interruptbehandlung
<i>num_blocks</i> Datenblöcke mit einer Größe von
<i>block_size</i> DSP-Worten aus dem Puffer <i>data_in</i> zum DSP.
Bei jedem Interrupt wird ein Block übertragen, unabhängig davon, ob
der DSP empfangsbereit ist. Gleichzeitig wird der Zähler
<i>blocks_done</i>, der die Anzahl der übertragenen Blöcke
wiedergibt, inkrementiert. Da die Daten per Interrupt übertragen
werden, muß die Prozedur nicht warten. Über <i>blocks_done</i> kann
das Programm im weiteren Verlauf feststellen, ob die Übertragung
beendet ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_InStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_InStream"></a>4.11.18.1 Bindings für Dsp_InStream</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_InStream">Dsp_InStream</a>( int8_t *data_in, int32_t block_size, int32_t
num_blocks, int32_t *blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       blocks_done       ; Offset 14
move.l    num_blocks,-(sp)  ; Offset 10
move.l    block_size,-(sp)  ; Offset  6
pea       data_in           ; Offset  2
move.w    #99,-(sp)         ; Offset  0
trap      #14               ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_IOStream"></a>4.11.19 Dsp_IOStream</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_IOStream« - Datentransfer vom und zum DSP via Interrupt</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">101</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_IOStream( int8_t *data_in, int8_t *data_out, int32_t
block_insize, int32_t block_outsize, int32_t num_blocks, int32_t
*blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion sendet und empfängt gleichzeitig mittels
DSP-Interruptbehandlung <i>num_blocks</i> Datenblöcke mit einer
Größe von <i>block_insize</i> bzw. <i>block_outsize</i> DSP-Worten
vom DSP. Die gesendeten Daten werden dem Puffer <i>data_in</i>
entnommen, die empfangenen Daten werden im Puffer <i>data_out</i>
abgelegt. Bei jedem Interrupt wird ein Block gesendet und einer
empfangen (eine Ausnahme bilden der erste und der letzte Interrupt).
Gleichzeitig wird der Zähler <i>blocks_done</i>, der die Anzahl der
übertragenen Blöcke wiedergibt, inkrementiert. Da die Daten per
Interrupt übertragen werden, muß die Funktion nicht warten. Über
<i>blocks_done</i> kann das Programm im weiteren Verlauf feststellen,
ob die Übertragung beendet ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_IOStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_IOStream"></a>4.11.19.1 Bindings für Dsp_IOStream</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_IOStream">Dsp_IOStream</a>( int8_t *data_in, int8_t *data_out, int32_t
block_insize, int32_t block_outsize, int32_t num_blocks, int32_t
*blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       blocks_done          ; Offset 22
move.l    num_blocks,-(sp)     ; Offset 18
move.l    block_outsize,-(sp)  ; Offset 14
move.l    block_insize,-(sp)   ; Offset 10
pea       data_out             ; Offset  6
pea       data_in              ; Offset  2
move.w    #101,-(sp)           ; Offset  0
trap      #14                  ; <a href="004.html">XBIOS</a> aufrufen
lea       $1A(sp),sp           ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_LoadProg"></a>4.11.20 Dsp_LoadProg</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_LoadProg« - DSP Programm laden und starten</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">108</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_LoadProg( int8_t *file, int16_t ability, int8_t
*buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_LoadProg lädt das DSP-Programm mit dem Namen
<i>file</i>. Das Programm muß im .LOD-Format vorliegen und darf den
durch <a href="#Dsp_Reserve">Dsp_Reserve</a> reservierten Speicher nicht überschreiten. Der
Parameter <i>ability</i> identifiziert das Programm. <i>buffer</i>
zeigt auf einen Speicherbereich, in dem das generierte Programm
zwischengespeichert werden kann. Die Größe des Speicherbereichs
berechnet sich nach der Formel<pre>DSP-Wortgröße *
( Anzahl der Programm- und Datenworte in der .LOD-Datei +
( DSP-Wortgröße * Anzahl der Blöcke in der .LOD-Datei ))
</pre>
<br><br>

Danach wird das Programm ausgeführt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im positiven Fall den Wert 0, und im
Fehlerfall den Wert -1 zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_LoadProg">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_LoadProg"></a>4.11.20.1 Bindings für Dsp_LoadProg</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_LoadProg">Dsp_LoadProg</a>( int8_t *file, int16_t ability, int8_t
*buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer         ; Offset 8
move.w    ability,-(sp)  ; Offset 6
pea       file           ; Offset 2
move.w    #108,-(sp)     ; Offset 0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
lea       $C(sp),sp      ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_LoadSubroutine"></a>4.11.21 Dsp_LoadSubroutine</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_LoadSubroutine« - Unterprogramm im Speicher des DSP
installieren</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">116</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_LoadSubroutine( int8_t *codeptr, int32_t codesize,
int16_t ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_LoadSubroutine installiert das
DSP-Unterprogramm aus dem Puffer <i>codeptr</i> im DSP-Speicher. Das
Unterprogramm ist <i>codesize</i> DSP-Worte lang und hat die
Identifikation <i>ability</i>. Das Unterprogramm bleibt solange
resident im DSP-Speicher bis kein Platz mehr für neue Unterprogramme
ist und es verdrängt wird oder die Funktion Dsp_FlushSubroutines aufgerufen wird.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im Fehlerfall den Wert 0 zurück. Ein
positiver Wert kennzeichnet das Unterprogramm, das per
<a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a> aufgerufen werden kann.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_LoadSubroutine">Binding</a> &nbsp; <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_LoadSubroutine"></a>4.11.21.1 Bindings für Dsp_LoadSubroutine</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>( int8_t *codeptr, int32_t codesize,
int16_t ability );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    ability,-(sp)   ; Offset 10
move.l    codesize,-(sp)  ; Offset  6
pea       codeptr         ; Offset  2
move.w    #116,-(sp)      ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $C(sp),sp       ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Lock"></a>4.11.22 Dsp_Lock</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Lock« - Verfügbarkeit des DSP ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">104</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Lock( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Lock ermittelt, ob der DSP für Anwendungen
verfügbar ist und nicht durch jemand anders blockiert wird.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert -1, wenn der DSP bereits durch
einen anderen Prozess benutzt wird. Ein Rückgabewert von Null
kennzeichnet hingegen die Verfügbarkeit des DSP und blockiert diesen
gleichzeitig für andere, bis ein Aufruf von Dsp_Unlock erfolgt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Lock">Binding</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Lock"></a>4.11.22.1 Bindings für Dsp_Lock</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Lock">Dsp_Lock</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #104,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_LodToBinary"></a>4.11.23 Dsp_LodToBinary</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_LodToBinary« - Konvertierung einer Datei vom LOD in das
Binärformat</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">111</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Dsp_LodToBinary( int8_t *file, int8_t *codeptr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_LodToBinary konvertiert den Inhalt der
.LOD-Datei mit dem Namen <i>file</i> ins Binärformat. Das so
erzeugte DSP-Programm wird an der Adresse codeptr abgelegt. Dieser
Speicherbereich muß ausreichend groß dimensioniert sein. Danach kann
das Programm mit Dsp_ExecProg oder <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> ausgeführt werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im positiven Fall die Länge des Programms
in DSP-Worten, oder im Fehlerfall einen negativen Wert zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_LodToBinary">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_LodToBinary"></a>4.11.23.1 Bindings für Dsp_LodToBinary</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>( int8_t *file, int8_t *codeptr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       codeptr      ; Offset 6
pea       file         ; Offset 2
move.w    #111,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_MultBlocks"></a>4.11.24 Dsp_MultBlocks</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_MultBlocks« - Datentransfer vom und zum DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">127</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_MultBlocks( int32_t numsend, int32_t numreceive,
<a href="004015.html#DSPBLOCK">DSPBLOCK</a> *sendblocks, <a href="004015.html#DSPBLOCK">DSPBLOCK</a> *receiveblocks );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_MultBlocks sendet und empfängt Daten vom DSP.
<i>numsend</i> ist die Anzahl der zu sendenden und <i>numreceive</i>
die Anzahl der zu empfangenden Blöcke. <i>sendblocks</i> und
<i>receiveblocks</i> sind Zeiger auf Strukturen, die die Puffer und
Blöcke beschreiben.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_MultBlocks">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_MultBlocks"></a>4.11.24.1 Bindings für Dsp_MultBlocks</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>( int32_t numsend, int32_t numreceive, <a href="004015.html#DSPBLOCK">DSPBLOCK</a>
*sendblocks, <a href="004015.html#DSPBLOCK">DSPBLOCK</a> *receiveblocks );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       receiveblocks     ; Offset 14
pea       sendblocks        ; Offset 10
move.l    numreceive,-(sp)  ; Offset  6
move.l    numsend,-(sp)     ; Offset  2
move.w    #127,-(sp)        ; Offset  0
trap      #14               ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_OutStream"></a>4.11.25 Dsp_OutStream</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_OutStream« - Datentransfer vom DSP via Interrupt</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">100</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_OutStream( int8_t *data_out, int32_t block_size,
int32_t num_blocks, int32_t *blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion kopiert mittels DSP-Interruptbehandlung
<i>num_blocks</i> Datenblöcke mit einer Größe von
<i>block_size</i> DSP-Worten vom DSP in dem Puffer <i>data_out</i>.
Bei jedem Interrupt wird ein Block übertragen. Gleichzeitig wird der
Zähler <i>blocks_done</i>, der die Anzahl der übertragenen Blöcke
wiedergibt, inkrementiert. Da die Daten per Interrupt übertragen
werden, muß die Funktion nicht warten. Über <i>blocks_done</i> kann
das Programm im weiteren Verlauf feststellen, ob die Übertragung
beendet ist.<br><br>

<b>Hinweis:</b> Die Funktion ist nur auf Computern mit dem
Signalprozessor DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_OutStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_OutStream"></a>4.11.25.1 Bindings für Dsp_OutStream</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_OutStream">Dsp_OutStream</a>( int8_t *data_out, int32_t block_size, int32_t
num_blocks, int32_t *blocks_done );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       blocks_done       ; Offset 14
move.l    num_blocks,-(sp)  ; Offset 10
move.l    block_size,-(sp)  ; Offset  6
pea       data_out          ; Offset  2
move.w    #100,-(sp)        ; Offset  0
trap      #14               ; <a href="004.html">XBIOS</a> aufrufen
lea       $12(sp),sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_RemoveInterrupts"></a>4.11.26 Dsp_RemoveInterrupts</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_RemoveInterrupts« - Generierung von DSP Interrupts
unterbinden</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">102</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_RemoveInterrupts( int16_t mask );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_RemoveInterrupts unterbindet die Generierung
von DSP-Interrupts. Der Parameter <i>mask</i> bestimmt, welche
Interrupts betroffen sind:<table>
<tr><td nowrap="nowrap" valign="top">mask</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top">Keine Interrupts zum Senden von Daten durch den DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top">Keine Interrupts zum Empfangen von Daten durch den DSP</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top">Keine Interrupts zum Senden oder Empfangen von Daten durch den
DSP

</td></tr>
</table>

<br><br>

Die Funktion entfernt ebenfalls Routinen, die mit Dsp_SetVectors
installiert wurden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_RemoveInterrupts">Binding</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_SetVectors">Dsp_SetVectors</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_RemoveInterrupts"></a>4.11.26.1 Bindings für Dsp_RemoveInterrupts</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a>( int16_t mask );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mask,-(sp)   ; Offset 2
move.w    #102,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_RequestUniqueAbility"></a>4.11.27 Dsp_RequestUniqueAbility</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_RequestUniqueAbility« - Identifikation für Prozess
erzeugen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">113</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_RequestUniqueAbility( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_RequestUniqueAbility erteilt einem DSP-Prozeß
eine für die gesamte Systemlaufzeit eindeutige Identifikation,
mittels derer man feststellen kann, ob der zum Prozeß gehörige Code
resident im DSP vorhanden ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die für den Prozess erzeugte Kennung
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_RequestUniqueAbility">Binding</a> &nbsp; <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_RequestUniqueAbility"></a>4.11.27.1 Bindings für Dsp_RequestUniqueAbility</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #113,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Reserve"></a>4.11.28 Dsp_Reserve</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Reserve« - Speicher reservieren</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">107</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_Reserve( int32_t xreserve, int32_t yreserve );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Reserve reserviert <i>xreserve</i> Worte
X-Speicher und <i>yreserve</i> Worte Y-Speicher. Die
Speicheranforderung darf den verfügbaren Speicher auf keinen Fall
übertreffen. Diese Funktion ist notwendig, damit DSP-Prozesse nicht
durch DSP-Unterprogramme überschrieben werden. Die Reservierung
bleibt bis zum nächsten Aufruf von Dsp_Reserve bestehen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im positiven Fall den Wert 0, und im
Fehlerfall den Wert -1 zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Reserve">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a>
&nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Reserve"></a>4.11.28.1 Bindings für Dsp_Reserve</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_Reserve">Dsp_Reserve</a>( int32_t xreserve, int32_t yreserve );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    yreserve,-(sp)  ; Offset 6
move.l    xreserve,-(sp)  ; Offset 2
move.w    #107,-(sp)      ; Offset 0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp       ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_RunSubroutine"></a>4.11.29 Dsp_RunSubroutine</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»DspRunSubroutine« - Unterprogramm ausführen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">118</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Dsp_RunSubroutine( int16_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_RunSubroutine führt das Unterprogramm mit der
Kennung <i>handle</i> aus. Die Kennung für ein Unterprogramm findet
man mittels Dsp_InqSubrAbility oder <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a> heraus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im positiven Fall den Wert 0, und im
Fehlerfall eine negative Zahl zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_RunSubroutine">Binding</a> &nbsp; <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_RunSubroutine"></a>4.11.29.1 Bindings für Dsp_RunSubroutine</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a>( int16_t handle );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    handle,-(sp)  ; Offset 2
move.w    #118,-(sp)    ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_SetVectors"></a>4.11.30 Dsp_SetVectors</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_SetVectors« - Installation einer eigenen
Übertragungsroutine</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">126</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_SetVectors( void (*receiver)(), int32_t
(*transmitter)() );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_SetVectors installiert Routinen, die
aufgerufen werden, wenn der DSP über einen Interrupt Daten
übertragen will. <i>receiver</i> ist ein Zeiger auf eine Routine,
die aufgerufen wird, nachdem der DSP Daten verschickt hat, und
<i>transmitter</i> ein Zeiger auf eine Routine, die aufgerufen wird,
bevor der DSP Daten empfängt. Die Empfangsroutine <i>receiver</i>
erhält als Parameter auf dem Stack einen LONG, der vom DSP gesendet
wurde. Die Senderoutine <i>transmitter</i> übergibt einen LONG an
den DSP in Register D0. Dieser muß ungleich Null sein, damit er, d.h.
dessen niederwertigen drei Bytes an den DSP übertragen wird. Beide
Routinen werden mit dem Assemblerbefehl RTS abgeschlossen.<br><br>

Wird für <i>receiver</i> oder transmitter 0 übergeben, so wird
der entsprechende Interrupt gesperrt. Um eine Routine wieder zu
entfernen, muß man Dsp_RemoveInterrupts aufrufen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_SetVectors">Binding</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_SetVectors"></a>4.11.30.1 Bindings für Dsp_SetVectors</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_SetVectors">Dsp_SetVectors</a>( void (*receiver)(), int32_t (*transmitter)()
);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       transmitter  ; Offset 6
pea       receiver     ; Offset 2
move.w    #126,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_TriggerHC"></a>4.11.31 Dsp_TriggerHC</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_TriggerHC« - Host Kommando ausführen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">112</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_TriggerHC( int16_t vector );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_TriggerHC führt Vector <i>vector</i> aus.
Nur die zwei Vektoren $13 und $14 stehen DSP-Programmen zur freien
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_TriggerHC">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_TriggerHC"></a>4.11.31.1 Bindings für Dsp_TriggerHC</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_TriggerHC">Dsp_TriggerHC</a>( int16_t vector );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    vector,-(sp)  ; Offset 2
move.w    #112,-(sp)    ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Dsp_Unlock"></a>4.11.32 Dsp_Unlock</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Dsp_Unlock« - DSP für andere Prozesse freigeben</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">105</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Dsp_Unlock( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion Dsp_Unlock gibt den DSP für andere Prozesse frei.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#DSP-Programmierung">DSP-Programmierung</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern mit dem Signalprozessor
DSP56001 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Dsp_Unlock">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a>
&nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dsp_Unlock"></a>4.11.32.1 Bindings für Dsp_Unlock</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Dsp_Unlock">Dsp_Unlock</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #105,-(sp)   ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00400a.html"><img src="udo_lf.gif" alt="Druckerfunktionen" title="Druckerfunktionen" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00400c.html"><img src="udo_rg.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24"></a></body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: AES-Strukturen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="008.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="008015.html"><img src="udo_lf.gif" alt="AES-Funktionsliste" title="AES-Funktionsliste" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="009.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24"></a>
<hr>

<h1><a name="AES-Strukturen"></a>8.22 AES-Strukturen</h1>
<ul class="content">
	<li>8.22.1 <a href="#ANI_MOUSE">ANI_MOUSE</a>
	</li>
	<li>8.22.2 <a href="#APPFLAGS">APPFLAGS</a>
	</li>
	<li>8.22.3 <a href="#APFLG">APFLG</a>
	</li>
	<li>8.22.4 <a href="#APPLRECORD">APPLRECORD</a>
	</li>
	<li>8.22.5 <a href="#Die_20Bit-Block-Struktur">Die Bit-Block-Struktur</a>
	</li>
	<li>8.22.6 <a href="#CICON">CICON</a>
	</li>
	<li>8.22.7 <a href="#CICONBLK">CICONBLK</a>
	</li>
	<li>8.22.8 <a href="#CLRCAT">CLRCAT</a>
	</li>
	<li>8.22.9 <a href="#DIALOG">DIALOG</a>
	</li>
	<li>8.22.10 <a href="#DITHER_MODE">DITHER_MODE</a>
	</li>
	<li>8.22.11 <a href="#DRV_ENTRY">DRV_ENTRY</a>
	</li>
	<li>8.22.12 <a href="#DRV_INFO">DRV_INFO</a>
	</li>
	<li>8.22.13 <a href="#EVNT">EVNT</a>
	</li>
	<li>8.22.14 <a href="#FNTS_ITEM">FNTS_ITEM</a>
	</li>
	<li>8.22.15 <a href="#FNT_DIALOG">FNT_DIALOG</a>
	</li>
	<li>8.22.16 <a href="#HNDL_OBJ">HNDL_OBJ</a>
	</li>
	<li>8.22.17 <a href="#ICONBLK">ICONBLK</a>
	</li>
	<li>8.22.18 <a href="#LBOX_ITEM">LBOX_ITEM</a>
	</li>
	<li>8.22.19 <a href="#LIST_BOX">LIST_BOX</a>
	</li>
	<li>8.22.20 <a href="#MEDIA_SIZE">MEDIA_SIZE</a>
	</li>
	<li>8.22.21 <a href="#MEDIA_TYPE">MEDIA_TYPE</a>
	</li>
	<li>8.22.22 <a href="#MENU">MENU</a>
	</li>
	<li>8.22.23 <a href="#MFORM">MFORM</a>
	</li>
	<li>8.22.24 <a href="#MN_SET">MN_SET</a>
	</li>
	<li>8.22.25 <a href="#OBJECT">OBJECT</a>
	</li>
	<li>8.22.26 <a href="#PARMBLK">PARMBLK</a>
	</li>
	<li>8.22.27 <a href="#PDLG_HNDL">PDLG_HNDL</a>
	</li>
	<li>8.22.28 <a href="#PDLG_INIT">PDLG_INIT</a>
	</li>
	<li>8.22.29 <a href="#PDLG_RESET">PDLG_RESET</a>
	</li>
	<li>8.22.30 <a href="#PDLG_SUB">PDLG_SUB</a>
	</li>
	<li>8.22.31 <a href="#POPINFO">POPINFO</a>
	</li>
	<li>8.22.32 <a href="#PRN_DIALOG">PRN_DIALOG</a>
	</li>
	<li>8.22.33 <a href="#PRN_ENTRY">PRN_ENTRY</a>
	</li>
	<li>8.22.34 <a href="#PRN_MODE">PRN_MODE</a>
	</li>
	<li>8.22.35 <a href="#PRN_SETTINGS">PRN_SETTINGS</a>
	</li>
	<li>8.22.36 <a href="#PRN_SWITCH">PRN_SWITCH</a>
	</li>
	<li>8.22.37 <a href="#PRN_TRAY">PRN_TRAY</a>
	</li>
	<li>8.22.38 <a href="#RSHDR">RSHDR</a>
	</li>
	<li>8.22.39 <a href="#RSXHDR">RSXHDR</a>
	</li>
	<li>8.22.40 <a href="#SCANX">SCANX</a>
	</li>
	<li>8.22.41 <a href="#SET_ITEM">SET_ITEM</a>
	</li>
	<li>8.22.42 <a href="#SHELTAIL">SHELTAIL</a>
	</li>
	<li>8.22.43 <a href="#SLCT_ITEM">SLCT_ITEM</a>
	</li>
	<li>8.22.44 <a href="#SWINFO">SWINFO</a>
	</li>
	<li>8.22.45 <a href="#TEDINFO">TEDINFO</a>
	</li>
	<li>8.22.46 <a href="#USERBLK">USERBLK</a>
	</li>
	<li>8.22.47 <a href="#UTXT_FN">UTXT_FN</a>
	</li>
	<li>8.22.48 <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a>
	</li>
	<li>8.22.49 <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a>
	</li>
	<li>8.22.50 <a href="#WININFO">WININFO</a>
	</li>
	<li>8.22.51 <a href="#XAESMSG">XAESMSG</a>
	</li>
	<li>8.22.52 <a href="#XDO_INF">XDO_INF</a>
	</li>
	<li>8.22.53 <a href="#XFONTINFO">XFONTINFO</a>
	</li>
	<li>8.22.54 <a href="#XFSL_FILTER">XFSL_FILTER</a>
	</li>
	<li>8.22.55 <a href="#XSHW_COMMAND">XSHW_COMMAND</a>
	</li>
	<li>8.22.56 <a href="#XTED">XTED</a>
	</li>
	<li>8.22.57 <a href="#X_BUF_V2">X_BUF_V2</a>
	</li>
</ul>

<h3><a name="ANI_MOUSE"></a>8.22.1 ANI_MOUSE</h3>
<pre>typedef struct
{
   int16_t frames;
   int16_t delay;
   <a href="#MFORM">MFORM</a> form[32];
} ANI_MOUSE;
</pre>
<p>Querverweis: <a href="00800c.html#graf_mouse">graf_mouse</a></p>

<h3><a name="APPFLAGS"></a>8.22.2 APPFLAGS</h3>
<pre>typedef struct
{
   int8_t  name[13];
   int8_t  desc[17];
   <a href="#APFLG">APFLG</a>   flags;
   KEYCODE open_key;
   KEYCODE reserve_key[3];
}  APPFLAGS;
</pre>
<p>Querverweis: <a href="Application.html#x_appl_flags">x_appl_flags</a></p>

<h3><a name="APFLG"></a>8.22.3 APFLG</h3>
<pre>typedef <a href="00f00e.html#union">union</a>
{
   struct
   {
     unsigned multitask    :1;
     unsigned special_types:1;
     unsigned round_buttons:1;
     unsigned kbd_equivs   :1;
     unsigned undo_equivs  :1;
     unsigned off_left     :1;
     unsigned exit_redraw  :1;
     unsigned AES40_msgs   :1;
     unsigned limit_handles:1;
     unsigned limit_memory :1;
     unsigned keep_deskmenu:1;
     unsigned clear_memory :1;
     unsigned maximize_wind:1;
     unsigned unused       :3;   /* Reserved for future use       */
     unsigned mem_limit    :16;  /* Kb to limit memory allocation */
   } s;
   unsigned long l;
} APFLG;
</pre>
<p>Querverweis: <a href="Application.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APPFLAGS">APPFLAGS</a></p>

<h3><a name="APPLRECORD"></a>8.22.4 APPLRECORD</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>typedef struct
{
    int32_t type;      /* Art des Ereignisses */
    int32_t what;      /* genaue Beschreibung des Ereignisses */
} APPLRECORD
</pre>
<p><b>Für die Komponenten gilt dabei:</b></p>

<table>
<tr><td nowrap="nowrap" valign="top"><i>type</i> Bedeutung</td>
<td valign="top"><i>what</i></td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp; Timer-Event</td>
<td valign="top">Anzahl von 50-Millisekunden Ticks</td></tr>

<tr><td nowrap="nowrap" valign="top">1&nbsp;&nbsp; Button-Event</td>
<td valign="top">Status der Maustaste (High-Word), und zwar: 0 = nicht
gedrückt, 1 = gedrückt:<table>
<tr><td nowrap="nowrap" valign="top">Linke Maustaste:</td>
<td valign="top">0x0001</td></tr>

<tr><td nowrap="nowrap" valign="top">Rechte Maustaste:</td>
<td valign="top">0x0002
</td></tr>
</table>

<br>

Das (low-WORD) ist immer auf 1 gesetzt</td></tr>

<tr><td nowrap="nowrap" valign="top">2&nbsp;&nbsp; Maus-Event</td>
<td valign="top">X-Koordinate (High-Word), Y-Koordinate (Low-Word).</td></tr>

<tr><td nowrap="nowrap" valign="top">3&nbsp;&nbsp; Tastatur-Event</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">High-Word</td>
<td valign="top">Scan-Code</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word</td>
<td valign="top">Zustand der Umschaltasten (0 = nicht gedrückt, 1 = gedrückt):<table>
<tr><td nowrap="nowrap" valign="top">Shift-Rechts:</td>
<td valign="top">0x0001</td></tr>

<tr><td nowrap="nowrap" valign="top">Shift-Links:</td>
<td valign="top">0x0002</td></tr>

<tr><td nowrap="nowrap" valign="top">Control:</td>
<td valign="top">0x0004</td></tr>

<tr><td nowrap="nowrap" valign="top">Alternate:</td>
<td valign="top">0x0008
</td></tr>
</table>


</td></tr>
</table>


</td></tr>
</table>

<p><b>Hinweis:</b> Unter PC-<a href="002002.html">GEM</a> belegt jedes Ereignis nur 6 Bytes,
da die Komponente <i>type</i> von APPLRECORD dort als int16_t
definiert ist.</p>

<p>Querverweis: <a href="Application.html#appl_tplay">appl_tplay</a> &nbsp; <a href="Application.html#appl_trecord">appl_trecord</a></p>

<h3><a name="Die_20Bit-Block-Struktur"></a>8.22.5 Die Bit-Block-Struktur</h3>
<a name="BITBLK"></a>
<p>Ein Bit-Image kann immer dort eingesetzt werden, wo ein nicht
anwählbares Icon stehen könnte; der entscheidende Unterschied ist
nämlich, daß es zu einem Bit-Image <i>keine Maske</i> gibt.</p>

<pre>typedef struct
{
  int16_t  *bi_pdata;     /* Zeiger auf die Grafikdaten    */
  int16_t  bi_wb;         /* Breite des Bildes in Bytes    */
  int16_t  bi_hl;         /* Höhe in Zeilen                */
  int16_t  bi_x;          /* x-Position                    */
  int16_t  bi_y;          /* y-Position                    */
  int16_t  bi_color;      /* Farbe                         */
} BITBLK;
</pre>
<p><b>Hinweis:</b> Die Breite eines Bit-Images (Komponente
<i>bi_wb</i>) muß stets durch 2 teilbar sein.</p>

<p>Querverweis: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="008002.html#Objektarten_20des_20AES">Objektarten des AES</a></p>

<h3><a name="CICON"></a>8.22.6 CICON</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>typedef struct cicon_data
{
  int16_t num_planes;   /* Anzahl der Planes für die folgenden Daten */
  int16_t *col_data;    /* Zeiger auf Farb-Bitmap in Standardform    */
  int16_t *col_mask;    /* Zeiger auf einzelne Farb-Plane Maske      */
  int16_t *sel_data;    /* Zeiger auf Farb-Bitmap des selekt. Icons  */
  int16_t *sel_mask;    /* Zeiger auf einzelne Plane-Maske des Icons */
  struct cicon_data *next_res; /* Zeiger auf Icon anderer Auflösung */
} CICON;
</pre>
<p>Querverweis: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#ICONBLK">ICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a></p>

<h3><a name="CICONBLK"></a>8.22.7 CICONBLK</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>typedef struct cicon_blk
{
   <a href="#ICONBLK">ICONBLK</a> monoblk;    /* Default: monochrome Icons */
   <a href="#CICON">CICON</a>   *mainlist;  /* Farb-Icons für verschiedene Auflösungen */
} CICONBLK;
</pre>
<p>Querverweis: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="008002.html#Die_20Objekt-Struktur">Objektstruktur im AES</a></p>

<h3><a name="CLRCAT"></a>8.22.8 CLRCAT</h3>
<pre>typedef struct clrcat
{
  int16_t cc_foreground     /* Foreground colour    */
  int16_t cc_background     /* Background colour    */
  int16_t cc_style          /* Fill style           */
  int16_t cc_pattern        /* Fill pattern         */
} CLRCAT;
</pre>
<p>The CLRCAT is used internally by ViewMAX/2 and later to store the
colour categories.</p>

<p>Querverweise: <a href="#X_BUF_V2">X_BUF_V2</a></p>

<h3><a name="DIALOG"></a>8.22.9 DIALOG</h3>
<pre>typedef void *DIALOG;
</pre>
<h3><a name="DITHER_MODE"></a>8.22.10 DITHER_MODE</h3>
<pre>typedef struct _dither_mode
{
   struct _dither_mode  *next;    /* Zeiger auf Nachfolger     */
   int32_t       length;          /* Strukturlänge             */
   int32_t       format;          /* Datenformat               */
   int32_t       reserved;        /* reserviert                */
   int32_t       dither_id;       /* Kennung                   */
   int32_t       color_modes;     /* unterstützte Farbtiefen   */
   int32_t       reserved1;       /* reserviert                */
   int32_t       reserved2;       /* reserviert                */
   int8_t        name[32];        /* Name des Rasterverfahrens */
} DITHER_MODE;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="DRV_ENTRY"></a>8.22.11 DRV_ENTRY</h3>
<pre>typedef struct _drv_entry
{
   struct _drv_entry *next; /* Zeiger auf Nachfolger */
} DRV_ENTRY;
</pre>
<h3><a name="DRV_INFO"></a>8.22.12 DRV_INFO</h3>
<pre>typedef struct
{
   int32_t     magic;           /* 'pdnf'                           */
   int32_t     length;          /* Strukturlänge                    */
   int32_t     format;          /* Datenformat                      */
   int32_t     reserved;        /* reserviert                       */
   int16_t     driver_id;       /* Treibernummer fürs <a href="007.html">VDI</a>           */
   int16_t     driver_type;     /* Treibertyp                       */
   int32_t     reserved1;       /* reserviert                       */
   int32_t     reserved2;       /* reserviert                       */
   int32_t     reserved3;       /* reserviert                       */
   <a href="#PRN_ENTRY">PRN_ENTRY</a>   *printers;       /* zum Treiber gehörenden Drucker   */
   <a href="#DITHER_MODE">DITHER_MODE</a> *dither_modes;   /* unterstützte Rasterverfahren     */
   int32_t     reserved4;       /* reserviert                       */
   int32_t     reserved5;       /* reserviert                       */
   int32_t     reserved6;       /* reserviert                       */
   int32_t     reserved7;       /* reserviert                       */
   int32_t     reserved8;       /* reserviert                       */
   int32_t     reserved9;       /* reserviert                       */
   int8_t      device[128];     /* Ausgabedatei des Druckertreibers */
} DRV_INFO;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="EVNT"></a>8.22.13 EVNT</h3>
<pre>typedef struct
{
    int16_t mwhich;         /* Art der Ereignisse                */
    int16_t mx;             /* x-Koordinate des Mauszeigers      */
    int16_t my;             /* y-Koordinate des Mauszeigers      */
    int16_t mbutton;        /* gedrückte Maustaste               */
    int16_t kstate;         /* Status der Sondertasten (kbshift) */
    int16_t key;            /* Scancode der gedrückten Taste     */
    int16_t mclicks;        /* Anzahl der Mausklicks             */
    int16_t reserved[9];    /* reserviert                        */
    int16_t msg[16];        /* <a href="00f00a.html#Message">Message</a>-Buffer                    */
} EVNT;
</pre>
<p>Querverweis: <a href="008014.html#fnts_evnt">fnts_evnt</a> &nbsp; <a href="00800a.html#fslx_evnt">fslx_evnt</a> &nbsp; <a href="008008.html#wdlg_evnt">wdlg_evnt</a></p>

<h3><a name="FNTS_ITEM"></a>8.22.14 FNTS_ITEM</h3>
<pre>typedef struct _fnts_item
{
  struct   _fnts_item  *next; /* Zeiger auf den nächsten Font oder 0L */
  <a href="#UTXT_FN">UTXT_FN</a>  display;           /* Anzeige-Funktion für eigene Fonts    */
  int32_t  id;                /* ID des Fonts                         */
  int16_t  index;             /* muß 0 sein, da kein <a href="007.html">VDI</a>-Font         */
  int8_t   mono;              /* Flag für äquidistante Fonts          */
  int8_t   outline;           /* Flag für Vektorfont                  */
  int16_t  npts;              /* Anzahl der vordefinierten Punkthöhen */
  int8_t   *full_name;        /* Zeiger auf den vollständigen Namen   */
  int8_t   *family_name;      /* Zeiger auf den Familiennamen         */
  int8_t   *style_name;       /* Zeiger auf den Stilnamen             */
  int8_t   *pts;              /* Zeiger auf Feld mit Punkthöhen       */
  int32_t  reserved[4];       /* reserviert, müssen 0 sein            */
} FNTS_ITEM;
</pre>
<p>Querverweis: <a href="008014.html#fnts_add">fnts_add</a> &nbsp; <a href="008014.html">Zeichensatzauswahl</a></p>

<h3><a name="FNT_DIALOG"></a>8.22.15 FNT_DIALOG</h3>
<pre>typedef void *FNT_DIALOG;
</pre>
<h3><a name="HNDL_OBJ"></a>8.22.16 HNDL_OBJ</h3>
<pre>typedef int16_t (cdecl *HNDL_OBJ) ( void *dialog, <a href="#EVNT">EVNT</a> *events, int16_t obj,
                                 int16_t clicks, void *data );
</pre>
<p>Dabei gilt:</p>

<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>dialog</i></td>
<td valign="top">Zeiger auf eine Dialogstruktur. Auf diese sollte nicht direkt,
sondern nur mit Hilfe der wdlg_xxx Funktionen zugegriffen werden.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>events</i></td>
<td valign="top">Zeiger auf die <a href="#EVNT">EVNT</a>-Strukur, die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a> übergeben wurde
(falls der Parameter <i>obj</i> >= 0 ist), oder NULL.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj</i></td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">>=0:</td>
<td valign="top">Objektnummer</td></tr>

<tr><td nowrap="nowrap" valign="top"><0:</td>
<td valign="top">Funktionsnummer:<pre> -1 = <a href="#HNDL_INIT">HNDL_INIT</a>    // Dialog initialisieren
 -2 = <a href="#HNDL_MESG">HNDL_MESG</a>    //
 -3 = <a href="#HNDL_CLSD">HNDL_CLSD</a>    // Dialogfenster wurde geschlossen
 -5 = <a href="#HNDL_OPEN">HNDL_OPEN</a>    // Dialog-Initialisierung abschließen
 -6 = <a href="#HNDL_EDIT">HNDL_EDIT</a>    // Zeichen für ein Editfeld prüfen
 -7 = <a href="#HNDL_EDDN">HNDL_EDDN</a>    // Zeichen wurde ins Editfeld gesetzt
 -8 = <a href="#HNDL_EDCH">HNDL_EDCH</a>    // Editfeld wurde gewechselt
 -9 = <a href="#HNDL_MOVE">HNDL_MOVE</a>    // Dialog wurde verschoben
-10 = <a href="#HNDL_TOPW">HNDL_TOPW</a>    // Dialogfenster kam nach oben
-11 = <a href="#HNDL_UNTP">HNDL_UNTP</a>    // Dialogfenster ist nicht aktiv
</pre>

</td></tr>
</table>

<br>

Von diesen Funktionsnummern muß nur auf <a href="#HNDL_CLSD">HNDL_CLSD</a> reagiert
werden; alle anderen Ereignisse können je nach Bedarf beachtet
werden.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>clicks</i></td>
<td valign="top">Anzahl der Mausklicks, falls es sich bei <i>obj</i> um eine
Objektnummer handelt.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>data</i></td>
<td valign="top">Falls der Parameter <i>obj</i> eine positive Objektnummer ist,
wird hier die Variable <i>user_data</i> aus der Funktion <a href="008008.html#wdlg_create">wdlg_create</a>
übergeben. Anderenfalls ist der Wert von der entsprechenden
Funktionsnummer abhängig.

</td></tr>
</table>

<p><b>Hinweis:</b> Die Funktion wird aufgerufen, wenn auf ein <a href="008002.html#EXIT">EXIT</a>-
oder <a href="008002.html#TOUCHEXIT">TOUCHEXIT</a> Objekt geklickt wurde (in diesem Fall ist <i>obj</i>
eine positive Objektnummer) oder wenn ein den Dialog betreffendes
Ereignis eingetreten ist (dann ist <i>obj</i> negativ und enthält
eine entsprechende Funktionsnummer (s.o.)).</p>

<p>Die Parameter werden über den Stack übergeben und die Routine
darf die Register d0-d2/a0-a2 verändern. Falls die Funktion mit einer
unbekannten Funktionsnummer in <i>obj</i> aufgerufen wird oder eine
der obigen Funktionsnummern ignoriert werden soll, muß der Wert 1
zurückgeliefert werden.</p>

<p>Querverweis: <a href="#Beispiel_20zu_20HNDL_OBJ">Beispiel-Implementation</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="Beispiel_20zu_20HNDL_OBJ"></a>8.22.16.1 Beispiel zu HNDL_OBJ</h4>
<pre>/* Der folgende Code ist ein Beispiel für eine Implementation
   der handle_exit Funktion, wie sie z.B. als Parameter bei
   <a href="008008.html#wdlg_create">wdlg_create</a> vorkommt. */

int16_t cdecl handle_exit ( void *dialog, <a href="#EVNT">EVNT</a> *events, int16_t obj,
                         int16_t clicks, void *data )
{
    /*
     * Ereignis oder Objektnummer?
     * Alle Ereignisse außer <a href="#HNDL_CLSD">HNDL_CLSD</a> werden bei diesem Beispiel
     * ignoriert
     */

    if ( obj < 0 )
    {
        if ( obj == <a href="#HNDL_CLSD">HNDL_CLSD</a> )     /* Closer betätigt? */
            return( 0 );            /* beenden */
        if ( obj == <a href="#HNDL_EDIT">HNDL_EDIT</a> )
        {
            /*  In Fensterdialogen kann es nützlich sein, Tasten-
                kombinationen mit Control in Eingabefeldern zu igno-
                rieren, damit Shortcuts wie z.B. Ctrl-U, Ctrl-W oder
                Ctrl-Q in der Eventschleife des Programms abgearbei-
                tet werden können. In diesem Fall sollte nach <a href="#HNDL_EDIT">HNDL_EDIT</a>
                eine 0 zurückgeliefert werden, damit die Taste nicht
                von <a href="008010.html#objc_edit">objc_edit</a> bearbeitet wird.
            */
        }
    }
    else
    {                         /* ein Objekt ist angewählt worden  */
        switch ( obj )        /* Aktionen einleiten (falls nötig) */
        {
            case ...
              .
              .
              .
            case MY_<a href="008002.html#EXIT">EXIT</a>_<a href="#OBJECT">OBJECT</a>:    ..... return( 0 );  /* beenden */
        }
    }
    return( 1 ); /* weitermachen */
}
</pre>
<h4><a name="HNDL_INIT"></a>8.22.16.2 HNDL_INIT</h4>
<p><i>data</i> ist die bei <b>wdlg_init</b> übergebene Variable.
Falls handle_exit den Wert 0 zurückliefert, legt <b><a href="008008.html#wdlg_create">wdlg_create</a></b>
keine Dialog-Struktur an (Fehler). Die Variable code wird in
<i>clicks</i> übergeben.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_MESG"></a>8.22.16.3 HNDL_MESG</h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück. <i>events</i> zeigt auf die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a>
übergebene <a href="#EVNT">EVNT</a>-Struktur.</p>

<p><b>Hinweis:</b> Dieser Code wird nur dann übergeben, wenn ein
Nachrichtencode zwischen 20 und 39 empfangen wurde, der nicht mit den
anderen Opcodes bearbeitet wird. Er wird z.B. für die Ikonifizierung
benötigt.</p>

<p><b>Achtung:</b> Dieser Opcode wird erst seit der <a href="00b.html">MagiC</a> Version
4.50 vom 18.04.96 unterstützt.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_OPEN"></a>8.22.16.4 HNDL_OPEN</h4>
<p><i>data</i> ist die bei <b><a href="008008.html#wdlg_open">wdlg_open</a></b> übergebene Variable.
Die Variable code wird in <i>clicks</i> übergeben.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_CLSD"></a>8.22.16.5 HNDL_CLSD</h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.</p>

<p><i>events</i> zeigt auf die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a> überg. <a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_MOVE"></a>8.22.16.6 HNDL_MOVE</h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.</p>

<p><i>events</i> zeigt auf die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a> überg. <a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_TOPW"></a>8.22.16.7 HNDL_TOPW</h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.</p>

<p><i>events</i> zeigt auf die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a> überg. <a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_UNTP"></a>8.22.16.8 HNDL_UNTP</h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.</p>

<p><i>events</i> zeigt auf die bei <a href="008008.html#wdlg_evnt">wdlg_evnt</a> überg. <a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDIT"></a>8.22.16.9 HNDL_EDIT</h4>
<p><i>data</i> zeigt auf ein Wort mit dem Tastencode. Falls
handle_exit den Wert 1 zurückliefert, wird der Tastendruck
verarbeitet, bei 0 ignoriert.</p>

<p><i>events</i> zeigt auf die bei <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b> überg.
<a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDDN"></a>8.22.16.10 HNDL_EDDN</h4>
<p><i>data</i> zeigt auf ein Wort mit dem Tastencode. <i>events</i>
zeigt auf die bei <b><a href="008008.html#wdlg_evnt">wdlg_evnt</a></b> überg. <a href="#EVNT">EVNT</a>-Struktur.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h4><a name="HNDL_EDCH"></a>8.22.16.11 HNDL_EDCH</h4>
<p><i>data</i> zeigt auf ein Wort mit der Objektnummer des neuen
Edit-Felds.</p>

<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="008008.html#wdlg_create">wdlg_create</a></p>

<h3><a name="ICONBLK"></a>8.22.17 ICONBLK</h3>
<pre>typedef struct
{
  uint16_t  *ib_pmask;    /* Zeiger auf die Icon-Maske     */
  uint16_t  *ib_pdata;    /* Zeiger auf das Icon-Bild      */
  int8_t    *ib_ptext;    /* Zeiger auf den Icon-Text      */
  uint16_t  ib_char;      /* Zeichen das im Icon erschei-
                             nen soll, sowie Vorder- und
                             Hintergrundfarbe des Icons    */
  uint16_t  ib_xchar;     /* x-Koordinate des Buchstabens  */
  uint16_t  ib_ychar;     /* y-Koordinate des Buchstabens  */
  uint16_t  ib_xicon;     /* x-Koordinate des Icons        */
  uint16_t  ib_yicon;     /* y-Koordinate des Icons        */
  uint16_t  ib_wicon;     /* Breite des Icons              */
  uint16_t  ib_hicon;     /* Höhe des Icons                */
  int16_t   ib_xtext;     /* x-Koordinate des Textes       */
  int16_t   ib_ytext;     /* y-Koordinate des Textes       */
  uint16_t  ib_wtext;     /* Breite des Textes             */
  uint16_t  ib_htext;     /* Höhe des Textes               */
  uint16_t  ib_resvd;     /* reserviert                    */
} ICONBLK;
</pre>
<p><b>Hinweise zu einzelnen Komponenten:</b></p>

<ul>
<li><p><b>ib_pmask:</b> Zeiger auf ein Feld von 16-Bit-Werten, in
denen das Bit-Image der Icon-Maske abgelegt ist. Die Icon-Maske legt
fest, an welchen Stellen das Icon überhaupt gezeichnet werden soll
und welche Pixel transparent bleiben sollen. Erzielt wird dieser
Effekt dadurch, daß der Iconhintergrund zunächst mit den Bits der
Maske 'undiert' und dann mit den Icondaten 'geodert' wird.</p></li>
<li><p><b>ib_char:</b><br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Bits</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">15..12</td>
  <td align="left" valign="top">Vordergrundfarbe des Icons</td>
</tr>
<tr>
  <td align="left" valign="top">11..08</td>
  <td align="left" valign="top">Hintergrundfarbe des Icons</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;7..&nbsp;0</td>
  <td align="left" valign="top">Zeichen das im Icon erscheinen soll</td>
</tr>
</table>
</div>

</p></li>
<li><p><b>ib_resvd:</b> unbenutzt, wird allerdings von den meisten
RCS-Programmen beim Schreiben in die Resourcedatei aufgenommen.</p></li>
</ul>

<p>Für Farbicon unter PC <a href="002002.html">GEM</a> gilt:
<br>In a colour icon, ib_pdata and ib_pmask point to <a href="00700d.html#MFDB">MFDB</a> objects.
Otherwise, they point to the lines of the bitmap.</p>

<p>Querverweis: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a></p>

<h3><a name="LBOX_ITEM"></a>8.22.18 LBOX_ITEM</h3>
<pre>typedef struct _lbox_item
{
   struct _lbox_item *next;  /* Zeiger auf den nächsten Eintrag */
                             /* in der Scroll-Liste             */
   int16_t  selected;        /* Objekt selektiert?              */
   int16_t  data1;           /* Daten für das Programm          */
   void     *data2;
   void     *data3;
} LBOX_ITEM;
</pre>
<p><b>Hinweis:</b> Die Struktur kann aber, wenn bei den Aufrufen
entsprechend gecastet wird, durchaus wie das folgende Beispiel
aussehen:</p>

<pre>typedef struct
{
   void     *next;
   int16_t   selected;

   ... ab hier nach Belieben der Applikation...
} LB_EXAMPLE;
</pre>
<p>Es ist lediglich darauf zu achten, daß als erstes Element ein
Zeiger auf den Nachfolger, und als zweites Element ein Wort das
angibt, ob der entsprechende Eintrag selektiert ist, vorhanden ist.</p>

<p>Querverweis:
<br><a href="00800e.html#lbox_create">lbox_create</a> &nbsp; <a href="00800e.html#lbox_free_list">lbox_free_list</a> &nbsp; <a href="00800e.html#lbox_get_idx">lbox_get_idx</a> &nbsp; <a href="00800e.html#lbox_get_item">lbox_get_item</a> &nbsp;
<a href="00800e.html#lbox_get_items">lbox_get_items</a></p>

<h3><a name="LIST_BOX"></a>8.22.19 LIST_BOX</h3>
<pre>typedef void *LIST_BOX;
</pre>
<h3><a name="MEDIA_SIZE"></a>8.22.20 MEDIA_SIZE</h3>
<p>Diese Struktur dient der Beschreibung eines Papierformates, und
ist wie folgt definiert:</p>

<pre>typedef struct _media_size
{
   struct _media_size *next;   /* Zeiger auf Nachfolger     */
   int32_t       size_id;      /* Kennung des Papierformats */
   int8_t        name[32];     /* Name des Papierformats    */
} MEDIA_SIZE;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="MEDIA_TYPE"></a>8.22.21 MEDIA_TYPE</h3>
<p>Diese Struktur dient der Beschreibung eines Papiertyps bzw.
Druckmediums, und ist wie folgt definiert:</p>

<pre>typedef struct _media_type
{
   struct _media_type   *next;    /* Zeiger auf Nachfolger     */
   int32_t              type_id;  /* Kennung des Papierformats */
   int8_t               name[32]; /* Name des Papierformats    */
} MEDIA_TYPE;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="MENU"></a>8.22.22 MENU</h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *mn_tree;    /* Adresse des Menü-Objektbaumes  */
    int16_t mn_menu;     /* <a href="indexudo.html">Index</a> des Parent-Objektes      */
    int16_t mn_item;     /* Anfangs-Menüeintrag (bestimmt  */
                         /* die Position des Menüs         */
    int16_t mn_scroll;   /* 0 = nicht scrollen             */
                         /* >0 = scrollen                  */
    int16_t mn_keystate; /* Tastaturstatus (Shift, Control */
                         /* bzw. Alternate)                */
} MENU;
</pre>
<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="00800f.html#menu_attach">menu_attach</a> &nbsp; <a href="00800f.html#menu_popup">menu_popup</a></p>

<h3><a name="MFORM"></a>8.22.23 MFORM</h3>
<p>Die Struktur MFORM legt das Aussehen des Mauszeigers fest, und ist
wie folgt definiert:</p>

<pre>typedef struct mfstr
{
    int16_t  mf_xhot;       /* X-Pos. Aktionspunkt */
    int16_t  mf_yhot;       /* Y-Pos. Aktionspunkt */
    int16_t  mf_nplanes;    /* Anzahl der Planes   */
    int16_t  mf_fg;         /* Maskenfarbe         */
    int16_t  mf_bg;         /* Zeigerfarbe         */
    int16_t  mf_mask[16];   /* Maskenform          */
    int16_t  mf_data[16];   /* Zeigerform          */
} MFORM;
</pre>
<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="00800c.html#graf_mouse">graf_mouse</a></p>

<h3><a name="MN_SET"></a>8.22.24 MN_SET</h3>
<pre>typedef struct
{
    int32_t display;    /* Anzeigeverzögerung              */
    int32_t drag;       /* Auswahlverzögerung              */
    int32_t delay;      /* Einfachklick Scroll-Verzögerung */
    int32_t speed;      /* Scroll-Verzögerung              */
    int16_t height;     /* Scroll-Höhe (Anzahl der darzu-  */
                        /* stellenden Einträge)            */
} MN_SET;
</pre>
<p>Alle Verzögerungszeiten werden in Millisekunden gemessen.</p>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="00800f.html#menu_settings">menu_settings</a></p>

<h3><a name="OBJECT"></a>8.22.25 OBJECT</h3>
<pre>typedef struct
{
   int16_t    ob_next;   /* das nächste Objekt            */
   int16_t    ob_head;   /* erstes Kind                   */
   int16_t    ob_tail;   /* letztes Kind                  */
   uint16_t   ob_type;   /* Objektart                     */
   uint16_t   ob_flags;  /* Manipulationsflags            */
   uint16_t   ob_state;  /* Objektstatus                  */
   void       *ob_spec;  /* mehr unter Objektart          */
   int16_t    ob_x;      /* x-Koordinate des Objekts      */
   int16_t    ob_y;      /* y-Koordinate des Objekts      */
   int16_t    ob_width;  /* Breite des Objekts            */
   int16_t    ob_height; /* Höhe des Objekts              */
} OBJECT;
</pre>
<table>
<tr><td nowrap="nowrap" valign="top"><b>ob_next:</b></td>
<td valign="top">Nummer das folgenden Objekts gleicher Ebene oder -falls es das
letzte Element in der Ebene ist - es Parent-Objekt.</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_head:</b></td>
<td valign="top">Nummer des erstes Kind des Objekts, falls keines -1</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_next:</b></td>
<td valign="top">Nummer des letzen Kind des Objekts, falls keines -1</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_type:</b></td>
<td valign="top"> Objektarten des AES</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_flags:</b></td>
<td valign="top"> Objektflags des AES</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_state:</b></td>
<td valign="top"> Objektstati des AES

</td></tr>
</table>

<p>Querverweis: <a href="008002.html#Die_20Objekt-Struktur">Objektstruktur im AES</a></p>

<h3><a name="PARMBLK"></a>8.22.26 PARMBLK</h3>
<pre>typedef struct
{
   <a href="#OBJECT">OBJECT</a>   *pb_tree;        /* Zeiger auf den Objektbaum        */
   int16_t  pb_obj;          /* Nummer des Objekts               */
   int16_t  pb_prevstate;    /* vorheriger Objektstatus          */
   int16_t  pb_currstate;    /* neuer Objektstatus               */
   int16_t  pb_x;            /* x-Position des Objektes          */
   int16_t  pb_y;            /* y-Position des Objektes          */
   int16_t  pb_w;            /* Breite des Objektes              */
   int16_t  pb_h;            /* Höhe des Objektes                */
   int16_t  pb_xc;           /* x-Position des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs */
   int16_t  pb_yc;           /* y-Position des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs */
   int16_t  pb_wc;           /* Breite des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs     */
   int16_t  pb_hc;           /* Höhe des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs       */
   int32_t  pb_parm;         /* Parameter der <a href="#USERBLK">USERBLK</a>-Struktur   */
} PARMBLK;
</pre>
<p><b>Hinweis:</b> Das Objekt muß nur neu gezeichnet werden, wenn
alter und neuer Status identisch sind; anderenfalls reicht ein
'Update' des Objektbaums aus. Ferner sollten folgende Punkte beachtet
werden:</p>

<ul>
<li><p> die eigene Funktion muß im Datenregister d0 dem AES
zurückliefern, welche Aspekte des Objektstatus noch aktualisiert
werden müssen. Damit ist es nicht unbedingt nötig, in der eigenen
Ausgabefunktion den Code zum invertieren des Objektes
auszuprogrammieren. Im allgemeinen wird man einige Bits des
Objektstatus selbst bearbeiten wollen, und andere dem AES
überlassen.</p></li>
<li><p> die Funktion erhält den PARMBLK-Zeiger auf dem Stack, und
muß daher in Pure-C als 'cdecl' deklariert werden.</p></li>
<li><p> ein vollständiges Neuzeichnen des Objektes ist nur dann
nötig, wenn die Komponenten <i>pb_prevstate</i> und
<i>pb_currstate</i> gleich sind; anderenfalls hat sich nur der
Objektstatus geändert (zum Beispiel durch Anklicken).</p></li>
<li><p> die eigene Funktion wird de facto als Unterprogramm der
AES ausgeführt. Daher sollte man im Hinblick auf die
Stackbenutzung vorsichtig sein. Außerdem darf man natürlich
<i>keine</i> weiteren AES-Aufrufe machen, da das AES
<i>nicht</i> re-entrant ist. Aufrufe der <a href="007.html">VDI</a>-<a href="007007.html">Eingabefunktionen</a> sind
hingegen an dieser Stelle erlaubt.</p></li>
<li><p> die Komponente <i>pb_parm</i> dient dazu, der eigenen
Funktion weitere Informationen (wie etwa einen Zeiger auf einen
String) mit auf den Weg zu geben.</p></li>
<li><p> man sollte sich nie zu weit von der ursprünglichen Optik von
GEM entfernen. Abgerundete Rechtecke oder kursive Texte passen
sicherlich nicht in das normale Erscheinungsbild einer
GEM-Applikation.</p></li>
</ul>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="#USERBLK">USERBLK</a></p>

<h3><a name="PDLG_HNDL"></a>8.22.27 PDLG_HNDL</h3>
<pre>typedef int32_t (cdecl *PDLG_HNDL)( struct _prn_settings *settings,
                                 struct _pdlg_sub *sub,
                                 int16_t exit_obj );
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_INIT"></a>8.22.28 PDLG_INIT</h3>
<pre>typedef int32_t (cdecl *PDLG_INIT) (struct _prn_settings *settings,
                                 struct _pdlg_sub *sub );
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_RESET"></a>8.22.29 PDLG_RESET</h3>
<pre>typedef int32_t (cdecl *PDLG_RESET) ( struct _prn_settings *settings,
                                   struct _pdlg_sub *sub );
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a></p>

<h3><a name="PDLG_SUB"></a>8.22.30 PDLG_SUB</h3>
<p>Diese Struktur dient der Beschreibung einer Geräteeinstellung,
und ist wie folgt definiert:</p>

<pre>typedef struct _pdlg_sub
{
   struct _pdlg_sub *next;      /* Zeiger auf Nachfolger           */
   int32_t     length;          /* Strukturlänge                   */
   int32_t     format;          /* Datenformat                     */
   int32_t     reserved;        /* reserviert                      */
   void        *drivers;        /* nur für interne Dialoge         */
   int16_t     option_flags;    /* verschiedene Flags              */
   int16_t     sub_id;          /* Kennung des Unterdialogs        */
   <a href="#DIALOG">DIALOG</a>      *dialog;         /* Zeiger auf die Struktur des
                                   Fensterdialogs oder 0L          */
   <a href="#OBJECT">OBJECT</a>      *tree;           /* Zeiger auf den Objektbaum       */
   int16_t     index_offset;    /* Offset des Unterdialogs         */
   int16_t     reserved1;       /* reserviert                      */
   int32_t     reserved2;       /* reserviert                      */
   int32_t     reserved3;       /* reserviert                      */
   int32_t     reserved4;       /* reserviert                      */
   <a href="#PDLG_INIT">PDLG_INIT</a>   init_dlg;        /* Initialisierungsfunktion        */
   <a href="#PDLG_HNDL">PDLG_HNDL</a>   do_dlg;          /* Behandlungsfunktion             */
   <a href="#PDLG_RESET">PDLG_RESET</a>  reset_dlg;       /* Zurücksetzfunktion              */
   int32_t     reserved5;       /* reserviert                      */
   <a href="#OBJECT">OBJECT</a>      *sub_icon;       /* Zeiger auf das Icon der Listbox */
   <a href="#OBJECT">OBJECT</a>      *sub_tree;       /* Objektbaum des Unterdialogs     */
   int32_t     reserved6;       /* reserviert                      */
   int32_t     reserved7;       /* reserviert                      */
   int32_t     private1;        /* dialogeigene Informationen-1    */
   int32_t     private2;        /* dialogeigene Informationen-2    */
   int32_t     private3;        /* dialogeigene Informationen-3    */
   int32_t     private4;        /* dialogeigene Informationen-4    */
} PDLG_SUB;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a></p>

<h3><a name="POPINFO"></a>8.22.31 POPINFO</h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *tree;     /* <a href="009001.html#Popup">Popup</a>-Menü                  */
    int16_t  obnum;    /* aktuelles Objekt von <tree> */
} POPINFO;
</pre>
<p><b>Hinweis:</b> Die Komponente tree zeigt auf einen Objektbaum,
der etwa für <a href="00800b.html#form_popup">form_popup</a> als Eingabe dienen könnte. D.h. die Box
sollte als Objekt 0 eine <a href="008002.html#G_BOX">G_BOX</a> oder <a href="008002.html#G_IBOX">G_IBOX</a> enthalten, die von den
anderen Objekten vollständig bedeckt wird. Objekte die nicht
auswählbar sind, sollten wie im Dropdownmenü den Status <a href="008002.html#DISABLED">DISABLED</a>
erhalten.</p>

<p>Alle wählbaren Objekte müssen den Status <a href="008002.html#SELECTABLE">SELECTABLE</a> haben.
Zusätzlich müssen bei der Verwendung durch G_POPUP alle
selektierbaren Objekte vom Typ <a href="008002.html#G_STRING">G_STRING</a> (bzw. <a href="008002.html#G_SHORTCUT">G_SHORTCUT</a>) oder
<a href="008002.html#G_BUTTON">G_BUTTON</a> sein und mit zwei Leerstellen beginnen, letzteres wegen des
Häkchens, das von <a href="00800b.html#form_button">form_button</a> bzw. <a href="00800b.html#form_do">form_do</a> automatisch gesetzt wird!</p>

<p>Wichtig ist, daß ob_x und ob_y von Objekt 0 des Menüs relativ
zum G_POPUP-Objekt angegeben werden, d.h. sie werden meistens beide 0
sein. Es wird empfohlen, einen Schatten und einen Rand der Stärke -1
anzugeben.</p>

<p>Querverweis: <a href="00b.html">MagiC</a> &nbsp; <a href="008002.html#G_POPUP">G_POPUP</a></p>

<h3><a name="PRN_DIALOG"></a>8.22.32 PRN_DIALOG</h3>
<pre>typedef void *PRN_DIALOG;
</pre>
<h3><a name="PRN_ENTRY"></a>8.22.33 PRN_ENTRY</h3>
<pre>typedef struct _prn_entry
{
   struct _prn_entry *next;          /* Zeiger auf Nachfolger           */
   int32_t     length;               /* Strukturlänge                   */
   int32_t     format;               /* Datenformat                     */
   int32_t     reserved;             /* reserviert                      */
   int16_t     driver_id;            /* Treiberkennung                  */
   int16_t     driver_type;          /* Treibertyp                      */
   int32_t     printer_id;           /* Druckerkennung                  */
   int32_t     printer_capabilities; /* Druckereigenschaften            */
   int32_t     reserved1;            /* reserviert                      */
   int32_t     flags;                /* verschiedene Flags              */
   struct _pdlg_sub  *sub_dialogs;   /* Zeiger auf Unterdialoge         */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  setup_panel;          /* Unterdialog bei Druckerwechsel
                                        initialisieren                  */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  close_panel;          /* Unterdialog bei Druckerwechsel
                                        schließen                       */
   <a href="#PRN_MODE">PRN_MODE</a>    *modes;               /* Liste vorhand. Auflösungen      */
   <a href="#MEDIA_SIZE">MEDIA_SIZE</a>  *papers;              /* Liste vorhand. <a href="VDI_fundamentals.html#Papierformate">Papierformate</a>    */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *input_trays;         /* Liste der Einzüge               */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *output_trays;        /* Liste der Auswürfe              */
   int8_t      name[32];             /* Name des Druckers               */
} PRN_ENTRY;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_MODE"></a>8.22.34 PRN_MODE</h3>
<p>Diese Struktur dient der Beschreibung eines Druckermodus, und ist
wie folgt definiert:</p>

<pre>typedef struct _prn_mode
{
   struct _prn_mode *next;         /* Zeiger auf Nachfolger             */
   int32_t     mode_id;            /* Modus (<a href="indexudo.html">Index</a> innerhalb der Datei) */
   int16_t     hdpi;               /* horizontale Auflösung in dpi      */
   int16_t     vdpi;               /* vertikale Auflösung in dpi        */
   int32_t     mode_capabilities;  /* Moduseigenschaften                */
   int32_t     color_capabilities; /* einstellbare Farbmodi             */
   int32_t     dither_flags;       /* Flags, die angeben, ob der
                                      korrespondierende Farbmodus mit
                                      oder ohne Dithern ansprechbar ist */
   <a href="#MEDIA_TYPE">MEDIA_TYPE</a>  *paper_types;       /* geeignete Papiertypen             */
   int32_t     reserved;           /* reserviert                        */
   int8_t      name[32];           /* Modusname                         */
} PRN_MODE;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_SETTINGS"></a>8.22.35 PRN_SETTINGS</h3>
<pre>typedef struct _prn_settings
{
   int32_t  magic;            /* 'pset'                                 */
   int32_t  length;           /* (+) Strukturlänge                      */
   int32_t  format;           /* Strukturtyp                            */
   int32_t  reserved;         /* reserviert                             */
   int32_t  page_flags;       /* (+) Flags, u.a. gerade/ungerade Seiten
                                 0x0001 = nur Seiten mit gerader Nummer
                                 0x0002 = dto. mit ungeraden Nummern    */
   int16_t  first_page;       /* (+) erste zu druckende Seite (min.1)   */
   int16_t  last_page;        /* (+) dto. letzte Seite (max. 9999)      */
   int16_t  no_copies;        /* (+) Anzahl der Kopien                  */
   int16_t  orientation;      /* (+) Drehung
                                  0x0000 = <a href="00f00e.html#Ausrichtung">Ausrichtung</a> unbekannt und
                                           nicht verstellbar
                                  0x0001 = Seite im <a href="007008.html#Hochformat">Hochformat</a> ausgeben
                                  0x0002 = Seite im <a href="007008.html#Querformat">Querformat</a> ausgeben */
   int32_t  scale;            /* (+) Skalierung: 0x10000L = 100%        */
   int16_t  driver_id;        /* (+) <a href="Application.html#VDI-Ger_C3_A4tenummer">VDI-Gerätenummer</a>                   */
   int16_t  driver_type;      /* Typ des eingestellten Treibers         */
   int32_t  driver_mode;      /* Flags, u.a. für Hintergrunddruck       */
   int32_t  reserved1;        /* reserviert                             */
   int32_t  reserved2;        /* reserviert                             */
   int32_t  printer_id;       /* Druckernummer                          */
   int32_t  mode_id;          /* Modusnummer                            */
   int16_t  mode_hdpi;        /* horizontale Auflösung in dpi           */
   int16_t  mode_vdpi;        /* vertikale Auflösung in dpi             */
   int32_t  quality_id;       /* Druckmodus (hardwäremäßige Qualität,
                                 z.B. Microweave oder Econofast)        */
   int32_t  color_mode;       /* Farbmodus                              */
   int32_t  plane_flags;      /* Flags für auszugebende Farbebenen
                                 (z.B. nur cyan)                        */
   int32_t  dither_mode;      /* Rasterverfahren                        */
   int32_t  dither_value;     /* Parameter für das Rasterverfahren      */
   int32_t  size_id;          /* Papierformat                           */
   int32_t  type_id;          /* Papiertyp (normal, glossy)             */
   int32_t  input_id;         /* Papiereinzug                           */
   int32_t  output_id;        /* Papierauswurf                          */
   int32_t  contrast;         /* Kontrast:   0x10000L = normal          */
   int32_t  brightness;       /* Helligkeit: 0x1000L  = normal          */
   int32_t  reserved3;        /* reserviert                             */
   int32_t  reserved4;        /* reserviert                             */
   int32_t  reserved5;        /* reserviert                             */
   int32_t  reserved6;        /* reserviert                             */
   int32_t  reserved7;        /* reserviert                             */
   int32_t  reserved8;        /* reserviert                             */
   int8_t   device[128];      /* Dateiname für den Ausdruck             */
   #ifdef __PRINTING__
   TPrint   mac_settings;     /* Einstellung des Mac-Druckertreibers    */
   #else
   struct
   {
      uint8_t inside[120];
   } mac_settings;
   #endif
} PRN_SETTINGS;
</pre>
<p><b>Hinweis:</b> Die mit (+) gekennzeichneten Strukturelemente
können von der Applikation ausgelesen werden. Auf alle anderen
Einträge sollte <i>nicht</i> zugegriffen werden. Daten wie z.B. die
Druckerauflösung oder die Farbanzahl sollten <i>nicht</i> der
Einstellstruktur entnommen werden, sondern beim Start des Ausdrucks
vom Drucker erfragt werden (es wäre z.B. möglich, daß der
Druckertreiber durch Speichermangel gezwungen wird, die
Druckauflösung gegenüber der in PRN_SETTINGS eingetragenen
Einstellung zu verringern).</p>

<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_open">pdlg_open</a></p>

<h3><a name="PRN_SWITCH"></a>8.22.36 PRN_SWITCH</h3>
<pre>typedef int32_t (cdecl *PRN_SWITCH) ( struct _drv_entr *drivers,
                                   struct _prn_settings *settings,
                                   struct _prn_entry *old_printer,
                                   struct _prn_entry *new_printer );
</pre>
<p><b>Hinweis:</b> Die Komponente <i>old_printer</i> kann auch 0L
sein!</p>

<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="PRN_TRAY"></a>8.22.37 PRN_TRAY</h3>
<p>Diese Struktur dient der Beschreibung eines Einzugs bzw. Auswurfs,
und ist wie folgt definiert:</p>

<pre>typedef struct _prn_tray
{
   struct _prn_tray  *next;    /* Zeiger auf Nachfolger       */
   int32_t           tray_id;  /* Nummer des Einzugs/Auswurfs */
   int8_t            name[32]; /* Name des Schachts           */
} PRN_TRAY;
</pre>
<p>Querverweis: <a href="008005.html">Druckdialoge</a> &nbsp; <a href="008005.html#pdlg_add_printers">pdlg_add_printers</a></p>

<h3><a name="RSHDR"></a>8.22.38 RSHDR</h3>
<a name="Resource-Header"></a>
<a name="Resource-Kopf"></a>
<a name="Header_20einer_20Resource-Datei"></a>
<a name="Kopf_20einer_20Resource-Datei"></a>
<pre>typedef struct
{
   uint16_t rsh_vrsn;      /* Null                              */
   uint16_t rsh_object;    /* Position des Objekt-Feldes        */
   uint16_t rsh_tedinfo;   /* Position der <a href="#TEDINFO">TEDINFO</a>-Strukturen   */
   uint16_t rsh_iconblk;   /* Position der <a href="#ICONBLK">ICONBLK</a>-Strukturen   */
   uint16_t rsh_bitblk;    /* Position der <a href="008016.html#BITBLK">BITBLK</a>-Strukturen    */
   uint16_t rsh_frstr;     /* Position der freien Strings       */
   uint16_t rsh_string;    /* unbenutzt                         */
   uint16_t rsh_imdata;    /* Position der Image-Daten          */
   uint16_t rsh_frimg;     /* Position der freien Images        */
   uint16_t rsh_trindex;   /* Position der Objektbaumtabelle    */
   uint16_t rsh_nobs;      /* Gesamtzahl der Objekte            */
   uint16_t rsh_ntree;     /* Gesamtzahl der Objektbäume        */
   uint16_t rsh_nted;      /* Gesamtzahl der <a href="#TEDINFO">TEDINFO</a>-Strukturen */
   uint16_t rsh_nib;       /* Gesamtzahl der <a href="#ICONBLK">ICONBLK</a>-Strukturen */
   uint16_t rsh_nbb;       /* Gesamtzahl der <a href="008016.html#BITBLK">BITBLK</a>-Strukturen  */
   uint16_t rsh_nstring;   /* Gesamtzahl der Strings            */
   uint16_t rsh_nimages;   /* Gesamtzahl der Images             */
   uint16_t rsh_rssize;    /* Gesamtlänge der RSC-Datei         */
} RSHDR;
</pre>
<p><b>Hinweis:</b> Alle Positionsangaben sind relativ zum
Dateianfang zu verstehen. Noch ein Wort zu den 'freien Strings': zu
diesen gehören nicht nur die Zeichenketten, in denen sich die Daten
für die Alarmboxen befinden, sondern auch alle anderen Strings, die
ein Programm zu seiner Arbeit benutzt. Ein Beispiel dafür wäre der
Dateiname einer einzulesenden Datei oder ein Eintrag, der mit
<a href="00800f.html#menu_text">menu_text</a> in einem Menü vorgenommen wird.</p>

<a name="Resourcedateien_2C_20Gr_C3_B6_C3_9Fe_20von"></a>
<p>Diesem Kopf folgen die eigentlichen Resource-Daten. Man beachte
dabei, daß eine Resource-Datei aufgrund der Verwendung von
16-Bit-Werten als Zeiger nur eine Gesamtgröße von <i>maximal 64
Kbyte</i> erreichen kann. Dateien dieses Formats werden von allen
RCS-Programmen abgespeichert.</p>

<p>Anwender des Programms Interface und RSM (Resource Master) können
auch mit Resource-Dateien > 64 Kbyte arbeiten. Auch das Betriebssystem
<a href="00b.html">MagiC</a> unterstützt ab Version 3 Resourcedateien von mehr als 64 Kbyte;
das Laden der Resource erfolgt wie üblich per <a href="008011.html#rsrc_load">rsrc_load</a>, der Rest
wird völlig transparent vom System übernommen.</p>

<p>Querverweis: <a href="008011.html#rsrc_rcfix">rsrc_rcfix</a> &nbsp; <a href="#RSXHDR">RSXHDR</a></p>

<h3><a name="RSXHDR"></a>8.22.39 RSXHDR</h3>
<pre>typedef struct
{
  uint16_t rsh_vrsn;     /* should be 3                                 */
  uint16_t rsh_extvrsn;  /* not used                                    */
                         /* initialized to 'IN' für Interface,          */
                         /* 'RM' für ResourceMaster                     */
  uint32_t rsh_object;
  uint32_t rsh_tedinfo;
  uint32_t rsh_iconblk;  /* list of ICONBLKS                            */
  uint32_t rsh_bitblk;
  uint32_t rsh_frstr;
  uint32_t rsh_string;
  uint32_t rsh_imdata;   /* image data                                  */
  uint32_t rsh_frimg;
  uint32_t rsh_trindex;
  uint32_t rsh_nobs;     /* Counts of various structs                   */
  uint32_t rsh_ntree;
  uint32_t rsh_nted;
  uint32_t rsh_nib;
  uint32_t rsh_nbb;
  uint32_t rsh_nstring;
  uint32_t rsh_nimages;
  uint32_t rsh_rssize;   /* Gesamtlänge der RSC-Datei                   */
} RSXHDR;
</pre>
<p>Querverweis: <a href="008011.html#rsrc_load">rsrc_load</a> &nbsp; <a href="#RSHDR">RSHDR</a></p>

<h3><a name="SCANX"></a>8.22.40 SCANX</h3>
<pre>typedef struct
{
    int8_t   scancode;
    int8_t   nclicks;
    int16_t  objnr;
} SCANX;
</pre>
<p><b>Hinweis:</b> Die Struktur enthält die Zuordnung für die
Taste mit dem Scancode <i>scancode</i>, bei deren Betätigung ein
<i>nclicks</i>-facher Mausklick auf das Objekt mit der Nummer
<i>objnr</i> ausgeführt wird. Das Ende der Tabelle wird durch einen
Scancode von Null markiert.</p>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="00b.html">MagiC</a> &nbsp; <a href="#XDO_INF">XDO_INF</a> &nbsp; <a href="010002.html">Scan-Code Tabelle</a></p>

<h3><a name="SET_ITEM"></a>8.22.41 SET_ITEM</h3>
<pre>typedef int16_t (cdecl *SET_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                struct _lbox_item *item,
                                int16_t obj_index, void *user_data,
                                <a href="010009.html#GRECT">GRECT</a> *rect, int16_t first );
</pre>
<p>Dabei gilt:</p>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top"><i>box</i></td>
  <td align="left" valign="top">Zeiger auf die Listbox-Struktur</td>
</tr>
<tr>
  <td align="left" valign="top"><i>tree</i></td>
  <td align="left" valign="top">Zeiger auf den Objektbaum des Dialogs</td>
</tr>
<tr>
  <td align="left" valign="top"><i>item</i></td>
  <td align="left" valign="top">Zeiger auf <a href="#LBOX_ITEM">LBOX_ITEM</a>-Struktur des zu setzenden Eintrags</td>
</tr>
<tr>
  <td align="left" valign="top"><i>obj_index</i></td>
  <td align="left" valign="top">Nummer des zu setzenden Objektes</td>
</tr>
<tr>
  <td align="left" valign="top"><i>user_data</i></td>
  <td align="left" valign="top">Zeiger der bei lbox_create übergeben wurde</td>
</tr>
<tr>
  <td align="left" valign="top"><i>rect</i></td>
  <td align="left" valign="top">Rechteck für das Objekt-Redraw (oder NULL)</td>
</tr>
<tr>
  <td align="left" valign="top"><i>first</i></td>
  <td align="left" valign="top">Nummer des ersten sichtbaren Elements für Slider-B</td>
</tr>
</table>
</div>

<p><b>Hinweis:</b> Bei einer Listbox, die nur Text-Strings enthält,
ist dies typischerweise eine Funktion, die einen String, auf den die
<a href="#LBOX_ITEM">LBOX_ITEM</a> Struktur verweist, in das Objekt <i>obj_index</i> kopiert.
Der Parameter <i>rect</i> ist 0L, wenn ein Redraw der Dialogbox
durchgeführt wird oder wenn <a href="00800e.html#lbox_update">lbox_update</a> aufgerufen wurde. Er ist
hingegen <i>nicht</i> 0L, wenn der Anwender ein Objekt selektiert
oder deselektiert hat, und zeigt auf das <a href="010009.html#GRECT">GRECT</a> für den Redraw.</p>

<p>Der Rückgabewert der Funktion ist die Nummer des Startobjekts
für die Funktion <a href="008010.html#objc_draw">objc_draw</a> bzw. <a href="008008.html#wdlg_redraw">wdlg_redraw</a>.</p>

<p>Bei Einträgen in der Listbox, die aus mehreren Objekten bestehen,
ist es manchmal sinnvoll bei Selektion/Deselektion eines Objekts das
Redrawrechteck zu verkleinern oder das Startobjekt zu ändern, um
unnötige Zeichenoperationen und unnötiges Geflacker zu vermeiden. In
den meisten Fällen rufen die Listbox-Routinen nach der oben
beschriebenen Funktion die Routinen objc_draw bzw. wdlg_redraw auf, um den
geänderten Inhalt anzuzeigen.</p>

<p>Der Parameter <i>first</i> enthält die Nummer des ersten
sichtbaren Elements für Slider B, wenn die Listbox 2 Slider hat. Bei
einer (vertikalen) Listbox mit Text-Strings und zwei Slidern gibt man
z.B. beim Aufruf von <a href="00800e.html#lbox_create">lbox_create</a> die Anzahl der sichtbaren Zeichen in
<i>visible_b</i>, die gesamte Stringlänge in <i>entries_b</i> und
den <a href="indexudo.html">Index</a> des ersten sichtbaren Zeichens in <i>first_b</i> an. Wird
der Text horizontal gescrollt, wird die Funktion für alle sichtbaren
Strings aufgerufen und der Bereich neugezeichnet bzw. verschoben. Wenn
die Listbox nur einen Slider hat, ist first immer 0.</p>

<p>Querverweis: <a href="00800e.html">Listboxen</a> &nbsp; <a href="00800e.html#lbox_create">lbox_create</a></p>

<h3><a name="SHELTAIL"></a>8.22.42 SHELTAIL</h3>
<pre>typedef struct
{
    int16_t dummy;       /* ein Nullwort               */
    int32_t magic;       /* 'SHEL', wenn Shell...      */
    int16_t isfirst;     /* erster Aufruf der Shell    */
    int32_t lasterr;     /* letzter Fehler             */
    int16_t wasgr;       /* Programm war Grafikapp.    */
} SHELTAIL;
</pre>
<p><b>Hinweis:</b> Diese Informationen bekommt ein alternatives
Desktop von <a href="00b.html">MagiC</a> beim Programmstart übermittelt (per <a href="008012.html#shel_read">shel_read</a> zu
ermitteln). Gibt die Shell einen negativen Fehlercode zurück, so wird
MAGXDESK wieder aktiviert.</p>

<p>Wenn die Komponente <i>isfirst</i> gesetzt ist, ist der Status
etwa aus der DESKTOP.INF-Datei zu lesen, anderenfalls aus einer
temporären Datei bzw. dem Shell-Puffer.</p>

<p>Die Komponente <i>lasterr</i> entspricht dem Rückgabewert des
vorher gelaufenen Programms. Wenn dies ein <a href="002002.html">GEM</a>-Programm war, ist der
Fehler bereits per Alertbox angezeigt worden. Das Langwort ist
negativ, wenn der Fehler beim <a href="00500b.html#Pexec">Pexec</a> selbst auftrat; ein
Programm-Rückgabewert besitzt immer ein High-Word von 0.</p>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="008012.html#shel_wdef">shel_wdef</a></p>

<h3><a name="SLCT_ITEM"></a>8.22.43 SLCT_ITEM</h3>
<pre>typedef void (cdecl *SLCT_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                 struct _lbox_item *item,
                                 void *user_data, int16_t obj_index,
                                 int16_t last_state );
</pre>
<p>Dabei gilt:</p>

<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>box</i></td>
<td valign="top">Zeiger auf Listbox-Struktur</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>tree</i></td>
<td valign="top">Zeiger auf den Objektbaum des Dialogs</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>item</i></td>
<td valign="top">Zeiger auf die <a href="#LBOX_ITEM">LBOX_ITEM</a>-Struktur des ausgewählten Eintrags</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>user_data</i></td>
<td valign="top">Zeiger der bei lbox_create übergeben wurde</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj_index</i></td>
<td valign="top">ist die Nummer des angewählten Objekts. Bei einem Doppelklick ist
ähnlich wie nach <a href="00800b.html#form_do">form_do</a> das oberste Bit gesetzt. Wenn
<i>obj_index</i> 0 ist, heißt das, daß dem Eintrag kein Objekt
zugeordnet ist; er ist nicht sichtbar. Normalerweise ist das nur der
Fall, wenn gescrollt wird und durch Auswahl eines neuen Objekts die
(mittlerweile nicht mehr sichtbare) Selektion gelöscht werden muß.</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>last_state</i></td>
<td valign="top">ist der vorhergehende Status des Objekts. <i>last_state</i>
kann auch den gleichen Wert wie item->selected haben. In diesem Fall
kann die Funktion slct normalerweise sofort verlassen werden.

</td></tr>
</table>

<p>Querverweis: <a href="00800e.html#lbox_create">lbox_create</a></p>

<h3><a name="SWINFO"></a>8.22.44 SWINFO</h3>
<pre>typedef struct
{
    int8_t  *string;     /* etwa "<a href="002.html">TOS</a>|KAOS|MAG!X"          */
    int16_t  num;        /* Nr. der aktuellen Zeichenkette */
    int16_t  maxnum;     /* maximal erlaubtes <num>        */
} SWINFO;
</pre>
<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="008002.html#G_SWBUTTON">G_SWBUTTON</a></p>

<h3><a name="TEDINFO"></a>8.22.45 TEDINFO</h3>
<p>Die TEDINFO-Struktur wird benutzt um ein Textobjekt näher zu
beschreiben, und ist wie folgt definiert:</p>

<pre>typedef struct
{
    int8_t    *te_ptext;          /* Zeiger auf einen String          */
    int8_t    *te_ptmplt;         /* Zeiger auf die Stringmaske       */
    int8_t    *te_pvalid;         /* Zeiger auf den Gültigkeitsstring */
    int16_t    te_font;           /* Zeichensatz                      */
    int16_t    te_fontid;         /* GDOS Font-ID                     */
    int16_t    te_just;           /* Justierung des Textes:
                                     0 = linksbündig
                                     1 = rechtsbündig
                                     2 = zentriert                    */
    int16_t    te_color;          /* Farbe                            */
    int16_t    te_fontsize;       /* GDOS Font-Größe in Punkten       */
    int16_t    te_thickness;      /* Rahmenbreite                     */
    int16_t    te_txtlen;         /* Maximale Länge des Textes        */
    int16_t    te_tmplen;         /* Länge der Stringmaske            */
} TEDINFO;
</pre>
<p>Dabei gilt es, die folgenden Einzelheiten zu beachten:</p>

<ul>
<li><p><i>te_ptext:</i> Wenn das erste Zeichen ein Klammeraffe (!)
ist, werden alle folgenden Zeichen als Platzhalter angesehen, und der
zunächst ausgegebene String besteht aus Leerzeichen. Folge: Der
Klammeraffe kann niemals am Anfang eines Edit-Feldes stehen!</p></li>
<li><p><i>te_ptmplt:</i> Schablone (template). Sie wird nur bei
<a href="008002.html#G_FTEXT">G_FTEXT</a> und <a href="008002.html#G_FBOXTEXT">G_FBOXTEXT</a> verwendet, d.h. bei <a href="008002.html#G_TEXT">G_TEXT</a> und <a href="008002.html#G_BOXTEXT">G_BOXTEXT</a> kann
hier ein Null-Zeiger stehen. Bei der Ausgabe werden alle '_' Zeichen
in der Schablone sukzessive durch die Zeichen in <i>te_ptext</i>
ersetzt, d.h. es wird eine Misch-Zeichenkette gebildet. I.A. wird die
Schablone also soviele '_' Zeichen enthalten, wie der Puffer für
<i>te_ptext</i> lang ist (ohne abschließendes Nullbyte).</p></li>
<li><p><i>te_pvalid:</i> String, der für jedes Zeichen in
<i>te_ptext</i> eine Zeichenkette enthält, die über die Gültigkeit
verschiedener Zeichen an dieser Stringposition Auskunft gibt. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Zeichen</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">1 - 9</td>
<td valign="top">Accept any digit from 0 to that number. This is handy for doing
octal ('7') or binary ('1') validation. (Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">9</td>
<td valign="top">nur Ziffern</td></tr>

<tr><td nowrap="nowrap" valign="top">A</td>
<td valign="top">nur Großbuchstaben/Leerzeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">a</td>
<td valign="top">nur Buchstaben/Leerzeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">N</td>
<td valign="top">Großbuchstaben, Ziffern, Leerzeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">n</td>
<td valign="top">Buchstaben, Ziffern, Leerzeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">F</td>
<td valign="top">alle Zeichen, die zu einem Dateinamen gehören und '*', '?' und
':'.</td></tr>

<tr><td nowrap="nowrap" valign="top">f</td>
<td valign="top">alle Zeichen, die zu einem Dateinamen, ohne '*', '?' und ':'.</td></tr>

<tr><td nowrap="nowrap" valign="top">h</td>
<td valign="top">Hexadezimale Zeichen. (Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">H</td>
<td valign="top">Hexadezimal Zeichen. Kleinbuchstaben a - f werden in
Großbuchstaben A - F umgewandelt. (Geneva)</td></tr>

<tr><td nowrap="nowrap" valign="top">P</td>
<td valign="top">alle Zeichen, die zu einem Pfadnamen gehören</td></tr>

<tr><td nowrap="nowrap" valign="top">p</td>
<td valign="top">analog 'P', aber ohne die Zeichen '?' und '*'</td></tr>

<tr><td nowrap="nowrap" valign="top">m</td>
<td valign="top">alle Zeichen, die für einen langen Dateinamen gültig sind;
d.h. alle Zeichen außer Steuerzeichen (ASCII < 32), sowie außer ':'
und '\'. Dieser Code wird z.Zt. nur von <a href="00b.html">MagiC</a> unterstützt.</td></tr>

<tr><td nowrap="nowrap" valign="top">X</td>
<td valign="top">alle Zeichen</td></tr>

<tr><td nowrap="nowrap" valign="top">x</td>
<td valign="top">alle Zeichen, Kleinbuchstaben werden automatisch in
Großbuchstaben umgewandelt. (Geneva)

</td></tr>
</table>

</p></li>
<li><p><i>te_font:</i>
<br>3 = normal
<br>5 = kleiner Zeichensatz<br><br>

Für weiters siehe unten.</p></li>
<li><p><i>te_fontid:</i>
<br>Für weiters siehe unten.</p></li>
<li><p><i>te_color:</i> Für die Farbe des begrenzenden Rechteckes
gilt die folgende Belegung:<table>
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">12..15</td>
<td valign="top">Rahmenfarbe (0..15)</td></tr>

<tr><td nowrap="nowrap" valign="top">08..11</td>
<td valign="top">Textfarbe (0..15)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top">Text (0 = transparent, 1 = deckend)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4..&nbsp;6</td>
<td valign="top">Intensität<table>
<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp;&nbsp; =</td>
<td valign="top">hohl</td></tr>

<tr><td nowrap="nowrap" valign="top">1..6 =</td>
<td valign="top">ansteigende Intensität</td></tr>

<tr><td nowrap="nowrap" valign="top">7&nbsp;&nbsp;&nbsp; =</td>
<td valign="top">solide Fläche
</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0..&nbsp;3</td>
<td valign="top">Innenfarbe (0..15)

</td></tr>
</table>

</p></li>
<li><p><i>te_thickness:</i> Für den Rahmen sind folgende Werte
gültig:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Wert</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;0</td>
  <td align="left" valign="top">kein Rahmen</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;1..&nbsp;128</td>
  <td align="left" valign="top">Rand liegt 1 bis 128 Pixel im Inneren</td>
</tr>
<tr>
  <td align="left" valign="top">-1..-127</td>
  <td align="left" valign="top">Rand liegt 1 bis 127 Pixel außerhalb des Objektes</td>
</tr>
</table>
</div>

</p></li>
</ul>

<a name="GDOS-Fonts_20in_20Dialogen"></a>
<a name="Dialogen_2C_20GDOS-Fonts_20in"></a>
<a name="Zeichens_C3_A4tze_20in_20Dialogen"></a>
<p><b>Hinweis:</b> Die Komponenten <i>te_fontid</i> und
<i>te_fontsize</i> waren bisher reserviert. Ab <a href="008.html">AES</a>-Version 4.1 ist es
möglich, beliebige GDOS-Fonts für TEDINFO-Objekte zu benutzen.</p>

<p>Dazu ist über die Komponente <i>te_font</i> die Art des
Zeichensatzes zu spezifizieren:</p>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top"><i>te_font</i></td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">SpeedoGDOS Font</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">SpeedoGDOS Font (monospaced)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">GDOS Bitmap-Font</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">System-Zeichensatz</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">kleiner System-Zeichensatz</td>
</tr>
</table>
</div>

<p>Für Werte im Bereich 0..2 von <i>te_font</i> kann dann über die
Komponenten <i>te_fontid</i> bzw. <i>te_fontsize</i> der gewünschte
Zeichensatz und die gewünschte Punktgröße eingestellt werden.</p>

<p>Das Vorhandensein der neuen Möglichkeiten kann am einfachsten per
<a href="Application.html#_25apgi_13">appl_getinfo</a> (Opcode 13) ermittelt werden.</p>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="002002.html">GEM</a> &nbsp; <a href="#OBJECT">OBJECT</a> &nbsp; <a href="#XTED">XTED</a> &nbsp; <a href="00b007.html">Scrollende Eingabefelder</a></p>

<h3><a name="USERBLK"></a>8.22.46 USERBLK</h3>
<pre>typedef struct
{
   int16_t cdecl (*ub_code)(<a href="#PARMBLK">PARMBLK</a> *parmblock);
   int32_t ub_parm;
} USERBLK;
</pre>
<p><b>Hinweis:</b> Die Funktion <i>ub_code</i> wird bei jedem
Aufruf von <a href="008010.html#objc_draw">objc_draw</a> und <a href="008010.html#objc_change">objc_change</a> für das entsprechende Objekt
aufgerufen. Die Komponente <i>ub_parm</i> kann als optionaler
Parameter angesehen werden.</p>

<h3><a name="UTXT_FN"></a>8.22.47 UTXT_FN</h3>
<p>Diese Funktion ist wie folgt deklariert:</p>

<pre>typedef void (cdecl *UTXT_FN) (int16_t x, int16_t y, int16_t *clip_rect,
                               int32_t id, int32_t pt, int32_t ratio,
                               int8_t *string);
</pre>
<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="008014.html#fnts_add">fnts_add</a> &nbsp; <a href="#FNTS_ITEM">FNTS_ITEM</a> &nbsp; <a href="008014.html">Zeichensatzauswahl</a></p>

<h3><a name="WINFRAME_HANDLER"></a>8.22.48 WINFRAME_HANDLER</h3>
<p>Übergabe-Struktur zum Einklinken</p>

<pre>typedef struct {
  int16_t   version;                  /* Versionsnummer der Struktur       */
  int32_t   wsizeof;                  /* Größe der WINDOW-Struktur         */
  int16_t   whshade;                  /* Höhe eines ge-shade-ten Fensters  */
  void      (*wbm_create)( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_skind) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_ssize) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sslid) ( <a href="#WININFO">WININFO</a> *w, int16_t vertical );
  void      (*wbm_sstr)  ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sattr) ( <a href="#WININFO">WININFO</a> *w, int16_t chbits );
  void      (*wbm_calc)  ( int16_t kind, int16_t *fg );
  int16_t   (*wbm_obfind)( <a href="#WININFO">WININFO</a> *w, int16_t x, int16_t y );
} WINFRAME_HANDLER;
</pre>
<p>Querverweis:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WININFO">WININFO</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a></p>

<h3><a name="WINFRAME_SETTINGS"></a>8.22.49 WINFRAME_SETTINGS</h3>
<pre>typedef struct {
  int16_t   flags;
  int16_t   h_inw;
  void      *finfo_inw;
} WINFRAME_SETTINGS;
</pre>
<p>Bits von <i>flags</i>:
<br>#define NO_BDROP 1</p>

<p>Querverweis:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WININFO">WININFO</a></p>

<h3><a name="WININFO"></a>8.22.50 WININFO</h3>
<p>WINDOW-Struktur für <a href="00b.html">MagiC</a>-Kernel</p>

<pre>typedef struct {
  int16_t   state;
  int16_t   attr;
  void      *own;         /* (APPL *)                     */
  int16_t   kind;         /* von <a href="008009.html#wind_create">wind_create</a>()            */
  char      *name;        /* Zeiger auf Titelzeile        */
  char      *info;        /* Zeiger auf Infozeile         */
  <a href="010009.html#GRECT">GRECT</a>     curr;
  <a href="010009.html#GRECT">GRECT</a>     prev;
  <a href="010009.html#GRECT">GRECT</a>     full;
  <a href="010009.html#GRECT">GRECT</a>     work;
  <a href="010009.html#GRECT">GRECT</a>     overall;      /* Umriß                        */
  <a href="010009.html#GRECT">GRECT</a>     unic;
  <a href="010009.html#GRECT">GRECT</a>     min;          /* Minimale Größe               */
  int16_t   oldheight;    /* alte Höhe vor Shading        */
  int16_t   hslide;       /* horizontale Schieberposition */
  int16_t   vslide;       /* vertikale Schieberposition   */
  int16_t   hslsize;      /* horizontale Schiebergröße    */
  int16_t   vslsize;      /* vertikale Schiebergröße      */
  void      *wg;          /* Rechteckliste                */
  void      *nextwg;      /* nächstes Rechteck der Liste  */
  int16_t   whdl;
  <a href="#OBJECT">OBJECT</a>    tree[N_OBJS];
  int16_t   is_sizer;
  int16_t   is_info;
  int16_t   is_rgtobjects;
  int16_t   is_botobjects;
  <a href="#TEDINFO">TEDINFO</a>   ted_name;
  <a href="#TEDINFO">TEDINFO</a>   ted_info;
} WININFO;
</pre>
<p>Bits von <i>state</i>:
<br>#define OPENED 1
<br>#define COVERED 2
<br>#define ACTIVE 4
<br>#define LOCKED 8
<br>#define ICONIFIED 32
<br>#define SHADED 64</p>

<p>Querverweis:
<br><a href="008009.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a></p>

<h3><a name="XAESMSG"></a>8.22.51 XAESMSG</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>typedef struct
{
   int16_t  dst_apid;       /* ID der Ziel-Applikation    */
   int16_t  unique_flg;     /* <a href="008007.html#Nachrichten">Nachrichten</a> überschreiben? */
   void     *attached_mem;  /* Zeiger auf Speicherblock   */
   int16_t  *msgbuf;        /* Nachrichenpuffer           */
} XAESMSG;
</pre>
<p><b>Hinweis:</b> Die Komponente <i>unique_flg</i> gibt an, ob
gleichartige <a href="008007.html#Nachrichten">Nachrichten</a> (d.h. solche mit gleichem Nachrichtentyp
msgbuf[0]) von der neuen Nachricht überschrieben werden sollen.</p>

<p>Wenn <i>attached_mem</i> nicht NULL ist, wird damit ein per
<a href="00500c.html#Malloc">Malloc</a> allozierter Speicherblock angegeben, der die erweiterten
Nachrichten-Informationen enthält. Die Länge dieses Blocks ist beliebig
und für das System uninteressant, sie könnte z.B. als erstes
Langwort des Blocks oder in <i>msgbuf</i> [4,5] übergeben werden.
Das System weist den Speicherblock der Zielapplikation zu und
übermittelt dessen Adresse in msgbuf[6,7].</p>

<p><b>Wichtig:</b> Die aufrufende Applikation muß davon ausgehen,
daß <i>msgbuf[6,7]</i> nach dem Aufruf von <a href="Application.html#appl_write">appl_write</a> zerstört
sind. Das System behält sich vor, den Inhalt des Speicherblocks
umzukopieren und den übergebenen Block freizugeben. Der Aufrufer darf
nach dem appl_write <b>nicht mehr</b> auf den Block zugreifen und ihn
auf gar keinen Fall freigeben!</p>

<p>Gibt <a href="Application.html#appl_write">appl_write</a> einen Fehlercode zurück, so ist der Block
<i>nicht</i> übergeben worden und gehört nach wie vor der
aufrufenden Applikation. Ein Fehler tritt dann auf, wenn:</p>

<ul>
<li><p>die Zielapplikation ungültig (nicht existent oder eingefroren)
ist</p></li>
<li><p>der Nachrichtenpuffer der Zielapplikation voll ist</p></li>
<li><p> die Zielapplikation kein Prozeß ist (z.B. der <a href="008002.html#Der_20Screen-Manager">SCRENMGR</a>) und
ein attached memory block angegeben worden ist.</p></li>
</ul>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="Application.html#appl_write">appl_write</a> &nbsp; <a href="002002.html">GEM</a></p>

<h3><a name="XDO_INF"></a>8.22.52 XDO_INF</h3>
<pre>typedef struct
{
    <a href="#SCANX">SCANX</a> *unsh;    /* Tabellen für UnShift-Kombinationen   */
    <a href="#SCANX">SCANX</a> *shift;   /* Tabellen für Shift-Kombinationen     */
    <a href="#SCANX">SCANX</a> *ctrl;    /* Tabellen für Control-Kombinationen   */
    <a href="#SCANX">SCANX</a> *alt;     /* Tabellen für Alternate-Kombinationen */
    void  *resvd;   /* reserviert */
} XDO_INF;
</pre>
<p><b>Hinweis:</b> In dieser Struktur liegen Zeiger auf Tabellen,
die einem Scancode eine Objektnummer der Dialogbox zuordnen. Hiermit
ist es auf einfache Weise möglich, Dialoge vollständig über die
Tastatur zu bedienen. Der Parameter <i>resvd</i> ist für spätere
Zwecke reserviert, und muss immer NULL sein.</p>

<p>Querverweis: <a href="008.html">AES</a> &nbsp; <a href="00800b.html#form_keybd">form_keybd</a> &nbsp; <a href="00800b.html#form_xdo">form_xdo</a> &nbsp; <a href="00b.html">MagiC</a> &nbsp; <a href="010002.html">Scan-Code Tabelle</a></p>

<h3><a name="XFONTINFO"></a>8.22.53 XFONTINFO</h3>
<pre>typedef struct
{
   int16_t font_id;
   int16_t point_size;
   int16_t gadget_wid;
   int16_t gadget_ht;
} XFONTINFO;
</pre>
<p>Querverweis: <a href="Application.html#x_appl_font">x_appl_font</a></p>

<h3><a name="XFSL_FILTER"></a>8.22.54 XFSL_FILTER</h3>
<pre>typedef int16_t (cdecl XFSL_FILTER) (int8_t *path, int8_t *name, <a href="005014.html#XATTR">XATTR</a> *xa);
</pre>
<p>Querverweis: <a href="00800a.html#fslx_do">fslx_do</a> &nbsp; <a href="00800a.html#fslx_open">fslx_open</a></p>

<h3><a name="XSHW_COMMAND"></a>8.22.55 XSHW_COMMAND</h3>
<pre>typedef struct
{
   int8_t  *command;
   int32_t limit;
   int32_t nice;
   int8_t  *defdir;
   int8_t  *env;
} XSHW_COMMAND;
</pre>
<p>Querverweis: <a href="008012.html#shel_write">shel_write</a></p>

<h3><a name="XTED"></a>8.22.56 XTED</h3>
<p>Diese Struktur wird im Zusammenhang mit scrollbaren
Texteditfeldern benötigt.</p>

<pre>typedef struct _xted
{
   int8_t  *xte_ptmplt;
   int8_t  *xte_pvalid;
   int16_t xte_vislen;
   int16_t xte_scroll;
} XTED;
</pre>
<p>Querverweis: <a href="00b007.html">Scrollende Eingabefelder</a> &nbsp; <a href="#TEDINFO">TEDINFO</a></p>

<h3><a name="X_BUF_V2"></a>8.22.57 X_BUF_V2</h3>
<a name="ABLE_GETINFO"></a>
<a name="ABLE_PROP"></a>
<a name="ABLE_WTREE"></a>
<a name="ABLE_X3D"></a>
<a name="ABLE_XSHL"></a>
<a name="ABLE_PROP2"></a>
<a name="ABLE_EMSDESK"></a>
<a name="ABLE_XBVSET"></a>
<pre>typedef struct x_buf_v2
{
int16_t  buf_len   /* Length of the structure, including this word. Future      */
                   /* versions of this structure (X_BUF_V3 etc.) may be bigger. */
int16_t  arch      /* 16 for 16-bit <a href="008.html">AES</a>, 32 for hypothetical 32-bit <a href="008.html">AES</a>.        */
<a href="#CLRCAT">CLRCAT</a>   *cc       /* Address of an array of 16 <a href="#CLRCAT">CLRCAT</a> structures.              */
                   /* This is so that they can be read by a program; in         */
                   /* ViewMAX, the colours could be set but not reread.         */
<a href="#OBJECT">OBJECT</a>   *w_active /* Address of an object tree (19 elements) used to           */
                   /* draw window elements. Included so a program can           */
                   /* change symbols on window buttons.                         */
int8_t   *info     /* Address of a 0-terminated ASCII string (at most           */
                   /* 40 characters, no newlines) describing the <a href="008.html">AES</a>            */
int32_t  abilities /* A bitmapped field describing what optional functions      */
                   /* this <a href="008.html">AES</a> provides:                                        */
/* ABLE_GETINFO  1    bit 0 : xapp_getinfo supported                            */
/* ABLE_PROP     2    bit 1 : prop_get, prop_put and prop_del supported         */
/* ABLE_WTREE    4    bit 2 : <a href="008009.html#wind_get">wind_get</a> and <a href="008009.html#wind_set">wind_set</a> can change glyphs           */
/* ABLE_X3D      8    bit 3 : <a href="002002.html">GEM</a>/5 3D using <a href="008002.html#DRAW3D">DRAW3D</a>                             */
/* ABLE_XSHL    16    bit 4 : xshl_getshell & xshl_putshell                     */
/* ABLE_PROP2   32    bit 5 : prop_gui_get, prop_gui_set                        */
/* ABLE_EMSDESK 64    bit 6 : xgrf_dtimage supports EMS                         */
/* ABLE_XBVSET 128    bit 7 : supports 32 disc drives                           */
} X_BUF_V2;
</pre>
<p>An initialised X_BUF_V2 is one in which all members are 0 except
buf_len. This initialised buffer is then passed to <a href="Application.html#appl_init">appl_init</a>. On
return, if arch is 0 then the structure was not filled in by the <a href="008.html">AES</a>;
otherwise it was. The buf_len field may be reduced, if the <a href="008.html">AES</a> was
expecting an earlier version of the structure (ie, X_BUF_V1); this
should not be a problem because the structures are forward and
backward compatible.</p>

<p>Querverweis: <a href="Application.html#appl_init">appl_init</a></p>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="008.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="008015.html"><img src="udo_lf.gif" alt="AES-Funktionsliste" title="AES-Funktionsliste" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="009.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24"></a></body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Signale
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="005006.html"><img src="udo_lf.gif" alt="Programmstart und TPA" title="Programmstart und TPA" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="005008.html"><img src="udo_rg.gif" alt="gemdos-Trap" title="gemdos-Trap" border="0" width="24" height="24"></a>
<hr>

<h1><a name="Signale"></a>5.7 Signale</h1>
<p>Das aus der U*NIX-Welt stammende Signal-Konzept steht auch unter
den Betriebssystemen MultiTOS und <a href="00b.html">MagiC</a> (ab Version 4.50) zur
Verfügung. Signale können als natürliche Zahlen aufgefaßt werden,
die einen bestimmten Ausnahmezustand (Exception) repräsentieren. Sie
sind mit einem Interrupt oder einer CPU-Exception vergleichbar, mit
dem Unterschied jedoch, daß es sich um eine reine
<i>Software</i>-Implementation handelt.</p>

<p><b>Jeder Prozess besitzt:</b></p>

<ul>
<li><p>einen Bitvektor der wartenden Signale (pending Signals). Dieser
beschreibt diejenigen Signale, die noch auf ihre Bearbeitung warten,
weil sie z.B. gerade durch die Signalmaske gesperrt sind, oder weil
der Prozess in einem Zustand ist, in dem er keine Signale bearbeiten
kann.</p></li>
<li><p>eine Signalmaske. Dieser 32bit-Wert definiert als Bitvektor
diejenigen Signale, die momentan gesperrt sind; wenn in diesem Vektor
z.B. Bit-30 gesetzt ist, ist das Signal SIGUSR2 gesperrt. Die
Signalmaske wird nicht nur explizit (d.h. durch Systemaufrufe),
sondern auch <i>implizit</i> durch andere Vorgänge beeinflußt.
Während der Abarbeitung eines Signals ist dieses z.B. gesperrt,
andere können jedoch noch auftreten. Nach der Bearbeitung des Signals
wird dieses wieder freigegeben und damit evtl. eine weitere
Signalbehandlung ausgelöst. Beachtet werden muss, daß einige Signale
(z.B. SIGKILL, SIGSTOP, SIGCONT) <i>nicht</i> maskiert werden
können.</p></li>
<li><p>eine Tabelle der Form <a href="005014.html#struct_20sigaction">struct sigaction</a></p></li>
</ul>

<p>Bei einem <a href="00500b.html#Pexec">Pexec</a> werden die Signalmaske und der pending-Wert (s.o.)
des Child-Prozesses auf Null gesetzt. Die Komponente
<i>sa_handler</i> der <a href="005014.html#sigaction">sigaction</a> Struktur wird vererbt, wobei ein Wert
ungleich 0 oder 1 immer auf 0 gesetzt wird. Die Komponenten
<i>sa_mask</i> und <i>sa_flags</i> der Struktur werden auf den Wert
Null gesetzt.</p>

<p>Die meisten Signale können von einem Programm abgefangen, (um
etwa beim Eintreffen eine bestimmte Routine aufzurufen) ignoriert,
oder auch blockiert werden. Blockierte Signale werden solange nicht
berücksichtigt, bis die Blockade wieder aufgehoben wird. <b>Zur
Terminologie:</b> Man sagt, daß ein Signal zu einem Prozess
<i>geschickt</i> wird, wenn die das Signal repräsentierende
Exception auftritt, oder wenn das Signal per <a href="00500b.html#Pkill">Pkill</a> von einem anderen
Prozess gesendet wird. Ein Signal wurde hingegen an einen Prozess
<i>überbracht</i>, wenn der entsprechende Prozess aufwacht, und die
für das Signal passenden Aktionen einleitet. Zu beachten ist, daß
das SignalHandling nicht zeitlos geschieht: Zwischen dem Abschicken
eines Signals, und der Aufnahme der dazu passenden Aktionen kann evtl.
ein beträchtlicher Zeitraum verstreichen.</p>

<a name="Signale_2C_20Liste_20der"></a>
<p>Insgesamt stehen 31 mögliche Signale (0 bis 30) zur Verfügung,
denen aber noch nicht allen eine feste Bedeutung zugewiesen ist. Die
folgende Liste beschreibt (soweit bekannt) alle möglichen Signale in
der Form: Signalnummer, Name des Signals, Bedeutung des Signals für
den empfangenden Prozess. <b>Sofern nicht ausdrücklich anders
beschrieben, besteht die Default Aktion beim Eintreffen eines Signals
in der Terminierung des empfangenden Prozesses</b>.</p>

<table>
<tr><td nowrap="nowrap" valign="top">Nummer Name</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;<a name="SIGNULL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; SIGNULL</td>
<td valign="top">Null: Dieses Signal besitzt keine Defaultaktion, da es streng
genommen gar kein Signal ist. Zusammen mit <a href="00500b.html#Pkill">Pkill</a> kann es jedoch
benutzt werden, um die Existenz eines Prozesses zu testen. Das Signal
kann <i>nicht</i> maskiert oder abgefangen werden.<a name="SIGHUP"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp; SIGHUP</td>
<td valign="top">Hang Up: Wird normalerweise verschickt, wenn ein Terminal, mit
dem ein Prozess verbunden ist, nicht mehr gültig ist. Nach Erhalt
dieses Signals sollte der Prozess keine Ausgaben mehr auf das Terminal
machen. In <a href="00b.html">MagiC</a> wird der VT52 das Signal verschicken, wenn ein
Terminalfenster geschlossen wurde.<a name="SIGINT"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp; SIGINT</td>
<td valign="top">Interrupt: Wird i.a. verschickt, wenn der Benutzer die
Tastenkombination ^C betätigt. Dieses Signal wird von zukünftigen
Versionen MagiC statt der bisherigen ^C-Behandlung benutzt.<a name="SIGQUIT"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp; SIGQUIT</td>
<td valign="top">Quit: Wird i.a. verschickt, wenn der Benutzer die
Tastenkombination ^\ betätigt. Das Signal soll 'härter' als SIGINT
sein, und wird z.Zt. noch nicht von MagiC bzw. VT52 verschickt.<a name="SIGILL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp; SIGILL</td>
<td valign="top">Illegal instruction: Entspricht dem gleichnamigen
Exceptionvektor des 68K-Prozessors. Das Signal sollte <i>nicht</i>
abgefangen werden. In MiNT kann das Signal abgefangen werden, d.h. der
Vektor wird praktisch für jeden Prozess umgebogen. In MagiC
funktioniert das jedoch z.Zt. noch nicht, so daß hier immer 8 Bomben
erscheinen.<a name="SIGTRAP"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp; SIGTRAP</td>
<td valign="top">Trap: Entspricht dem Exceptionvektor 'Trace' des 68K-Prozessors
und wird nach jeder Anweisung gesendet, wenn das System im
Einzelschritt 'trace' Modus läuft. Dieses Signal sollte nur von
<b>Debuggern</b> abgefangen werden. In MiNT kann das Signal
abgefangen werden, d.h. der Vektor wird praktisch für jeden Prozess
umgebogen. In MagiC funktioniert das z.Zt. jedoch noch nicht, d.h.
es erscheinen immer 9 Bomben.<a name="SIGABRT"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp; SIGABRT</td>
<td valign="top">Abort: Wird normalerweise von der Bibliotheksfunktion abort()
in ANSI C verwendet, und sollte <i>nicht</i> abgefangen werden.
Dieses Signal wird nicht vom Betriebssystem selbst verschickt.<a name="SIGPRIV"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp; SIGPRIV</td>
<td valign="top">Privilege Violation: Entspricht dem gleichnamigen
Exceptionvektor im 68K-Prozessor, wenn ein Prozess versucht, eine
Anweisung im User-Mode auszuführen, die nur im Supervisor Mode
ausgeführt werden darf. Dieses Signal sollte nicht abgefangen werden;
in MiNT ist dies jedoch möglich, so daß der Exceptionvektor
praktisch für jeden Prozess umgebogen wird. In MagiC funktioniert
das z.Zt. jedoch noch nicht, d.h. es erscheinen immer 8 Bomben.<a name="SIGFPE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp; SIGFPE</td>
<td valign="top">Floating Point Exception: Die Default-Aktion besteht darin, das
Signal zu ignorieren. Es entspricht dem 68k-Execptionvektor 'Division
durch Null' oder eine Floating Point Exception. Das Signal kann
ignoriert oder abgefangen werden. In MiNT kann das Signal abgefangen
werden, so daß der Vektor praktisch für jeden Prozess umgebogen
wird. In MagiC ist dies z.Zt. noch nicht möglich.<a name="SIGKILL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp; SIGKILL</td>
<td valign="top">Kill: Terminiert den empfangenden Prozess. Das Signal kann
nicht maskiert bzw. abgefangen werden; deshalb sollte dieses Signal
erst dann verschickt werden, wenn SIGTERM erfolglos war. Das Signal
wird von <a href="00b.html">MagiC</a> selbst z.Zt. noch nicht verschickt.<a name="SIGBUS"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;10&nbsp;&nbsp; SIGBUS</td>
<td valign="top">Bus Error: Entspricht dem gleichnamigen Exceptionvektor des
68K-Prozessors. Das Signal sollte <i>nicht</i> ignoriert oder
abgefangen werden. In MiNT kann das Signal abgefangen werden, d.h. der
Exceptionvektor wird praktisch für jeden Prozess umgebogen; in
MagiC geht das z.Zt. jedoch noch nicht, so daß immer 2 Bomben
erscheinen. In MiNT werden SIGBUS, SIGSEGV und SIGPRIV beim ersten
Eintreffen des Signals auf die Defaultroutine des Systems
zurückgesetzt, so daß ein <i>doppelter</i>
Bus-/Adreß-/Privilegfehler den Prozess immer beendet.<a name="SIGSEGV"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;11&nbsp;&nbsp; SIGSEGV</td>
<td valign="top">Segmentation violation: Entspricht dem Exceptionvektor
'Adressfehler' des 68K-Prozessors. Das Signal sollte <i>nicht</i>
abgefangen oder ignoriert werden. In MiNT kann das Signal abgefangen
werden, d.h. der Exceptionvektor wird praktisch für jeden Prozess
umgebogen. In MagiC geht das jedoch z.Zt. noch nicht, d.h. es
erscheinen immer 3 Bomben.<a name="SIGSYS"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;12&nbsp;&nbsp; SIGSYS</td>
<td valign="top">Bad System Call: Wird verschickt, wenn ein Parameter für ein
Systemaufruf ungültig ist bzw. den erlaubten Wertebereich
überschreitet und der Aufruf selbst keinen Fehler meldet. Wird von
MagiC z.Zt. noch nicht verschickt.<a name="SIGPIPE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;13&nbsp;&nbsp; SIGPIPE</td>
<td valign="top">Pipe Error: Wird beim Versuch verschickt, in eine nicht mehr
existierende Pipe zu schreiben, und kann z.B. beim <a href="00f003.html">Drag&Drop-Protokoll</a>
maskiert werden. Dieses Signal wird z.Zt. von MagiC noch nicht
verschickt.<a name="SIGALRM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;14&nbsp;&nbsp; SIGALRM</td>
<td valign="top">Alarm: Wird von MiNT für <a href="00500a.html#Talarm">Talarm</a> verwendet, und dient z.B. zum
Behandeln von Time-Outs. In MagiC wird dieses Signal z.Zt. noch
nicht verschickt.<a name="SIGTERM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;15&nbsp;&nbsp; SIGTERM</td>
<td valign="top">Terminate: Standardsignal zum Beenden eines Prozesses; es wird
von MiNT z.B. beim Löschen einer Programmdatei im Verzeichnis U:\PROC
verschickt, von MagiC z.Zt. jedoch noch ignoriert.<a name="SIGURG"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;16&nbsp;&nbsp; SIGURG</td>
<td valign="top">Dieses Signal ist z.Zt. noch nicht definiert.<a name="SIGSTOP"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;17&nbsp;&nbsp; SIGSTOP</td>
<td valign="top">Stop: Die Default-Aktion besteht darin, den empfangenden
Prozess anzuhalten. Das Signal kann <i>nicht</i> blockiert bzw.
abgefangen werden. In <a href="00b.html">MagiC</a> werden dabei sämtliche Threads eines
Prozesses angehalten. Im gestoppten Zustand gehen in MagiC keinerlei
Maus- bzw. Tastaturklicks verloren; beim Fortfahren des Prozesses per
SIGCONT werden die entsprechenden <a href="008007.html#Nachrichten">Nachrichten</a> ausgewertet.<a name="SIGTSTP"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;18&nbsp;&nbsp; SIGTSTP</td>
<td valign="top">Terminal Stop: Die Default-Aktion besteht darin, den
empfangenden Prozess anzuhalten. Das Signal entspricht SIGSTOP, und
wird i.a. vom Benutzer durch Drücken der Tastenkombination ^Z
ausgelöst. Es kann <i>nicht</i> maskiert bzw. abgefangen werden. Das
Signal wird z.Zt. noch nicht von MagiC und VT52 verschickt.<a name="SIGCONT"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;19&nbsp;&nbsp; SIGCONT</td>
<td valign="top">Continue: Die Default-Aktion besteht darin, den empfangenen
(und vorher durch SIGSTOP oder <a href="00500b.html#Pause">Pause</a> gestoppten) Prozess wieder
aufzuwecken. Obwohl das Signal nicht maskiert bzw. ignoriert werden
kann, kann eine Behandlungsroutine für das Signal installiert werden.
In MagiC werden sämtliche Threads aufgeweckt, die durch einen
Aufruf von Pause bzw. SIGSTOP angehalten worden sind.<a name="SIGCHLD"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;20&nbsp;&nbsp; SIGCHLD</td>
<td valign="top">Child Terminated: Die Default-Aktion besteht darin, das Signal
zu ignorieren. Es wird sowohl beim Terminieren als auch beim Anhalten
eines Prozesses an den Parent-Prozess verschickt. In MiNT kann
festgelegt werden, daß dieses Signal nur beim Terminieren verschickt
wird, und darüber hinaus auch festgestellt werden, welcher
Child-Prozess betroffen war. Da MagiC bisher nur das wartende <a href="00500b.html#Pexec">Pexec</a>
kennt (d.h. der Parent wartet so lange, bis der Child terminiert),
gibt es das Signal hier noch nicht. Die durch <a href="008012.html#shel_write">shel_write</a> erzeugten
Prozesse sind <i>keine</i> richtigen Childs, sondern völlig
unabhängige Prozesse; in diesen Fällen muss daher auf das Eintreffen
der Nachricht <a href="008007.html#CH_EXIT">CH_EXIT</a> gewartet werden.<a name="SIGTTIN"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;21&nbsp;&nbsp; SIGTTIN</td>
<td valign="top">Terminal Input-Error: Die Default-Aktion besteht darin, den
empfangenden Prozess anzuhalten. In der Regel versucht ein Prozess von
einem Terminal zu lesen, das ihm nicht gehört. Von MagiC bzw. VT52
wird das Signal z.Zt. noch nicht verschickt.<a name="SIGTTOU"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;22&nbsp;&nbsp; SIGTTOU</td>
<td valign="top">Terminal Output-Error: Die Default-Aktion besteht darin, den
empfangenden Prozess anzuhalten. In der Regel versucht ein Prozess
Ausgaben auf ein Terminal vorzunehmen, das ihm nicht gehört. Von
MagiC bzw. VT52 wird das Signal z.Zt. noch nicht verschickt.<a name="SIGIO"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;23&nbsp;&nbsp; SIGIO</td>
<td valign="top">I/O possible: Eine Ein-/Ausgabe für eine Dateikennung ist
möglich.<a name="SIGXCPU"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;24&nbsp;&nbsp; SIGXCPU</td>
<td valign="top">Exhaustion of CPU-Limit: Das per <a href="00500b.html#Psetlimit">Psetlimit</a> bzw. durch die
erweiterten <a href="008012.html#shel_write">shel_write</a>-Modi festgelegte Rechenzeit-Kontingent ist
abgelaufen. Da die Begrenzung der Rechenzeit in <a href="00b.html">MagiC</a> bisher nicht
implementiert ist, wird das Signal z.Zt. noch nicht verschickt.<a name="SIGXFSZ"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;25&nbsp;&nbsp; SIGXFSZ</td>
<td valign="top">File size limit exceeded: Wird verschickt wenn eine Datei auf
eine Weise verändert wird, die die maximale Größe einer Datei, die
dem Prozess erlaubt ist, überschritten wird.<a name="SIGVTALRM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;26&nbsp;&nbsp; SIGVTALRM</td>
<td valign="top">Time limit expired: Wird an einen Prozess geschickt, der seine
maximale CPU Zeit überschritten hat.<a name="SIGPROF"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;27&nbsp;&nbsp; SIGPROF</td>
<td valign="top">Profiling time expired: Wird an einen Prozess geschickt, um ihm
mitzuteilen, daß seine maximale Profiling Zeit überschritten ist.<a name="SIGWINCH"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;28&nbsp;&nbsp; SIGWINCH</td>
<td valign="top">Window-Changed: Die Default-Aktion besteht darin, das Signal zu
ignorieren. Es wird normalerweise verschickt, wenn sich die
Terminalgröße (d.h. die Anzahl der Zeilen bzw. Spalten) verändert
hat. Ein Programm daß im Terminalfenster abläuft, kann sich nun
entsprechend neu konfigurieren. Zur Ermittlung der aktuellen
Fenstergröße gibt es in MiNT <a href="005009.html#Fcntl">Fcntl</a>-Opcodes, die in MagiC bisher
jedoch noch nicht implementiert sind. Das Signal wird daher z.Zt. noch
nicht von <a href="00b.html">MagiC</a> bzw. VT52 verschickt.<a name="SIGUSR1"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;29&nbsp;&nbsp; SIGUSR1</td>
<td valign="top">User-Defined:<a name="SIGUSR2"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;30&nbsp;&nbsp; SIGUSR2</td>
<td valign="top">User-Defined: Diese zwei Signale dürfen durch
Benutzerprogramme verschickt werden. Da ein Prozess beim Empfangen
dieses Signals per Default terminiert wird, sollte es nur verschickt
werden, wenn der Empfänger bekannt ist.

</td></tr>
</table>

<p>Querverweis:
<br><a href="#Signalhandler_20in_20MagiC">Signalhandler in MagiC</a> &nbsp; <a href="00500b.html">Prozessfunktionen</a> &nbsp; <a href="#Beispielcode_20zu_20Signalen">Beispielcode</a> &nbsp; <a href="00500b.html#Psigaction">Psigaction</a>
&nbsp; <a href="00500b.html#Psignal">Psignal</a> &nbsp; <a href="00500b.html#Pkill">Pkill</a> &nbsp; <a href="005004.html">Test auf Pipes</a></p>

<h3><a name="Signalhandler_20in_20MagiC"></a>5.7.1 Signalhandler in MagiC</h3>
<p>Da sich Signalhandler in MagiC etwas von denen in MiNT bzw.
MultiTOS unterscheiden, wird an dieser Stelle auf die wichtigsten
Unterschiede bzw. Eigenschaften eingegangen. Zunächst einmal muss
festgestellt werden, daß in MagiC <a href="008.html">AES</a>- und <a href="007.html">VDI</a>-Aufrufe aus einem
Signalhandler heraus <i>erlaubt</i> sind (ganz im Gegensatz zu MiNT).</p>

<p>Ein Signalhandler läuft im Usermodus und verwendet den Userstack
des Haupt-Threads, der solange schläft. In MiNT wird der
Supervisor-Stack des Prozesses verwendet. Daher schießt laut
MiNT-Dokumentation die Verschachtelung von Signalen ab 4 Stück einen
Prozeß wegen Stapelüberlaufs ab. In MagiC ist jeder Signalhandler
ein <i>eigener</i> Thread mit <i>eigenem</i> Supervisor-Stack, es
kann also lediglich der extrem unwahrscheinliche Fall des
Userstack-Überlaufs eintreten. Wenn jedoch zur Behandlung eines
Signals zuwenig Speicher für einen neuen Thread zur Verfügung steht,
wird eine Alertbox "System hat keinen freien Speicher mehr"
ausgegeben, und es sollte schleunigst ein Programm beendet werden.
Für jede Signalbehandlung benötigt MagiC ca. 7k Speicherplatz.</p>

<p>Für <a href="#Signale">Signale</a> gilt in MagiC das gleiche wie für Threads (ein
Signalhandler ist ein Thread), d.h. die entsprechenden
Systembibliotheken müssen <i>reentrant</i> sein. Es kommt jedoch
noch erschwerend hinzu, daß der Haupt-Thread während der Abarbeitung
des Signals angehalten wird. Wenn also der Haupt-Thread eine Semaphore
(Stichwort: <a href="008009.html#wind_update">wind_update</a>) gesetzt hat, ensteht ein Deadlock, wenn der
Signalhandler diese Semaphore ebenfalls setzen will. Weiterhin kann
ein Prozeß in MagiC an beinahe beliebiger Stelle unterbrochen
werden (MagiC ist reentrant, sogar DOS ist unterbrechbar), so daß
der Haupt-Thread u.U. wichtige Bereiche des Systems sperrt (Dateien,
Verzeichnisse, Semaphoren). Daher kann es z.B. vorkommen, daß
bestimmte Dateien nicht gelöscht oder geöffnet werden können.</p>

<p>Beim normalen Beenden eines Signalhandlers werden alle von dem
Handler gesperrten Semaphoren automatisch freigegeben. Weiterhin
werden ggf. Fenster, Bildschirmhintergrund und Menüleiste des
Signalhandlers freigegeben. Man beachte, daß ein Signalhandler eine
eigene <a href="008.html">AES</a> <a href="00f00a.html#Message">Message</a>-Queue besitzt, d.h. evnt_message und <a href="Application.html#appl_write">appl_write</a>
sind mit Vorsicht zu verwenden.</p>

<p>Bei <a href="00500b.html#Psigreturn">Psigreturn</a> werden die Semaphoren aller Signalhandler als auch
die des Haupt-Thread freigegeben. Nicht freigegeben werden jedoch
Fenster, Bildschirmhintergrund und Menüleiste der Signalhandler. Das
wäre zwar kein großes Problem gewesen, dürfte aber in der Praxis
nicht notwendig sein. Psigreturn restauriert den Supervisor-Stack des
Haupt-Thread, d.h. ein setjmp/longjmp-Mechanismus braucht nur den USP
zu setzen. Dies ist in der MiNT-Dokumentation nicht ausreichend
dokumentiert und funktioniert auch nur dann, wenn der Haupt-Thread per
<a href="005.html">GEMDOS</a>-Aufruf wartet. Kommt AES ins Spiel, stürzt MultiTOS ab.
Psigreturn sollte daher nach Möglichkeit vermieden werden. Psigreturn ist
in MagiC nicht vom Typ VOID wie in MiNT, sondern vom Typ LONG. Wenn
die Funktion von einem Nicht-Signalhandler aufgerufen wird, liefert
Psigreturn den Wert <a href="005003.html#EACCDN">EACCDN</a> zurück, sonst <a href="005003.html#E_OK">E_OK</a>. Hat Psigreturn <a href="005003.html#E_OK">E_OK</a>
geliefert, sollte (wie in MiNT) auf <i>keinen</i> Fall die
Behandlungs-Prozedur normal per rts beendet werden, weil die
Rücksprungadresse auf dem Userstack nach der Ausführung von Psigreturn
ungültig ist.</p>

<p>Ein Problem existiert in MagiC mit den bisherigen Versionen von
VT52. Ein Signalhandler kann noch <i>keine</i> Tastaturabfragen im
VT52 durchführen; die Tasten werden noch nicht empfangen. Dies wird
sich in einer späteren Version jedoch noch ändern.</p>

<p>Querverweis: <a href="00500b.html">Prozessfunktionen</a> &nbsp; <a href="#Signale">Signale</a> &nbsp; <a href="00b012.html">Threads</a></p>

<h3><a name="Beispielcode_20zu_20Signalen"></a>5.7.2 Beispielcode zu Signalen</h3>
<p>Das erste Programm installiert einen Signalhandler für die beiden
<a href="#Signale">Signale</a> <a href="005007.html#SIGUSR1">SIGUSR1</a> und <a href="005007.html#SIGUSR2">SIGUSR2</a>. Damit kann man die Verschachtelung der
beiden Signale testen, wenn beide hintereinander verschickt werden.
Das Programm sollte im VT52 bzw. im MINIWIN laufen. Wenn man während
der "for()" Warteschleife Ctrl-Alt-Esc betätigt, erkennt man, daß
<a href="00b.html">MagiC</a> für jeden Signalhandler einen eigenen Thread erstellt. Das hat
den Vorteil, daß unter MagiC keine Ereignisse (Maus, Timer, ...)
verlorengehen können, während ein Signal bearbeitet wird.</p>

<pre>------------------------------ schnipp --------------------------
#include <tos.h>
#include <stdio.h>

void cdecl handler(long signr)
{
    long i;

    printf("handler: Signal %ld empfangen.\n", signr);
    <a href="005010.html#Cconws">Cconws</a>("warte...");
    for (i = 0; i < 7000000L; i++)
        ;
    <a href="005010.html#Cconws">Cconws</a>("...OK\r\n");
}

int main( void )
{
    long ret;

    printf("Meine ProcID ist %d.\n", <a href="00500b.html#Pgetpid">Pgetpid</a>());
    ret = (long) <a href="00500b.html#Psignal">Psignal</a>(<a href="005007.html#SIGUSR1">SIGUSR1</a>, handler);
    printf("<a href="00500b.html#Psignal">Psignal</a> => %ld\n", ret);
    ret = (long) <a href="00500b.html#Psignal">Psignal</a>(<a href="005007.html#SIGUSR2">SIGUSR2</a>, handler);
    printf("<a href="00500b.html#Psignal">Psignal</a> => %ld\n", ret);
    <a href="005010.html#Cconin">Cconin</a>();
    return(0);
}
------------------------------ schnipp --------------------------
</pre>
<p>Das zweite Programm zeigt die Behandlung des <a href="00500b.html#Psigreturn">Psigreturn</a>()-Aufrufs.
Unter MiNT funktioniert dieses Programm nur, wenn man keine
<a href="008.html">AES</a>-Aufrufe (<a href="008007.html#evnt_keybd">evnt_keybd</a>() oder <a href="008007.html#evnt_multi">evnt_multi</a>()) verwendet, sondern z.B.
<a href="005010.html#Cconin">Cconin</a>() verwendet. D.h. das folgende Programm funktioniert unter
MagiC und stürzt unter MultiTOS (MiNT 1.08+AES 4.1) ab. Das
Problem liegt wahrscheinlich an der Restauration des Supervisor-Stacks
(Systemstapelzeiger), dabei versagt MultiTOS wegen des inhomogenen
Konzepts AES<->MiNT.</p>

<pre>------------------------------ schnipp --------------------------
#include <tos.h>
#include <<a href="008002.html#aes">aes</a>.h>
#include <setjmp.h>
#include <tosdefs.h>
#include <stdio.h>

jmp_buf env;

void cdecl handler(long signr)
{
    printf("handler: Signal %ld empfangen.\n", signr);
    <a href="005010.html#Cconws">Cconws</a>("Mache <a href="00500b.html#Psigreturn">Psigreturn</a>()\r\n");
    <a href="00500b.html#Psigreturn">Psigreturn</a>();
    longjmp(env, 1);
}

int main( void )
{
    long ssp;

    <a href="Application.html#appl_init">appl_init</a>();
    printf("Meine ProcID ist %d.\n", <a href="00500b.html#Pgetpid">Pgetpid</a>());
    <a href="00500b.html#Psignal">Psignal</a>(<a href="005007.html#SIGUSR1">SIGUSR1</a>, handler);

    if  (setjmp(env))
        <a href="005010.html#Cconws">Cconws</a>("komme von longjmp.\r\n");
    else    <a href="005010.html#Cconws">Cconws</a>("komme von setjmp.\r\n");
    ssp = <a href="00500e.html#Super">Super</a>(0L);
    <a href="00500e.html#Super">Super</a>((void *) ssp);
    printf("ssp = 0%08lx\n", ssp);
    <a href="008007.html#evnt_keybd">evnt_keybd</a>();
    return(0);
}
</pre>
<p>Querverweis: <a href="#Signale">Signale</a> &nbsp; <a href="00500b.html">Prozessfunktionen</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="005006.html"><img src="udo_lf.gif" alt="Programmstart und TPA" title="Programmstart und TPA" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="005008.html"><img src="udo_rg.gif" alt="gemdos-Trap" title="gemdos-Trap" border="0" width="24" height="24"></a></body>
</html>

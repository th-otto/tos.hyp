<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: MagiC PC-Schnittstelle
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="00e.html"><img src="udo_up.gif" alt="Emulatoren" title="Emulatoren" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00e001.html"><img src="udo_lf.gif" alt="MagiC Mac-Spezifika" title="MagiC Mac-Spezifika" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00e003.html"><img src="udo_rg.gif" alt="STEmulator" title="STEmulator" border="0" width="24" height="24"></a>
<hr>

<h1><a name="MagiC_20PC-Schnittstelle"></a>14.2 MagiC PC-Schnittstelle</h1>
<p><a href="00b.html">MagiC</a> PC kennt zwei Schnittelstellen mit denen man Funktionen des
Windowssystem aufrufen kann.</p>

<ul>
<li><p><a href="#mec0_20_28MPS_29_20Schnittstelle">mec0 (MPS) Schnittstelle</a> diese dient dazu beliebigen
(selbstgeschriebenen) Windowscode auszuführen. Dieser wird in einer
DLL abgelegt, und über illegale Opcodes aus <a href="00b.html">MagiC</a> PC heraus
aufgerufen.</p></li>
<li><p> <a href="#mec1_20Schnittstelle">mec1 Schnittstelle</a> hiermit kann ein vorgegebenes Set an
Spezialfunktionen aufgerufen werden.</p></li>
</ul>

<h3><a name="mec0_20_28MPS_29_20Schnittstelle"></a>14.2.1 mec0 (MPS) Schnittstelle</h3>
<p><u>0. Allgemeines</u></p>

<p>MPS = Magic_Programmier_Schnittstelle</p>

<p>Dateien des Demobeispieles:</p>

<table>
<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.def">mps_base.def</a></td>
<td valign="top">Die Exportliste der DLL, NICHT ÄNDERN</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.h">mps_base.h</a></td>
<td valign="top">Definition der MPS_Schnittstelle, NICHT ÄNDERN</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_base.cpp">mps_base.cpp</a></td>
<td valign="top">Basis-Funktionen der DLL, NICHT ÄNDERN</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_demo.h">mps_demo.h</a></td>
<td valign="top">Definitionen für die Demo-DLL</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#mps_demo.cpp">mps_demo.cpp</a></td>
<td valign="top">Die MPS_Funktionen der Demo-DLL</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#testmps.s">testmps.s</a></td>
<td valign="top">Motorola - Beispiel zum Aufruf der MPS-Funktionen des
Demo-Beispieles

</td></tr>
</table>

<p>Um eigene MPS_DLLs zu entwickeln, verwenden Sie bitte mps_base.def,
mps_base.h und mps_base.cpp unverändert. Zu ändern/ergänzen sind mps_demo.h
und mps_demo.cpp. Insbesondere wählen Sie bitte eine eigene DLL_ID in
<a href="#mps_demo.h">mps_demo.h</a> zur Unterscheidung von anderen MPS_DLLs.</p>

<p><u>I. Konzept</u></p>

<p>Windowsseitig können über dynamische Bibliotheken (DLLs)
beliebig viele Funktionen (im folgenden MPS_Funktionen genannt)
eingerichtet werden, die innerhalb von <a href="00b.html">MagiC</a>_PC (motorolaseitig)
aufgerufen werden können.</p>

<p>In der Startphase versucht <a href="00b.html">MagiC</a>_PC, alle DLLs im Unterverzeichnis
MPS zu laden und zu starten. Dazu ruft <a href="00b.html">MagiC</a> PC drei von der DLL zu
exportierende Funktionen auf (in dieser Reihenfolge):</p>


<ol>
<li><p>mps_get_type(): muß 0x4701 liefern!</p></li>
<li><p>mps_get_functionlist(...): ermittelt DLL_ID und
MPS_Funktionsliste der DLL.</p></li>
<li><p>mps_magicinfo: teilt <a href="00b.html">MagiC</a> PC-eigene Daten/Funktionen mit, die
die DLL bei Bedarf verwenden kann.</p></li>
</ol>

<p>Alle in 2) angemeldeten Funktionen können über spezielle Opcodes
motorola-seitig aufgerufen werden. Näheres zum Aufruf siehe IV.</p>

<p><u>II. Zu exportierende Funktionen der DLL
("Basisfunktionen")</u></p>

<p>Eine MPS-DLL muß genau 3 C-Funktionen unter fester Ordinalzahl
exportieren: (auch Basisfunktionen genannt) (siehe mfp_base.def,
mfp_base.cpp, mfp_base.h)</p>

<ul>
<li><p>@101: int mps_get_type()<br><br>

Zweck: Dient der Rückversicherung, ob tatsächlich MPS_DLL
erwischt. !! Rückgabewert: 0x4701 !!</p></li>
<li><p>@102: int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr
**p_funktionsliste);<br><br>

Zweck: <a href="00b.html">MagiC</a> PC möchte DLL_ID und MPS_Funktionsliste wissen.<br><br>

Rückgabewerte:
<br>*mps_ddl_id: DLL_ID (4 Bytes, DLL_spezifisch zu wählen!)
<br>*p_funktionsliste: Zeiger auf Liste der MPS_Funktionen.
<br>return: 1: alles klar</p></li>
<li><p>@103: void mps_magicinfo(MPS_magicinfo *is);<br><br>

Zweck: <a href="00b.html">MagiC</a> PC teilt eigene Infos / Funktionspointer mit, die die
DLL verwenden darf:<a name="MPS_magicinfo"></a>
<pre>   typedef struct {
    DWORD sizeof_str;               // Größe von MPS_magicinfo
    DWORD magic_version;            // z.B. 0x010001
    DWORD magic_date;               // z.B. 19960815      (aufsteigend)
    BYTE  is_demo;                  // Ist demoversion?
    BYTE  uu1, uu2, uu3;            // noch unbenutzt, 0

    BYTE *(*intel_adr)(DWORD motadr);   // Adressumrechnung Motorola -> Intel
    BYTE *(*intel_ptr)(DWORD motptr);   // Pointer-Umrechnung Motorola -> Intel (NULL bleibt NULL!)

    WORD (*swap_word)(WORD w);      // Ein Word swappen
    DWORD (*swap_long)(DWORD dw);   // Ein Langwort swappen
    } MPS_magicinfo;
</pre>
<br><br>

Die Adressumrechnungen ergeben NULL, falls motadr bzw motptr
ungültig ist.</p></li>
</ul>

<p><u>III. Die frei definierbaren MPS_Funktionen einer DLL:</u></p>

<p>MPS_Funktionen haben grundsätzlich die Form</p>

<p>void funktion_blabla( MPS_motregs *motregs )</p>

<p>motregs zeigt dabei auf die Liste der Motorola-Register d0-a7. Der
Inhalt der Register ist schon im richtigen Intel-ByteSex. Die
Motorola-Register dürfen auch mit neuen Werten beschrieben werden.</p>

<p>Die DLL übergibt mit mps_get_functionlist die Liste der Adressen
aller solcher MPS_Funktionen. Die Funktionsnummern entsprechen der
Position der Funktion innerhalb der Liste. Soll eine Nummer
freibleiben, ist als Adresse 0xffffffff (= -1) zu übergeben. Siehe
auch <a href="#mps_demo.cpp">mps_demo.cpp</a>.</p>

<p><u>IV. Motorola-seitiger Aufruf</u></p>

<p>MPS_Funktionen werden durch einen 8-Byte-Opcode motorola-seitig
aufgerufen:</p>

<pre>    dc.w    $4fbf       * 2 Bytes: nicht ändern
    dc.l    DLL_ID      * 4 Bytes: DLL-spezifische DLL_ID
    dc.w    Fkt_Nr.     * 2 Bytes: Funktionsnummer.
</pre>
<p>Die DLL_ID ist die über mps_get_functionlist mitgeteilte DLL_ID
(4 Bytes!). Funktionsnummer ist die Position der Funktion in der über
mps_get_functionlist mitgeteilten Funktionsliste (Zählung beginnt bei
0).</p>

<p><u>V. Sonstiges</u></p>


<ol>
<li><p>Jede DLL sollte eine individuelle DLL_ID verwenden, um
Konflikte zwischen mehreren DLLs zu vermeiden (siehe <a href="#mps_demo.h">mps_demo.h</a>).
DLL_IDs mit gesetztem Bit 31 sind für uns (Application Systems) bzw.
für zugeteilte IDs reserviert. Bitte wählen Sie deshalb keine DLL_ID
mit gesetztem Bit 31! Falls wir Ihnen eine reservierte DLL_ID zuteilen
sollen, setzen Sie sich bitte mit Herrn Hoffmann von Application
Systems in Verbindung.<br><br>

Folgende DLL IDs sind vergeben:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">DLL ID</td>
  <td align="left" valign="top">Programmname</td>
  <td align="left" valign="top">Author</td>
</tr>
<tr>
  <td align="left" valign="top">0x003f5c66</td>
  <td align="left" valign="top">MPCTime</td>
  <td align="left" valign="top">Robert Weiß</td>
</tr>
<tr>
  <td align="left" valign="top">0x2053434B</td>
  <td align="left" valign="top">MPCSTiK</td>
  <td align="left" valign="top">Dan Ackerman</td>
</tr>
<tr>
  <td align="left" valign="top">0x21342812</td>
  <td align="left" valign="top">Draconis Windows Sockets</td>
  <td align="left" valign="top"></td>
</tr>
<tr>
  <td align="left" valign="top">0x44594a01</td>
  <td align="left" valign="top">In2Cat</td>
  <td align="left" valign="top">Dimitri Junker</td>
</tr>
<tr>
  <td align="left" valign="top">0x44594a02</td>
  <td align="left" valign="top">Win_Lnk</td>
  <td align="left" valign="top">Dimitri Junker</td>
</tr>
<tr>
  <td align="left" valign="top">0x50475752</td>
  <td align="left" valign="top">MPC_POWR</td>
  <td align="left" valign="top">Emanuel Welter</td>
</tr>
</table>
</div>

</p></li>
<li><p>Achten Sie auf die Verschiebung des Adressraumes!!
<br>Wollen Sie eine Motorola-Adresse DLL-seitig verwenden, ist zur
Konvertierung intel_adr(..) bzw. intel_ptr(..) aufzurufen (siehe
MPS_magicinfo in <a href="#mps_base.h">mps_base.h</a>). Adressen aus dem DLL-Adressraum können
motorola-seitig NICHT verwendet werden!</p></li>
<li><p>Achten Sie auf den unterschiedlichen Byte-Sex zwischen
Motorola- und Intel-Prozessor. Worte und Langworte aus dem
Motorola-Adressraum müssen geswappt werden, damit sie in der DLL
richtig vorliegen. Beim eventuellen zurückschreiben ist wieder zu
swappen. Sie können dazu die Funktionen swap_word(..) bzw.
swap_long(..) aufrufen (siehe MPS_magicinfo in <a href="#mps_base.h">mps_base.h</a>). Aber: Die
Elemente von MPS_motregs (d0-a7) liegen schon intelmäßig vor und
müssen nicht mehr geswappt werden.</p></li>
</ol>

<h4><a name="mps_base.h"></a>14.2.1.1 mps_base.h</h4>
<pre>; ========================================================
; Export-Definitionen für MPS <a href="00b.html">MagiC</a>_PC Progr.Schnittstelle    FS 15.08.96
; ========================================================
;
; !! NICHT ÄNDERN !!
; ==================
EXPORTS
   mps_get_type         @101
   mps_get_functionlist @102
   mps_magicinfo        @103
</pre>
<h4><a name="mps_base.def"></a>14.2.1.2 mps_base.def</h4>
<pre>// Tabsize: 3

// Letzte Änderung:  15.08.96
// Autor:   FS

// ------------------------------------------------------------------------------
//
// Die <a href="00b.html">MagiC</a> PC - Programmier-Schnittstelle
//
// <a href="#mps_base.h">mps_base.h</a>: Basis-Include     !! UNVERÄNDERT ÜBERNEHMEN !!
//                               ======================

#ifdef __cplusplus
   extern "C" {
#endif

/* =========================================================================
   Die vom Anwender frei definierbaren DLL-Funktionen haben die Form
   void mps_funktion(MPS_motregs *r),
   wobei r ein Pointer auf die 16 Motorola-Register darstellt, also:
*/
   typedef struct {                 // MPS_motregs = Die Motorola-Register
     long d0,d1,d2,d3,d4,d5,d6,d7;
     long a0,a1,a2,a3,a4,a5,a6,a7;
     } MPS_motregs;
                                    // MPS_fuptr = Pointer auf eine MPS_Funktion:
   typedef void (*MPS_fuptr)(MPS_motregs *);


/* ============================================================
   Der DLL-Basisfunktion mps_info wird der folgende Infoblock
   MPS_infostr mitgegeben:
*/
   typedef struct {
     DWORD sizeof_str;           // Größe von MPS_infostr
     DWORD magic_version;        // z.B. 0x010001
     DWORD magic_date;           // z.B. 19960815     (aufsteigend)
     BYTE  is_demo;              // Ist demoversion?
     BYTE  uu1, uu2, uu3;        // noch unbenutzt, 0

     BYTE *(*intel_adr)(DWORD motadr); // Adressumrechnung Motorola -> Intel
     BYTE *(*intel_ptr)(DWORD motptr); // Pointer-Umrechnung Motorola -> Intel (NULL bleibt NULL!)

     WORD (*swap_word)(WORD w);           // Ein Word swappen
     DWORD (*swap_long)(DWORD dw);        // Ein Langwort swappen
     } <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a>;

// =============== zu exportieren sind 3 Basisfunktionen: ==================
//
   int mps_get_type();                                                        // @101
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_funktionsliste);  // @102
   void mps_magicinfo(<a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> *is);                                     // @103
//
// siehe auch <a href="#mps_base.cpp">mps_base.cpp</a>, mps_base.def


#ifdef __cplusplus
   }
#endif
</pre>
<p>Querverweise: <a href="#MagiC_20PC-Schnittstelle">MagiC PC-Schnittstelle</a></p>

<h4><a name="mps_base.cpp"></a>14.2.1.3 mps_base.cpp</h4>
<pre>// Tabsize: 3

// Letzte Änderung:  15.08.96
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu <a href="00b.html">MagiC</a> PC - Programmier-Schnittstelle (MPS)
//
// Teil 1: Basisfunktionen, UNVERÄNDERT übernehmen!
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "<a href="#mps_base.h">mps_base.h</a>"
#include "<a href="#mps_demo.h">mps_demo.h</a>"

//
// Die folgenden 3 Basisfunktionen müssen von der DLL exportiert werden:
//


// 1) Basisfuktion @101: Typabfrage
// ---------------------
   int mps_get_type()
// ----------------
 {
   return(0x4701);         // muß diesen Wert zurückgeben
 }

// 2) Basisfuktion @102: <a href="00b.html">MagiC</a> PC fordert Id und Funktionsliste an.
// ---------------------
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_funktionsliste)
// ------------------------
 {
   *mps_dll_id = DLL_ID;               // benutzerdefinierte ID, siehe <a href="#mps_demo.h">mps_demo.h</a>
   *p_funktionsliste = my_funclist;    // Zeiger auf Funktionsliste eintragen
   return(1);
 }

// 3) Basisfuktion @103: <a href="00b.html">MagiC</a> PC übergibt <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> an die DLL
// ---------------------
   void mps_magicinfo(<a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> *is)
// -------------
 {
   m_info = *is;                    // Merken
 }

//
// ENDE Basisfunktionen -------------------------------------------------------
//

</pre>
<p>Querverweise: <a href="#MagiC_20PC-Schnittstelle">MagiC PC-Schnittstelle</a></p>

<h4><a name="mps_demo.h"></a>14.2.1.4 mps_demo.h</h4>
<pre>// Tabsize: 3

// Letzte Änderung:  15.08.96
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu <a href="00b.html">MagiC</a> PC - Programmier-Schnittstelle (MPS)
//
// Teil 2: Benutzer-definierte Funktionen, DLL_ID auf eigenen Wert ändern !!!
// =======
//
// ------------------------------------------------------------------------------

#define DLL_ID  0x01020304             // auf eigenen Wert בñndern.
                                       // !! Werte mit gesetztem Bit 31 reserviert für Appl.Systems.
                                       // ID-Reservierung: Bei Appl.Systems (Herrn Hoffmann) anfragen!

   extern MPS_fuptr my_funclist[];     // Die Funktionsliste in der Demo-DLL

   extern <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> m_info;        // wird von <a href="00b.html">MagiC</a>_PC übernommen
</pre>
<p>Querverweise: <a href="#MagiC_20PC-Schnittstelle">MagiC PC-Schnittstelle</a></p>

<h4><a name="mps_demo.cpp"></a>14.2.1.5 mps_demo.cpp</h4>
<pre>// Tabsize: 3

// Letzte Änderung:  15.08.96
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu <a href="00b.html">MagiC</a> PC - Programmier-Schnittstelle (MPS)
//
// Teil 2: Benutzer-definierte Funktionen, frei änderbar.
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "<a href="#mps_base.h">mps_base.h</a>"
#include "<a href="#mps_demo.h">mps_demo.h</a>"

   <a href="00e002.html#MPS_magicinfo">MPS_magicinfo</a> m_info;               // <a href="008002.html#global">global</a> für die DLL

//
// Liste der benutzerdefinierten Funktionen (nach Bedarf ändern/erweitern):
// -----------------------------------------------------------------------
   static void demo_0(MPS_motregs *r);
   static void demo_1(MPS_motregs *r);
   static void demo_3(MPS_motregs *r);
   static void copy_string(MPS_motregs *r);

   MPS_fuptr my_funclist[] = {
     demo_0,                           // Demo-Funktion 0
     demo_1,                           // Demo-Funktion 1
     (MPS_fuptr) -1,                   // -1 (d.h Funktion Nummer 2 nicht definiert)
     demo_3,                           // Demo-Funktion 3
     copy_string,                      // Demo-Funktion 4
     NULL                              // !! Am Listenende ein NULL-Eintrag !!
     } ;


// *******************************************************************************
//
// Hier die benutzerdefinierten Funktionen:
// ========================================
//

// Demo_0 liefert nur in d0 den Wert 1 zurück:
//
   static void demo_0(MPS_motregs *r)
// ----------------------
 {
   r->d0 = 1;                       // Demo-0 setzt d0 auf 1
   return;
 }

// Demo_1 addiert die Register d1 und d2; Ergebnis nach d0:
//
   static void demo_1(MPS_motregs *r)
// ----------------------
 {
   r->d0 = r->d1 + r->d2;
   return;
 }

// Demo_3 tut gar nichts:
//
   static void demo_3(MPS_motregs *r)
// ----------------------
 {
   return;
 }

// Demo-Routine4 copy_string kopiert einen String in den Motorola-Adressraum:
//               -----------
// a0: Ziel-Adresse,
// d0: Maximalzahl der Zeichen (incl. 0)
//
   static void copy_string(MPS_motregs *r)
// -----------------------
 {
   static char string[] = "Dies ist ein Demo-Text von copy_string(..)";

   int i, nchmax;
   char *ziel;

   nchmax = (int) r->d0;
   ziel = (char *) (*m_info.intel_ptr)(r->a0);
   if (nchmax<=0 || ziel==NULL) return;         // ungültig?

   for (i=0; i<nchmax; i++) {
     if ((ziel[i] = string[i])==0)
       return;
     }
   ziel[nchmax-1] = 0;                          // zu lange->abschneiden
   return;
 }
</pre>
<p>Querverweise: <a href="#MagiC_20PC-Schnittstelle">MagiC PC-Schnittstelle</a></p>

<h4><a name="testmps.s"></a>14.2.1.6 testmps.s</h4>
<pre>
*                                                 FS  15.08.96
*
*   =============================================================
*   Beispiel für den Aufruf der MPS-Funktionen von Motorola aus
*   =============================================================
*
* Quelle Windows-seitig:
* ----------------------
* <a href="#mps_base.cpp">mps_base.cpp</a>, <a href="#mps_demo.cpp">mps_demo.cpp</a>
*
mps_code .equ  $4fbf                   * !! NICHT ÄNDERN !!
DLL_ID   .equ  $01020304               * hier eigene DLL_ID eintragen

* -------------------------------------- 60 Bytes Puffer
bufsize  .equ  60
.bss
.even
buffer:   ds.w  bufsize
* --------------------------------------


*
* ------------------- Hier gehts los: ---------------------------------
*
.text
.globl _main
_main:
      moveq    #-1,d0                  * d0 auf -1 (zum Testen)

*     ===========================      * Funktion 0 (Demo_0) aufrufen:
      dc.w     mps_code                * = $4fbf
      dc.l     DLL_ID                  * = eigene DLL_ID
      dc.w     0                       * Funktionsnummer (hier 0)
*     ===========================
      cmpi.l   #1,d0                   * müßte 1 zurückliefern
      bne      fertig

* Beispiel für Aufruf mit Parametern (copy_string)
* ----------------------------------
      movea.l  #buffer,a0              * Zeiger auf Puffer für String
      move.l   #bufsize,d0             * Max. Stringlänge (incl.0-Byte).

*     ===========================      * Funktion 4 (copy_string) aufrufen:
      dc.w     mps_code                * = $4fbf
      dc.l     DLL_ID                  * = eigene DLL_ID
      dc.w     4                       * Funktionsnummer (hier 4)
*     ===========================

      bsr      put_line                * Zeile (a0) ausgeben
fertig:
      bsr      wait                    * Auf Tastendruck warten
      rts
*
* --------------------- ENDE Hauptroutine _main ------------------------
*


* ------------------------ Zeile (a0) ausgeben -----------------------
put_line:
      moveq    #13,d0
      bsr      put_char
      moveq    #10,d0
put_lnext:
      bsr      put_char
      move.b   (a0)+,d0
      bne      put_lnext
      rts

* ------------------------ Zeichen d0 ausgeben -----------------------
put_char:
      movem.l  d0-d2/a0-a2,-(sp)
      move.w   d0,-(sp)
      move.w   #2,-(sp)
      move.w   #3,-(sp)
      trap     #13
      addq.l   #6,sp
      movem.l  (sp)+,d0-d2/a0-a2
      rts

* -------------------------- auf Tastendruck warten. --------------------
wait:
      move.w   #2,-(sp)
      move.w   #2,-(sp)
      trap     #13
      addq.l   #4,sp
      rts

</pre>
<p>Querverweise: <a href="#MagiC_20PC-Schnittstelle">MagiC PC-Schnittstelle</a></p>

<h3><a name="mec1_20Schnittstelle"></a>14.2.2 mec1 Schnittstelle</h3>

<ol>
<li><p>Konzept<br><br>

Die mec1-Schnittstelle ermöglicht es, im Motorola-Code von
Emulator vorgebenene Funktionen aufrufen. Sie entspricht der
mec0-Schnittstelle; die Funktionen sind jedoch nicht in einer DLL frei
definierbar, sondern schon vom Emulator vorgegeben.Aufruf:Die
Funktionen werden einheitlich durch den Opcode $43bf aufgerufen, mit
nachfolgender Funktionsnummer, also 4 Bytes Gesamtlänge. Beispiel:<br><br>

dc.w $43bf,$0031<br><br>

ruft die mec1-Funktion mit der Nummer 0x31 auf. ($43bf ist der
Opcode für chk <ea>,D1, mit <ea> = 111111 binär, also ungültig).
Die Parameter-Übergabe erfolgt wie bei mec0 über die Motorola
Register.</p></li>
<li><p>Die Funktionen<table>
<tr><td nowrap="nowrap" valign="top">$0001</td>
<td valign="top">long emu_version:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">keine</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: Versions-Nummer</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1: Versions-Datum</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d2: Bit0: Ist Demo-Version?</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0002</td>
<td valign="top">long emu_enquire: Ermittelt Verschiedenes.<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">long d0: was willst Du wissen?</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">long d0: Wert</td>
</tr>
</table>
</div>

<br><br>

bisher definiert:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">was:</td>
  <td align="left" valign="top">1: Versionsnumemr</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">2: Versionsdatume</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">3: Ist Demo?</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0003</td>
<td valign="top">void emu_getexepath: Ermittelt vollen Pfad (incl. Laufwerk,
ohne MAGIC_PC.EXE)<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: char *bufadr (Buffer)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0: short nb_max (max. Byteszahl für Buffer)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0004</td>
<td valign="top">int emu_install_newvdi:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: Byte *bufadr (neuer Inhalt von <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLL)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0: long nbytes  (Länge)</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: >0: erfolgreich <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLN erzeugt.</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">Beim nächsten  Hochstarten wird automatisch</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">umbenannt in <a href="VDI_fundamentals.html#NVDI">NVDI</a>_PC.DLL, wie besprochen.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0010</td>
<td valign="top">void dw_addline: &nbsp;! ab 03.97<br><br>

Text in neuer Zeile im Debug-Fenster ausgeben<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: Zeiger auf den Text.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0011</td>
<td valign="top">void dw_addtext: &nbsp;! ab 03.97<br><br>

Text im Debug-Fenster ausgeben<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: Zeiger auf den Text.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0011</td>
<td valign="top">void dw_formtxt: &nbsp;! ab 03.97<br><br>

Text sprintf-like im Debug-Fenster ausgeben<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: Zeiger auf den Format-String</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0, d1, ...  zusätzliche Parameter, passend zu</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">dem Format-String der Formatstring entspricht</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">ungefähr sprintf(format,...); Stringpointer</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">sind jedoch nicht zulässig.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0031</td>
<td valign="top">int printer_open &nbsp;! ab 03.97<br><br>

printer_open öffnet den Standarddrucker und beginnt ein neues
Dokument<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: char *DocName (NULL-Pointer erlaubt)</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0>0: alles klar</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0<=0 Fehler</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0032</td>
<td valign="top">int printer_close &nbsp;! ab 03.97<br><br>

printer_close beendet das zuvor geöffnete Dokument und schließt
den Drucker<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">keine</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0>0: alles klar</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0<=0 Fehler</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0033</td>
<td valign="top">int printer_write &nbsp;! ab 03.97<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: Byte *pData;  // Zeiger auf den DatenBuffer</td>
</tr>
<tr>
  <td align="left" valign="top"></td>
  <td align="left" valign="top">d0: long nBytes;  // Zahl der Bytes im Buffer</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: übertragene Bytes.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0040</td>
<td valign="top">DWORD getTickCount &nbsp;! ab 03.97<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: TickCount (msec seit Start des Rechners)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0041</td>
<td valign="top">DWORD getDrivePath &nbsp;! ab 02.99<br><br>

Die Funktion ermittelt den Windows-Pfad für ein Magic-Laufwerk.<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">d0: DriveNr (0 für A:, 1 für B:, ...)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">a0: Textbuffer für den Pfad</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1: Größe des Textbuffers</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: 0:  nicht gefunden,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 1:  Container-Laufwerk,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 2:  xfs-Laufwerk (Windows-Laufwerk)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp; 4:  Floppy-Laufwerk</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">$0042</td>
<td valign="top">DWORD setClipboardDir &nbsp;! ab 02.99<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">a0: char *pPath // NULL: auf Default setzen</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0: 1</td>
</tr>
</table>
</div>

<br><br>

Beispiel:<pre>        movea.l stringadr,a0    *
        dc.w    $43bf,$0042     * mec1,Funktion $42 aufrufen
        tst.l   d0              * -1: Fkt. nicht implementiert
        jl  nichtimplementiert
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">$0043</td>
<td valign="top">long getMouseWheel<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">d0.l: 1: Position nach dem Auslesen zurücksetzen</td>
</tr>
<tr>
  <td align="left" valign="top"></td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0: Position nach dem Auslesen nicht zurücksetzen</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">d0.l: aktuelle Position des Mausrades</td>
</tr>
</table>
</div>

<br><br>

Beispiel:<pre>        moveq   #1,d0       * Position nach dem Auslesen zurücksetzen
        dc.w    $43bf,$0043 * mec1,Funktion $43 aufrufen
        tst.l   d0          * Position seit letztem zurücksetzen geändert
        je  no_action
        <d0.l verarbeiten>
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">$0045</td>
<td valign="top">long setCompiler &nbsp;! ab 17.06.99<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter:</td>
  <td align="left" valign="top">d0.l: Auswahl, im Moment realisert:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d0 = 1: Compiler ein/ausschalten:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = 0: Compiler aus,</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = 1: Compiler ein</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">d1 = -1: Modus erfragen (Nach meinen Erfahrungen</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;funtioniert dies nicht, soll aber in</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;der 6.20 funktionieren)</td>
</tr>
<tr>
  <td align="left" valign="top">return:</td>
  <td align="left" valign="top">alter Modus (0 oder 1).</td>
</tr>
</table>
</div>



</td></tr>
</table>

</p></li>
</ol>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="00e.html"><img src="udo_up.gif" alt="Emulatoren" title="Emulatoren" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00e001.html"><img src="udo_lf.gif" alt="MagiC Mac-Spezifika" title="MagiC Mac-Spezifika" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00e003.html"><img src="udo_rg.gif" alt="STEmulator" title="STEmulator" border="0" width="24" height="24"></a></body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Laufwerksfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="00400c.html"><img src="udo_lf.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="00400e.html"><img src="udo_rg.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24"></a>
<hr>

<h1><a name="Laufwerksfunktionen"></a>4.13 Laufwerksfunktionen</h1>
<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#DMAread">DMAread</a></td>
<td valign="top">Sektoren von Festplatte lesen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#DMAwrite">DMAwrite</a></td>
<td valign="top">Sektoren auf Festplate schreiben.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Flopfmt">Flopfmt</a></td>
<td valign="top">Spur auf einer Diskette formatieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Floprate">Floprate</a></td>
<td valign="top"> Seekrate und Timeout der Floppy setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Floprd">Floprd</a></td>
<td valign="top"> Einzelne Sektoren lesen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Flopver">Flopver</a></td>
<td valign="top"> Sektoren einer Diskette überprüfen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Flopwr">Flopwr</a></td>
<td valign="top"> Einzelne Sektoren schreiben.<a name="MetaDOS-Funktionen"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metaclose">Metaclose</a></td>
<td valign="top">Gibt ein <a href="004002.html">MetaDOS</a> Gerät wieder frei.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metadiscinfo">Metadiscinfo</a></td>
<td valign="top">Ermittelt aktuelle Status-Informationen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metagettoc">Metagettoc</a></td>
<td valign="top"> Liefert das Inhaltsverzeichnis eines Gerätes.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metainit">Metainit</a></td>
<td valign="top"> Informationen über MetaDOS Version ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metaioctl">Metaioctl</a></td>
<td valign="top"> Schickt <a href="005.html">GEMDOS</a>-Opcodes an ein MetaDOS Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metaopen">Metaopen</a></td>
<td valign="top"> Initialisiert ein MetaDOS Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metaread">Metaread</a></td>
<td valign="top"> Liest Daten von einem MetaDOS Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metasetsongtime">Metasetsongtime</a></td>
<td valign="top"> Startet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metastartaudio">Metastartaudio</a></td>
<td valign="top"> Startet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metastatus">Metastatus</a></td>
<td valign="top"> Ermittelt den Status eines MetaDOS Gerätes.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metastopaudio">Metastopaudio</a></td>
<td valign="top"> Beendet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Metawrite">Metawrite</a></td>
<td valign="top"> Schreibt Daten auf ein MetaDOS Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Protobt">Protobt</a></td>
<td valign="top"> Bootsektor für Diskette im Speicher generieren.

</td></tr>
</table>

<p>Querverweis: <a href="005009.html">GEMDOS-Dateifunktionen</a> &nbsp; <a href="00500f.html">GEMDOS-Verzeichnisfunktionen</a></p>

<h3><a name="DMAread"></a>4.13.1 DMAread</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»DMA read« - liest einzelne Sektoren von einer DMA-Einheit.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">42</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t DMAread( int32_t sector, int16_t count, void *buffer,
int16_t devno );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine DMAread liest einzelne oder mehrere Sektoren
von einem ACSI- oder SCSI Gerät. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top">erste Sektornummer</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der Sektoren</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">Anfangsadresse im Speicher</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Gerätenummer. Es gilt:<br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI-Geräte</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI-Geräte</td>
</tr>
</table>
</div>

<br>

Alle anderen Werte sind für zukünftige Erweiterungen reserviert.

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> In vielen Fällen ist es sinnvoller, statt dieser
Funktion <a href="About_the_BIOS.html#Rwabs">Rwabs</a> zu verwenden. Der angegebene Speicherbereich muß für
die jeweilige Hardware beschreibbar sein (Stichwort: <a href="003007.html#Fast-RAM-Buffer">Fast-RAM-Buffer</a>).
SCSI-Geräte werden von dieser Funktion nicht per DMA, sondern per
Handshake betrieben.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht erst ab <a href="002.html">TOS</a> 3.* (Atari TT) zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20DMAread">Binding</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20DMAread"></a>4.13.1.1 Bindings für DMAread</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#DMAread">DMAread</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #42,-(sp)    ; Offset  0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="DMAwrite"></a>4.13.2 DMAwrite</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»DMA write« - schreibt einzelne Sektoren auf eine
DMA-Einheit.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">43</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t DMAwrite( int32_t sector, int16_t count, void *buffer,
int16_t devno );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine DMAwrite schreibt einzelne oder mehrere
Sektoren auf ein ACSI- oder SCSI-Gerät. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top">erste Sektornummer</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der Sektoren</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">Anfangsadresse im Speicher</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Gerätenummer. Es gilt:<br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI-Geräte</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI-Geräte</td>
</tr>
</table>
</div>

<br>

Alle anderen Werte sind für zukünftige Erweiterungen reserviert.

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> In vielen Fällen ist es sinnvoller, statt dieser
Funktion <a href="About_the_BIOS.html#Rwabs">Rwabs</a> zu verwenden. Der angegebene Speicherbereich muß für
die jeweilige Hardware lesbar sein (Stichwort: <a href="003007.html#Fast-RAM-Buffer">Fast-RAM-Buffer</a>).
SCSI-Geräte werden von dieser Funktion nicht per DMA, sondern per
Handshake betrieben.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht erst ab <a href="002.html">TOS</a> 3.* (Atari TT) zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20DMAwrite">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20DMAwrite"></a>4.13.2.1 Bindings für DMAwrite</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#DMAwrite">DMAwrite</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #43,-(sp)    ; Offset  0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Flopfmt"></a>4.13.3 Flopfmt</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Floppy format« - formatiert einzelne Spuren auf einer
Diskette.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">10</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Flopfmt( void *buf, int32_t filler, int16_t devno,
int16_t spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t
magic, int16_t virgin );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Flopfmt formatiert eine oder mehrere Spuren
auf einer Diskette. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top">Zeiger auf einen Bereich, in dem die Daten für die Spur
gespeichert werden können.</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top">bei allen <a href="002.html">TOS</a>-Versionen < 1.02 unbenutzt, und auf 0 zu setzen.
Ab dem Blitter-<a href="002.html">TOS</a> gilt: wenn <i>interlv</i> = -1 ist, so ist
<i>filler</i> als Zeiger auf eine Tabelle von Sektornummern anzusehen
(16Bit-Worte). Dadurch ergibt sich die Möglichkeit, die Reihenfolge
der Sektoren auf der Spur frei zu wählen.</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">0 = Laufwerk-A, 1 = Laufwerk-B</td></tr>

<tr><td nowrap="nowrap" valign="top">spt</td>
<td valign="top">Sektoren pro Spur (normal: 9). Falls der Cookie <a href="003007.html#Cookie_2C_20_FDC">_FDC</a> gesetzt
ist, sind auch Werte von 18 (High-Density) bzw. 36
(Extra-High-Density) Sektoren erlaubt. Die Umschaltung der
verschiedenen Schreibverfahren findet bei 13 (HD) bzw. 26 (<a href="00f00d.html#ED">ED</a>) statt.</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top">Nummer der Spur (0..79)</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top">0: Seite-1
<br>1: Seite-2 (bei doppelseitigen Disketten)</td></tr>

<tr><td nowrap="nowrap" valign="top">interlv</td>
<td valign="top">bestimmt, wie viele physikalische Sektoren jeweils zwischen
zwei logischen Sektoren liegen (normal: 1)</td></tr>

<tr><td nowrap="nowrap" valign="top">magic</td>
<td valign="top">0x87654321, sonst wird nicht formatiert.</td></tr>

<tr><td nowrap="nowrap" valign="top">virgin</td>
<td valign="top">Bitmuster, welches beim Formatieren in jeden Sektor geschrieben
wird (normal: 0xe5e5). Die oberen vier Bits dürfen nicht gesetzt
werden, da dies sonst vom Controller als Kommando interpretiert
würde.

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Ab dem Blitter-<a href="002.html">TOS</a> erlaubt es das Desktop, eine
Liste von Sektornummern zu übergeben, um Spuren derart zu
spiralisieren, daß beim Spurwechsel möglichst wenig Zeit mit dem
Warten auf den nächsten Sektor verloren wird.<br><br>

Bei einem normalen Format (9 Sektoren pro Spur) muss der über den
Parameter <i>buf</i> angegebene Speicherbereich eine Größe von
mindestens 8 Kbyte besitzen; in anderen Fällen muss der Puffer evtl.
noch vergrößert werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist. Im Fehlerfall wird eine durch 0 abgeschlossene Liste der
fehlerhaften Sektoren in den Puffer geschrieben.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Flopfmt">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopfmt"></a>4.13.3.1 Bindings für Flopfmt</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Flopfmt">Flopfmt</a>( void *buf, int32_t filler, int16_t devno, int16_t
spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t magic,
int16_t virgin );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    virgin,-(sp)  ; Offset 24
move.l    magic,-(sp)   ; Offset 20
move.w    interlv,-(sp) ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    spt,-(sp)     ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #10,-(sp)     ; Offset  0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
lea       $1A(sp),sp    ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(10,L:buf%,L:filler%,W:devno%,W:spt%,W:trackno%,W:sideno%,W:interlv%,L:magic%,W:virgin%)

</td></tr>
</table>

<h3><a name="Floprate"></a>4.13.4 Floprate</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Floppy rate« - liest oder setzt die seek rate eines
Floppylaufwerks.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">41</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Floprate( int16_t devno, int16_t newrate );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Floprate liefert bzw. setzt die aktuelle
Seekrate. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Laufwerksnummer<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-A</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-B usw.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">newrate</td>
<td valign="top"><br><br>


<div align="left">
<table border="0">
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seekrate nicht verändern</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  6ms</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von 12ms</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  2ms</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  3ms</td>
</tr>
</table>
</div>



</td></tr>
</table>

<a name="Floppy_2C_20Timeout_20der"></a>
<a name="Timeout_20der_20Floppy"></a>
<br><br>

<b>Hinweis:</b> Ab <a href="00b.html">MagiC</a> 3 kann darüberhinaus per Floprate (-1,
newrate) der <b>Timeout</b> für die Floppy eingestellt werden; ein
Wert von 300 bedeutet 1,5 Sekunden (dies ist der Wert, der beim Booten
per Default eingestellt ist).<br><br>

Bei älteren ROM-<a href="002.html">TOS</a>-Versionen muß man die vorher
undokumentierten Systemvariablen verwenden:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top"><a href="002.html">TOS</a>-Version</td>
  <td align="center" valign="top">Laufwerk A</td>
  <td align="center" valign="top">Laufwerk B</td>
</tr>
<tr>
  <td align="center" valign="top">1.00</td>
  <td align="center" valign="top">0x0a08</td>
  <td align="center" valign="top">0xa0c</td>
</tr>
<tr>
  <td align="center" valign="top">1.02</td>
  <td align="center" valign="top">0x0a4e</td>
  <td align="center" valign="top">0xa52</td>
</tr>
</table>
</div>

<br><br>

Zum portablen Setzen kann man die folgende <a href="#Seekrate_20f_C3_BCr_20alle_20TOS-Versionen">Beispielroutine</a> nutzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die vorherige Seekrate als Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht erst ab <a href="002.html">TOS</a> 1.04 zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Floprate">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopver">Flopver</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Floprate"></a>4.13.4.1 Bindings für Floprate</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Floprate">Floprate</a>( int16_t devno, int16_t newrate );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    newrate,-(sp) ; Offset 4
move.w    devno,-(sp)   ; Offset 2
move.w    #41,-(sp)     ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h4><a name="Seekrate_20f_C3_BCr_20alle_20TOS-Versionen"></a>4.13.4.2 Seekrate für alle TOS-Versionen</h4>
<pre>/* Portables Setzen der Floppy-Seekrate für alle TOS-Versionen
   (außer RAM-<a href="002.html">TOS</a> 1.00).
   Parameter: genau wie bei <a href="004.html">XBIOS</a>-Funktion "<a href="#Floprate">Floprate</a>()" */

int16_t SeekRate ( int16_t devno, int16_t newrate )
{
  int32_t stack;
  int16_t version;
  <a href="010009.html#OSHEADER">OSHEADER</a> *sys;

  /* Zeiger auf OS-Header holen */
  stack = <a href="00500e.html#Super">Super</a> (0L);
  sys = *((<a href="010009.html#OSHEADER">OSHEADER</a> **) 0x4f2);
  version = sys->os_version;
  <a href="00500e.html#Super">Super</a> ((void *)stack);

  /* bei neuem <a href="002.html">TOS</a> einfach "<a href="#Floprate">Floprate</a>()" aufrufen */
  if ( version >= 0x0104 )
    return <a href="#Floprate">Floprate</a> ( devno, newrate );
  else
  {
    /* sonst Zeiger auf interne <a href="005.html">GEMDOS</a>-Variablen
       berechnen */
    int16_t *sk, merk;

    if ( version == 0x0102 )
      sk = (int16_t *) 0x0a4e;
    else
      sk = (int16_t *) 0x0a08;

    /* Laufwerk B: 2 int16_t dahinter */
    if ( devno ) sk = &(sk[2]);

    merk = *sk;
    /* Wert nur bei ungleich -1 eintragen */
    if ( newrate != -1 ) *sk = newrate;

    /* alten Wert immer zurückliefern */
    return merk;
  }
}
</pre>
<h3><a name="Floprd"></a>4.13.5 Floprd</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Floppy read« - liest einzelne Sektoren von einer
Platteneinheit.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">8</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Floprd( void *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Floprd liest einen oder mehrere physikalische
Sektoren von einer Diskette. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top">Zeiger auf Speicherbereich für die eingelesenen Sektoren</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top">unbenutzt</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Laufwerk (0 = Laufwerk-A usw.)</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top">Startsektor (normal zwischen 1 und 9)</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top">Tracknummer (normal zwischen 0 und 79)</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top">Seite der Diskette (0 oder 1)</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der zu lesenden Sektoren

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Floprd">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Floprd"></a>4.13.5.1 Bindings für Floprd</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Floprd">Floprd</a>( void *buf, int32_t filler, int16_t devno, int16_t
sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)   ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    sectno,-(sp)  ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #8,-(sp)      ; Offset  0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
lea       $14(sp),sp    ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(8,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno%,W:count%)

</td></tr>
</table>

<h3><a name="Flopver"></a>4.13.6 Flopver</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Floppy verify« - überprüft Disketten.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">19</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Flopver( void *buf, int32_t filler, int16_t devno,
int16_ sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Flopver überprüft, ob eine Reihe von
Sektoren fehlerfrei von einem Disketten-Laufwerk gelesen werden kann.
Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top">Zeiger auf einen 1024 Byte großen Speicherbereich, in den die
zu verifizierenden Sektoren eingelesen werden können.</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top">unbenutzt (sollte auf 0 gesetzt werden)</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Laufwerk<br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-A</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-B</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top">Startsektor (normal zwischen 1 und 9)</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top">Tracknummer (normal zwischen 0 und 79)</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top">Seite der Diskette (0 oder 1)</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der zu überprüfenden Sektoren

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Nach dem Aufruf findet man im Parameter
<i>buf</i> eine durch Null abgeschlossene Liste von 16-Bit Worten mit
den Nummern der defekten Sektoren. Die Funktion vergleicht also
<i>keine</i> Sektoren mit einem Speicherbereich; stattdessen liest
sie die Sektoren in den immer selben Puffer ein. Dabei wird nur
überprüft, ob die Sektoren korrekt gelesen werden können, oder ob
beim Lesen Lesefehler auftreten.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis den Wert 0, wenn die im
Parameter <i>buf</i> abgelegte Liste gültig ist und anderenfalls
einen Wert ungleich Null.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Flopver">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopver"></a>4.13.6.1 Bindings für Flopver</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Flopver">Flopver</a>( void *buf, int32_t filler, int16_t devno, int16_
sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #19,-(sp)      ; Offset  0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
lea       $14(sp),sp     ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(19,L:buf%,L:filler%,W:devno%,W:sectno,W:trackno%,W:sideno%,W:count%)

</td></tr>
</table>

<h3><a name="Flopwr"></a>4.13.7 Flopwr</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Floppy write« - schreibt einzelne Sektoren auf eine
Platteneinheit.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">9</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Flopwr( VOID *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Flopwr schreibt einen oder mehrere
physikalische Sektoren auf eine Diskette. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top">Zeiger auf Speicherbereich mit den zu schreibenden Sektoren</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top">unbenutzt</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top">Laufwerk (0=Laufwerk-A, 1=Laufwerk-B)</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top">Startsektor (normal zwischen 1 und 9)</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top">Tracknummer (normal zwischen 0 und 79)</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top">Seite der Diskette (0 oder 1)</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der zu schreibenden Sektoren

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Flopwr">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopwr"></a>4.13.7.1 Bindings für Flopwr</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Flopwr">Flopwr</a>( VOID *buf, int32_t filler, int16_t devno, int16_t
sectno, int16_t trackno, int16_t sideno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #9,-(sp)       ; Offset  0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
lea       $14(sp),sp     ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(9,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno,W:count%)

</td></tr>
</table>

<h3><a name="Metaclose"></a>4.13.8 Metaclose</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metaclose« - gibt ein MetaDOS-Gerät wieder frei.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">50</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metaclose( int16_t drive );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion gibt das Laufwerk <i>drive</i> wieder frei.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metaclose">Binding</a> &nbsp; <a href="#Metaopen">Metaopen</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaclose"></a>4.13.8.1 Bindings für Metaclose</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metaclose">Metaclose</a>( int16_t drive );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    drive,-(sp)  ; Offset 2
move.w    #50,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metadiscinfo"></a>4.13.9 Metadiscinfo</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metadiscinfo« - ermittelt aktuelle Status-Informationen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">63</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metadiscinfo( int16_t drive, <a href="004015.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion ermittelt Informationen über den Status eines
<a href="004002.html">MetaDOS</a>-Gerätes. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">p</td>
  <td align="left" valign="top">Adresse des aufnehmenden Puffers</td>
</tr>
</table>
</div>

<br><br>

<b>Hinweis:</b> Die Positionsangaben innerhalb der Struktur sind
im BCD-MSF-Format codiert. Die Komponente <i>index</i> wird von alten
BOS-Treibern nicht gesetzt, und die Komponente <i>disctype</i> ist
bei SCSI-<a href="00f00d.html#CD">CD</a>-ROMs nicht gesetzt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem MetaDOS zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metadiscinfo">Binding</a> &nbsp; <a href="#Metastatus">Metastatus</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metadiscinfo"></a>4.13.9.1 Bindings für Metadiscinfo</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metadiscinfo">Metadiscinfo</a>( int16_t drive, <a href="004015.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       p            ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #63,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metagettoc"></a>4.13.10 Metagettoc</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metagettoc« - liefert das Inhaltsverzeichnis eines Gerätes.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">62</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metagettoc( int16_t drive, int16_t flag, <a href="004015.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion liefert das Inhaltsverzeichnis eines Laufwerks zurück. Es
gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">flag</td>
  <td align="left" valign="top">reserviert für CDAR504</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">Puffer zur Aufnahme des Verzeichnisses</td>
</tr>
</table>
</div>

<br><br>

<b>Hinweis:</b> Der aufnehmende Puffer sollte Platz für 128
Einträge bieten. Jeder Eintrag besteht aus einer Tracknummer und
MSF-Adresse (jeweils im BCD-Format). Für die Tracknummer gilt dabei:
<br>0 = Record hat keine Bedeutung
<br>0x01...0x99 = Tracknummer in BCD-Codierung
<br>0xa0 = erster Track bei programmierter Reihenfolge
<br>0xa2 = Ende der <a href="00f00d.html#CD">CD</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metagettoc">Binding</a> &nbsp; <a href="#Metaread">Metaread</a> &nbsp; <a href="#Metawrite">Metawrite</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metagettoc"></a>4.13.10.1 Bindings für Metagettoc</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metagettoc">Metagettoc</a>( int16_t drive, int16_t flag, <a href="004015.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer       ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #62,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metainit"></a>4.13.11 Metainit</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metainit« - Informationen über die installierte Version von
<a href="004002.html">MetaDOS</a> ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">48</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Metainit( <a href="004015.html#META_INFO_1">META_INFO_1</a> *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Metainit ermittelt Informationen über die
aktuell installierte Version von <a href="004002.html">MetaDOS</a>, und der ihr bekannten
Geräte.<br><br>

Es bietet sich folgendes Verfahren an:<ul>
<li>Inhalt der <a href="004015.html#META_INFO_1">META_INFO_1</a> Struktur komplett löschen</li>
<li>Funktion Metainit aufrufen</li>
<li>Testen, ob die Komponente <i>version</i> noch einen Nullzeiger
enthält (dann ist <i>kein</i> MetaDOS installiert).</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein direktes Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metainit">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metainit"></a>4.13.11.1 Bindings für Metainit</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">void <a href="#Metainit">Metainit</a>( <a href="004015.html#META_INFO_1">META_INFO_1</a> *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer       ; Offset 2
move.w    #48,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metaioctl"></a>4.13.12 Metaioctl</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metaioctl« - schickt GEMDOS-Opcodes an ein MetaDOS Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">55</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metaioctl( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion erlaubt es, Opcodes der GEMDOS-Routinen Dcntl
bzw. Fcntl an ein <a href="004002.html">MetaDOS</a> Gerät abzusetzen. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">magic</td>
  <td align="left" valign="top">muss Wert 'FCTL' besitzen</td>
</tr>
<tr>
  <td align="left" valign="top">opcode</td>
  <td align="left" valign="top">abzusetzender Opcode</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">abhängig vom Opcode</td>
</tr>
</table>
</div>

<br><br>

<b>Hinweis:</b> Die <a href="005009.html#CD-ROM-Funktionen">Liste der CD-ROM Kommandos</a> ist eine Aufstellung aller bekannten
Opcodes, die bei der Arbeit mit <a href="00f00d.html#CD">CD</a>-ROMs anfallen können.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert im Fehlerfall einen der folgenden Werte
zurück:<table>
<tr><td nowrap="nowrap" valign="top"><a href="005003.html#EINVFN">EINVFN</a>:</td>
<td valign="top">der angegebene Opcode wird nicht unterstützt.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="003006.html#EUNCMD">EUNCMD</a>:</td>
<td valign="top">die Funktion selbst (!) wird nicht unterstützt.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem MetaDOS zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metaioctl">Binding</a> &nbsp; <a href="00500f.html#Dcntl">Dcntl</a> &nbsp; <a href="005009.html#Fcntl">Fcntl</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaioctl"></a>4.13.12.1 Bindings für Metaioctl</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metaioctl">Metaioctl</a>( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer       ; Offset 10
move.w    opcode,-(sp) ; Offset  8
move.l    magic,-(sp)  ; Offset  4
move.w    drive,-(sp)  ; Offset  2
move.w    #55,-(sp)    ; Offset  0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metaopen"></a>4.13.13 Metaopen</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metaopen« - initialisiert ein MetaDOS-Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">49</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metaopen( int16_t drive, <a href="004015.html#META_DRVINFO">META_DRVINFO</a> *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion initialisiert ein MetaDOS-Gerät. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">Puffer zur Aufnahme des Namens des Treibers

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Falls der Treibername mit '<a href="00f00d.html#CD">CD</a>' beginnt, darf man
davon ausgehen, daß es sich um einen <a href="00f00d.html#CD">CD</a>-ROM-Treiber handelt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert 0 wenn alles OK
oder eine negative Fehlernummer.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metaopen">Binding</a> &nbsp; <a href="#Metaclose">Metaclose</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaopen"></a>4.13.13.1 Bindings für Metaopen</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metaopen">Metaopen</a>( int16_t drive, <a href="004015.html#META_DRVINFO">META_DRVINFO</a> *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #49,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metaread"></a>4.13.14 Metaread</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metaread« - liest Daten von einem MetaDOS-Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">51</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metaread( int16_t drive, void *buffer, int32_t blockno,
int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion liest Daten von einem MetaDOS-Gerät. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">Puffer zur Aufnahme der Daten</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top">Nummer des Startblocks</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der zu lesenden Blöcke

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Die Blockgröße beträgt bei <a href="00f00d.html#CD">CD</a>-ROMs 2048 Bytes;
dies kann jedoch leider nicht gezielt abgefragt werden. Aufgrund einer
Begrenzung in Atari's BOS-Treibern können maximal 63 Blöcke an einem
Stück gelesen werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metaread">Binding</a> &nbsp; <a href="#Metawrite">Metawrite</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaread"></a>4.13.14.1 Bindings für Metaread</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metaread">Metaread</a>( int16_t drive, void *buffer, int32_t blockno,
int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #51,-(sp)     ; Offset  0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp     ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metasetsongtime"></a>4.13.15 Metasetsongtime</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metasetsongtime« - startet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">61</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metasetsongtime">Bindings für Metasetsongtime</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion startet eine Audio-Wiedergabe. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">repeat</td>
<td valign="top">Repeat<br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">ohne Wiederholung</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">mit Wiederholung</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">starttime</td>
<td valign="top">BCD-Anfangszeit in MSF-Codierung</td></tr>

<tr><td nowrap="nowrap" valign="top">endtime</td>
<td valign="top">BCD-Endzeit in MSF-Codierung

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Der Repeat-Modus wird anscheinend nur von
CDARGEN.BOS und auch nur für das Atari-CDAR504 unterstützt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metasetsongtime">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metasetsongtime"></a>4.13.15.1 Bindings für Metasetsongtime</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metasetsongtime">Metasetsongtime</a>( int16_t drive, int16_t repeat, int32_t
starttime, int32_t endtime );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    endtime,-(sp)    ; Offset 10
move.l    starttime,-(sp)  ; Offset  6
move.w    repeat           ; Offset  4
move.w    drive            ; Offset  2
move.w    #61,-(sp)        ; Offset  0
trap      #14              ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metastartaudio"></a>4.13.16 Metastartaudio</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metastartaudio« - startet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">59</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top">int32_t Metastartaudio( int16_t drive, int16_t flag, uint8_t
*bytearray);</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion startet eine Audio-Wiedergabe. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">flag</td>
<td valign="top">Modus</td></tr>

<tr><td nowrap="nowrap" valign="top">bytearray</td>
<td valign="top">abhängig vom Parameter flag

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Auf SCSI-Geräten existiert nur ein Modus (flag =
0). In diesem Fall übergibt man in <i>bytearray[0]</i> die Anzahl
der Lieder, und in <i>bytearray[1]</i> die Nummer des ersten Liedes.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="Metastartaudio.html#Bindings_20f_C3_BCr_20Metastartaudio">Binding</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastartaudio"></a>4.13.16.1 Bindings für Metastartaudio</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metastartaudio">Metastartaudio</a>( int16_t drive, int16_t flag, uint8_t
*bytearray);</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       bytearray    ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #59,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metastatus"></a>4.13.17 Metastatus</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metastatus« - ermittelt den Status eines MetaDOS Gerätes.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">54</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metastatus( int16_t drive, void *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion ermittelt den Status eines MetaDOS Gerätes. Es
gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">abhängig von der Implementierung des BOS-Treibers

</td></tr>
</table>

<br><br>

<b>Achtung:</b> Diese Funktion ist optional. Sie steht nur bei
installiertem <a href="004002.html">MetaDOS</a> zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen 32-Bit Wert zurück,
der wie folgt codiert ist:<table>
<tr><td nowrap="nowrap" valign="top">High-Word:</td>
<td valign="top"><br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">0x0000</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">alles ok</td>
</tr>
<tr>
  <td align="left" valign="top">0xffff</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Fehler aufgetreten</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word :</td>
<td valign="top"><br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Bit-15</td>
  <td align="left" valign="top">(Fehler)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-07</td>
  <td align="left" valign="top">(Timeout)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-02</td>
  <td align="left" valign="top">(Medienwechsel)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-01</td>
  <td align="left" valign="top">(Busy)</td>
</tr>
</table>
</div>



</td></tr>
</table>

<br><br>

Alle anderen Bits des Low-Words sind z.Zt. reserviert.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metastatus">Binding</a> &nbsp; <a href="#Metadiscinfo">Metadiscinfo</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastatus"></a>4.13.17.1 Bindings für Metastatus</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metastatus">Metastatus</a>( int16_t drive, void *buffer );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #54,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metastopaudio"></a>4.13.18 Metastopaudio</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metastopaudio« - beendet eine Audio-Wiedergabe.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">60</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metastopaudio( int16_t drive );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion beendet die Audio-Wiedergabe für das Laufwerk
<i>drive</i>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metastopaudio">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastopaudio"></a>4.13.18.1 Bindings für Metastopaudio</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metastopaudio">Metastopaudio</a>( int16_t drive );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    drive,-(sp)  ; Offset 2
move.w    #60,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Metawrite"></a>4.13.19 Metawrite</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Metawrite« - schreibt Daten auf ein MetaDOS-Gerät.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">52</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t Metawrite( int16_t drive, void *buffer, int32_t
blockno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die Funktion schreibt Daten auf ein MetaDOS-Gerät. Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top">gewünschtes Laufwerk</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top">Adresse des Datenpuffers</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top">Nummer des Startblocks</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der zu schreibenden Blöcke

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Bei einem <a href="00f00d.html#CD">CD</a>-ROM hat diese Funktion natürlich
keine Wirkung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Diese Funktion steht nur bei installiertem <a href="004002.html">MetaDOS</a> zur
Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Metawrite">Binding</a> &nbsp; <a href="#Metaread">Metaread</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metawrite"></a>4.13.19.1 Bindings für Metawrite</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">int32_t <a href="#Metawrite">Metawrite</a>( int16_t drive, void *buffer, int32_t
blockno, int16_t count );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #52,-(sp)     ; Offset  0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp     ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Protobt"></a>4.13.20 Protobt</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»prototype boot sector« - Standard-Boot-Sektor.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">18</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Protobt( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Protobt legt einen Boot-Sektor auf einer
Diskette an. Das Argument <i>buf</i> verweist auf einen 512 Byte
großen Puffer mit dem Inhalt des Boot-Sektors. Der Parameter
<i>serialno</i> dient dazu, eine Seriennummer im Bootsektor
abzuspeichern. Wenn die Variable <i>serialno</i> größer als
0x01000000 ist, dann wird eine Zufallszahl abgelegt. Mit
<i>disktype</i> wird eine der folgenden Diskettenarten ausgewählt:<table>
<tr><td nowrap="nowrap" valign="top">disktype</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;-1</td>
<td valign="top">nicht verändern</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;0</td>
<td valign="top">40 Spuren, einseitig&nbsp;&nbsp;&nbsp; (180 Kbyte)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;1</td>
<td valign="top">40 Spuren, doppelseitig (360 Kbyte)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;2</td>
<td valign="top">80 Spuren, einseitig&nbsp;&nbsp;&nbsp; (360 Kbyte)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;3</td>
<td valign="top">80 Spuren, doppelseitig (720 Kbyte)</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;4</td>
<td valign="top"><b>High-Density</b> (1,44 Mbyte)
<br>Wird nur unterstützt, wenn im Cookie <a href="003007.html#Cookie_2C_20_FDC">_FDC</a> der Wert für
HD-Unterstützung eingetragen ist.</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;5</td>
<td valign="top"> <b>Extra-High-Density</b> (2,88 Mbyte)
<br>Wird nur unterstützt, wenn im Cookie _FDC der Wert für
<a href="00f00d.html#ED">ED</a>-Unterstützung eingetragen ist.

</td></tr>
</table>

<br><br>

Der Parameter <i>execflag</i> legt schließlich fest, ob die
Informationen im Boot-Sektor als Programm ausgeführt werden können.
Es gilt:<table>
<tr><td nowrap="nowrap" valign="top">execflag</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top">Bootsektor nicht verändern</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top">Bootsektor nicht ausführen</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top">Bootsektor ausführbar

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Damit Disketten auch auf MSDOS-Systemen gelesen
werden können, müssen in die ersten 3 Bytes des Bootsektors die
Werte 0xE9, 0x00 und 0x4E oder 0xEB, 0x34 und 0x90 eingetragen werden;
auf diese Art und Weise behandelte Disketten sind unter <a href="002.html">TOS</a> dann
allerdings <i>nicht</i> mehr bootbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Laufwerksfunktionen">Laufwerksfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Protobt">Binding</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Protobt"></a>4.13.20.1 Bindings für Protobt</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Protobt">Protobt</a>( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    execflag,-(sp)  ; Offset 12
move.w    disktype,-(sp)  ; Offset 10
move.l    serialno,-(sp)  ; Offset  6
pea       buf             ; Offset  2
move.w    #18,-(sp)       ; Offset  0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $E(sp),sp       ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">Fehler%=Xbios(18,L:buf%,L:serialno%,W:disktype%,W:execflag%)

</td></tr>
</table>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="00400c.html"><img src="udo_lf.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="00400e.html"><img src="udo_rg.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24"></a></body>
</html>

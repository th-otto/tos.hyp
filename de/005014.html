<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: GEMDOS-Strukturen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="005013.html"><img src="udo_lf.gif" alt="GEMDOS-Funktionsliste" title="GEMDOS-Funktionsliste" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="006.html"><img src="udo_rg.gif" alt="Line-A" title="Line-A" border="0" width="24" height="24"></a>
<hr>

<h1><a name="GEMDOS-Strukturen"></a>5.20 GEMDOS-Strukturen</h1>
<ul class="content">
	<li>5.20.1 <a href="#CD-ROM_20Definitionen">CD-ROM Definitionen</a>
	</li>
	<li>5.20.2 <a href="#cdrom_audioctrl">cdrom_audioctrl</a>
	</li>
	<li>5.20.3 <a href="#cdrom_mcn">cdrom_mcn</a>
	</li>
	<li>5.20.4 <a href="#cdrom_msf">cdrom_msf</a>
	</li>
	<li>5.20.5 <a href="#cdrom_read">cdrom_read</a>
	</li>
	<li>5.20.6 <a href="#cdrom_subchnl">cdrom_subchnl</a>
	</li>
	<li>5.20.7 <a href="#cdrom_ti">cdrom_ti</a>
	</li>
	<li>5.20.8 <a href="#cdrom_tisrc">cdrom_tisrc</a>
	</li>
	<li>5.20.9 <a href="#cdrom_tocentry">cdrom_tocentry</a>
	</li>
	<li>5.20.10 <a href="#cdrom_tochdr">cdrom_tochdr</a>
	</li>
	<li>5.20.11 <a href="#cdrom_volctrl">cdrom_volctrl</a>
	</li>
	<li>5.20.12 <a href="#cd_ad">cd_ad</a>
	</li>
	<li>5.20.13 <a href="#DISKINFO">DISKINFO</a>
	</li>
	<li>5.20.14 <a href="#DOSTIME">DOSTIME</a>
	</li>
	<li>5.20.15 <a href="#DOSVARS">DOSVARS</a>
	</li>
	<li>5.20.16 <a href="#DTA">DTA</a>
	</li>
	<li>5.20.17 <a href="#fcookie">fcookie</a>
	</li>
	<li>5.20.18 <a href="#FILEPTR">FILEPTR</a>
	</li>
	<li>5.20.19 <a href="#flock_2C_20Fcntl">flock, Fcntl</a>
	</li>
	<li>5.20.20 <a href="#LINE">LINE</a>
	</li>
	<li>5.20.21 <a href="#ltchars">ltchars</a>
	</li>
	<li>5.20.22 <a href="#mutimbuf">mutimbuf</a>
	</li>
	<li>5.20.23 <a href="#Process-Descriptor_20_28PD_29_20bzw._20BASEPAGE">Process-Descriptor (PD) bzw. BASEPAGE</a>
	</li>
	<li>5.20.24 <a href="#ploadinfo">ploadinfo</a>
	</li>
	<li>5.20.25 <a href="#sgttyb">sgttyb</a>
	</li>
	<li>5.20.26 <a href="#struct_20sigaction">struct sigaction</a>
	</li>
	<li>5.20.27 <a href="#tchars">tchars</a>
	</li>
	<li>5.20.28 <a href="#timeval">timeval</a>
	</li>
	<li>5.20.29 <a href="#timezone">timezone</a>
	</li>
	<li>5.20.30 <a href="#struct_20tty">struct tty</a>
	</li>
	<li>5.20.31 <a href="#winsize">winsize</a>
	</li>
	<li>5.20.32 <a href="#XATTR">XATTR</a>
	</li>
</ul>

<h3><a name="CD-ROM_20Definitionen"></a>5.20.1 CD-ROM Definitionen</h3>
<a name="CDROM_LBA"></a>
<a name="CDROM_MSF"></a>
<a name="CDROM_AUDIO_EMPHASIS"></a>
<a name="CDROM_COPY_PERMITTED"></a>
<a name="CDROM_DATA_TRACK"></a>
<a name="CDROM_FOUR_CHANNEL"></a>
<a name="CDROM_LEADOUT"></a>
<a name="CDROM_AUDIO_INVALID"></a>
<a name="CDROM_AUDIO_PLAY"></a>
<a name="CDROM_AUDIO_PAUSED"></a>
<a name="CDROM_AUDIO_COMPLETED"></a>
<a name="CDROM_AUDIO_ERROR"></a>
<a name="CDROM_AUDIO_NO_STATUS"></a>
<pre>/* Adressierungs-Typen */

#define CDROM_LBA               0x01
#define CDROM_MSF               0x02

/* SUB-Q Kontroll-Bits */

#define CDROM_AUDIO_EMPHASIS    0x01
#define CDROM_COPY_PERMITTED    0x02
#define CDROM_DATA_TRACK        0x04
#define CDROM_FOUR_CHANNEL      0x08

/* The leadout track is always 0xAA, regardless of # of tracks on disc */

#define CDROM_LEADOUT   0xAA

/* Rückgabewerte von READ SUBCHANNEL DATA */

#define CDROM_AUDIO_INVALID     0x00  /* audio status not supported         */
#define CDROM_AUDIO_PLAY        0x11  /* audio play operation in progress   */
#define CDROM_AUDIO_PAUSED      0x12  /* audio play operation paused        */
#define CDROM_AUDIO_COMPLETED   0x13  /* audio play successfully completed  */
#define CDROM_AUDIO_ERROR       0x14  /* audio play stopped due to error    */
#define CDROM_AUDIO_NO_STATUS   0x15  /* no current audio status to return  */
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_audioctrl"></a>5.20.2 cdrom_audioctrl</h3>
<pre>struct cdrom_audioctrl
{
    /* Eingabe-Parameter */

    int16_t set;                   /* 0 = nur nachfragen */

    /* Ein-/Ausgabe-Parameter */

    struct
    {
        int8_t selection;
        int8_t volume;
    } channel[4];
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_mcn"></a>5.20.3 cdrom_mcn</h3>
<pre>struct cdrom_mcn
{
    int8_t  mcn_audiostatus;
    int8_t  mcn_mcn[23];       /* Media-Katalog-Nummer als ASCII-String */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a> &nbsp; <a href="010001.html">ASCII-Tabelle</a></p>

<h3><a name="cdrom_msf"></a>5.20.4 cdrom_msf</h3>
<pre>struct cdrom_msf
{
    int8_t cdmsf_min0;       /* Anfangs-Minute  */
    int8_t cdmsf_sec0;       /* Anfangs-Sekunde */
    int8_t cdmsf_frame0;     /* Anfangs-Frame   */
    int8_t cdmsf_min1;       /* Ende-Minute     */
    int8_t cdmsf_sec1;       /* Ende-Sekunde    */
    int8_t cdmsf_frame1;     /* Ende-Frame      */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_read"></a>5.20.5 cdrom_read</h3>
<pre>struct cdrom_read
{
    int32_t  cdread_lba;       /* Adresse               */
    int8_t  *cdread_bufaddr;   /* Zeiger auf den Puffer */
    int32_t  cdread_buflen;    /* Länge des Puffers     */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_subchnl"></a>5.20.6 cdrom_subchnl</h3>
<pre>struct cdrom_subchnl
{
    /* Eingabe-Parameter */

    int8_t cdsc_format;             /* <a href="005014.html#CDROM_MSF">CDROM_MSF</a> oder <a href="005014.html#CDROM_LBA">CDROM_LBA</a> */

    /* Ausgabe-Parameter */

    int8_t   cdsc_audiostatus;
    unsigned cdsc_resvd: 8;         /* reserviert               */
    unsigned cdsc_adr  : 4;
    unsigned cdsc_ctrl : 4;
    int8_t   cdsc_track;            /* aktueller Track          */
    int8_t   cdsc_ind;              /* aktueller <a href="indexudo.html">Index</a>          */
    <a href="#cd_ad">cd_ad</a>    cdsc_absaddr;          /* absolute Adresse         */
    <a href="#cd_ad">cd_ad</a>    cdsc_reladdr;          /* relative Track-Adresse   */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_ti"></a>5.20.7 cdrom_ti</h3>
<pre>struct cdrom_ti
{
    int8_t cdti_trk0;        /* Start-Track */
    int8_t cdti_ind0;        /* Start-<a href="indexudo.html">Index</a> */
    int8_t cdti_trk1;        /* Ende-Track  */
    int8_t cdti_ind1;        /* Ende-<a href="indexudo.html">Index</a>  */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_tisrc"></a>5.20.8 cdrom_tisrc</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>struct cdrom_tisrc
{
    /* Eingabe-Parameter */

    int8_t tisrc_track;          /* Track-Nummer */

    /* Ausgabe-Parameter */

    int8_t tisrc_audiostatus;
    int8_t tisrc_tisrc[23];      /* Track International Standard
                                    Recording Code als ASCII-String */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a> &nbsp; <a href="010001.html">ASCII-Tabelle</a></p>

<h3><a name="cdrom_tocentry"></a>5.20.9 cdrom_tocentry</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>struct cdrom_tocentry
{
    /* Eingabe-Parameter */

    int8_t cdte_track;             /* Track-Nummer oder <a href="005014.html#CDROM_LEADOUT">CDROM_LEADOUT</a> */
    int8_t cdte_format;            /* <a href="005014.html#CDROM_LBA">CDROM_LBA</a> oder <a href="005014.html#CDROM_MSF">CDROM_MSF</a>        */

    /* Ausgabe-Parameter */

    unsigned cdte_adr:4;           /* SUBQ Channel Encodes; es gilt:
                                      0 = keine
                                      1 = Positions-Daten
                                      2 = MCN
                                      3 = ISRC
                                      (alle anderen Werte reserviert) */
    unsigned cdte_ctrl:4;          /* Bit-0: Audio mit Pre-Emphasis
                                      Bit-1: digitale Kopie möglich
                                      Bit-2: Daten Track
                                      Bit-3: 4-Kanal                  */
    int8_t   cdte_datamode;        /* z.Zt. unbenutzt                 */
    <a href="#cd_ad">cd_ad</a>    dte_addr;             /* Track-Start                     */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_tochdr"></a>5.20.10 cdrom_tochdr</h3>
<pre>struct cdrom_tochdr
{
    int8_t cdth_trk0;        /* Start-Track */
    int8_t cdth_trk1;        /* Ende-Track  */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cdrom_volctrl"></a>5.20.11 cdrom_volctrl</h3>
<pre>struct cdrom_volctrl
{
    int8_t  channel0;   /* Kanal-1: Lautstärke 0...255 */
    int8_t  channel1;   /* Kanal-2: Lautstärke 0...255 */
    int8_t  channel2;   /* Kanal-3: Lautstärke 0...255 */
    int8_t  channel3;   /* Kanal-4: Lautstärke 0...255 */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="cd_ad"></a>5.20.12 cd_ad</h3>
<p>Diese Union ist wie folgt definiert:</p>

<pre>typedef <a href="00f00e.html#union">union</a>
{
    struct
    {
       int8_t reserved;    /* reserviert */
       int8_t minute;      /* Minute     */
       int8_t second;      /* Sekunde    */
       int8_t frame;       /* Frame      */
    } msf;
    int32_t lba;
} cd_ad;
</pre>
<p>Querverweis: <a href="005009.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a></p>

<h3><a name="DISKINFO"></a>5.20.13 DISKINFO</h3>
<pre>typedef struct
{
    uint32_t   b_free;    /* Anzahl der freien Cluster */
    uint32_t   b_total;   /* Gesamtzahl der Cluster    */
    uint32_t   b_secsiz;  /* Bytes pro Sektor          */
    uint32_t   b_clsiz;   /* Sektoren pro Cluster      */
} DISKINFO;
</pre>
<p>Querverweis: <a href="00500f.html#Dfree">Dfree</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<h3><a name="DOSTIME"></a>5.20.14 DOSTIME</h3>
<pre>typedef struct
{
   uint16_t     time;  /* Zeit wie in <a href="00500a.html#Tgettime">Tgettime</a>  */
   uint16_t     date;  /* Datum wie in <a href="00500a.html#Tgetdate">Tgetdate</a> */
} DOSTIME;
</pre>
<p>Die Struktur der beiden Integer-Werte gliedert sich wie folgt:</p>

<table>
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top">time</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-4</td>
<td valign="top">Sekunden in Zweierschritten (0-29)</td></tr>

<tr><td nowrap="nowrap" valign="top">5-10</td>
<td valign="top">Minuten (0-59)</td></tr>

<tr><td nowrap="nowrap" valign="top">11-15</td>
<td valign="top">Stunden (0-23)

</td></tr>
</table>

<table>
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top">date</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">0-4</td>
<td valign="top">Tag im Monat (1-31)</td></tr>

<tr><td nowrap="nowrap" valign="top">5-8</td>
<td valign="top">Monat (1-12)</td></tr>

<tr><td nowrap="nowrap" valign="top">9-15</td>
<td valign="top">Jahr (0-119, 0=1980)

</td></tr>
</table>

<p>Querverweis: <a href="005009.html#Fdatime">Fdatime</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<h3><a name="DOSVARS"></a>5.20.15 DOSVARS</h3>
<pre>typedef struct
{
   int8_t    *in_dos;                 /* Adresse der DOS- Semaphore */
   int16_t   *dos_time;               /* Adresse der DOS- Zeit      */
   int16_t   *dos_date;               /* Adresse des DOS- Datums    */
   int32_t   res1;                    /*                            */
   int32_t   res2;                    /*                            */
   int32_t   res3;                    /* ist 0L                     */
   VOID      *act_pd;                 /* Laufendes Programm         */
   int32_t   res4;                    /*                            */
   int16_t   res5;                    /*                            */
   VOID      *res6;                   /*                            */
   VOID      *res7;                   /* interne DOS- Speicherliste */
   VOID      (*resv_intmem)();        /* DOS- Speicher erweitern    */
   int32_t   (*<a href="003004.html#etv_critic">etv_critic</a>)();         /* <a href="003004.html#etv_critic">etv_critic</a> des <a href="005.html">GEMDOS</a>      */
   int8_t *  ((*err_to_str)(int8_t e)); /* Umrechnung Code->Klartext*/
   int32_t   res8;                    /*                            */
   int32_t   res9;                    /*                            */
   int32_t   res10;                   /*                            */
} DOSVARS;
</pre>
<p><b>Hinweis:</b> Diese Variablen sind READ-ONLY !</p>

<p>Mit Hilfe der Funktion <i>resv_intmem</i> läßt sich ähnlich
wie mit FOLDRnnnn Speicher für die interne <a href="00500c.html">Speicherverwaltung</a>
reservieren. Im Gegensatz zu <a href="002.html">TOS</a> wird diese jedoch deutlich weniger
belastet, so daß ein Erweitern i.a. nicht notwendig ist. Muß der
Speicher erweitert werden, was auch in <a href="00b013.html#ADDMEM">ADDMEM</a> geschieht, übergibt man
der Funktion <i>resv_intmem</i> in Register A0 die Adresse, und in
Register D0 die Länge des zu reservierenden Speicherblocks.</p>

<p><b>Der Prototyp für den <i>Event-Critic-Handler</i> lautet:</b></p>

<pre>int32_t <a href="003004.html#etv_critic">etv_critic</a> (int16_t errcode, int16_t drvnr)
</pre>
<p>Man beachte, daß die Funktion die Argumente auf dem Stack
erwartet, und daher in <i>Pure-C</i> als <i>cdecl</i> deklariert
werden muß.</p>

<p>Die Funktion <i>err_to_str</i> erwartet in Register D0 einen
<a href="002.html">TOS</a>-Fehlercode, und gibt in den Registern D0 und A0 einen Zeiger auf
die beschreibende Zeichenkette zurück. Bei einem ungültigen
Fehlercode erhält man in D0 eine Null, und in A0 einen Zeiger auf die
Zeichenkette '<a href="002.html">TOS</a>-Fehler'.</p>

<p>Aus der Sicht von KAOS 1.4.2 sieht die Struktur folgendermaßen
aus:</p>

<pre>typedef struct
{
   int8_t    *in_dos;                 /* Adresse der DOS- Semaphore */
   int16_t   *dos_time;               /* Adresse der DOS- Zeit      */
   int16_t   *dos_date;               /* Adresse des DOS- Datums    */
   int32_t   dos_stack;               /* Stack für DOS selbst       */
   int32_t   pgm_superset;            /* Benutzerpgm.-Sup.stack     */
   <a href="003007.html#MD">MD</a>        *menlist[3];             /* Adresse der 3 <a href="003007.html#MD">MD</a>-Listen    */
   VOID      *act_pd;                 /* Laufendes Programm         */
   FCB       *fcbx;                   /* Dateien                    */
   int16_t   fcbn;                    /* Länge von fcbx[]           */
   DMD       *dmdx;                   /* Zeiger auf 16 DMDs         */
   IMB       *imbx;                   /* interne DOS- Speicherliste */
   VOID      (*resv_intmem)();        /* DOS- Speicher erweitern    */
   int32_t   (*<a href="003004.html#etv_critic">etv_critic</a>)();         /* <a href="003004.html#etv_critic">etv_critic</a> des <a href="005.html">GEMDOS</a>      */
   int8_t *  ((*err_to_str)(int8_t e)); /* Umrechnung Code->Klartext  */
} DOSVARS;
</pre>
<p>Querverweis: <a href="010009.html#AESVARS">AESVARS</a> &nbsp; <a href="003007.html#Cookie_2C_20MagX">Cookie von MagiC</a> &nbsp; <a href="00500e.html#Sconfig">Sconfig</a></p>

<h3><a name="DTA"></a>5.20.16 DTA</h3>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>typedef struct
{
    int8_t    d_reserved[21];  /* für <a href="005.html">GEMDOS</a> reserviert */
    uint8_t   d_attrib;        /* Datei-Attribut        */
    uint16_t  d_time;          /* Uhrzeit               */
    uint16_t  d_date;          /* Datum                 */
    uint32_t  d_length;        /* Dateilänge            */
    int8_t    d_fname[14];     /* Dateiname             */
} DTA;
</pre>
<p><b>rekursive Suche in Ordnern</b></p>

<p>In je einer DTA werden genau alle nötigen Informationen
gespeichert, die nach einem Fsfirst für weitere Fsnext benötigt
werden. Das heißt, daß auf keinen Fall erneut Fsfirst für andere
Verzeichnisse/Wildcards aufrufen sollte, solange noch weitere
Fsnext-Aufrufe in der Verzeichnis-Ebene gemachen werden.
<br>Bei einer rekursiven Suche mußt für jedes neue Fsfirst eine
eigene DTA verwendet werden, die solange erhalten bleiben muß, bis
alle Fsnext für den Fsfirst getätigt sind. Hier ein Bsp in
pseudo-C:</p>

<pre>void durchsuche_verzeichnis (int8_t *pfadname)
{
  DTA_Record local_dta, saved_dta;

  saved_dta = GetDTA ();
  SetDTA (local_dta);

  err = <a href="005009.html#Fsfirst">Fsfirst</a> (pfadname, ...);
  while (err == 0) {
    if (local_dta.attrib == subdir) {
      // rekursive suche in sub-dir
      durchsuche_verzeichnis (subdir-pfadname);
    } else {
      ... normales file auswerten
    }
    err = <a href="005009.html#Fsnext">Fsnext</a> ();
  }

  SetDTA (saved_dta);
}
</pre>
<p>Querverweis: <a href="005009.html#Fgetdta">Fgetdta</a> &nbsp; <a href="005009.html#Fsetdta">Fsetdta</a> &nbsp; <a href="005009.html#Fsfirst">Fsfirst</a> &nbsp; <a href="005009.html#Fsnext">Fsnext</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<h3><a name="fcookie"></a>5.20.17 fcookie</h3>
<pre>typedef struct f_cookie
{
    struct filesys *fs; /* Filesystem welches diesen Cookie kennt     */
    uint16_t dev;       /* Device-Info (z.B. <a href="About_the_BIOS.html#Rwabs">Rwabs</a> Gerätenummer)      */
    uint16_t aux;       /* weitere Daten für das Filesystem           */
    int32_t   index;    /* dient zusammen mit dev zur Identifizierung */
                        /* eines Files */
} fcookie;
</pre>
<p>Querverweis: <a href="#FILEPTR">FILEPTR</a> &nbsp; <a href="00b015.html#FILESYS">FILESYS</a> &nbsp; <a href="00b015.html">XFS-Konzept in MagiC</a></p>

<h3><a name="FILEPTR"></a>5.20.18 FILEPTR</h3>
<pre>typedef struct fileptr
{
    int16_t         links;
    uint16_t        flags;
    int32_t         pos;
    int32_t         devinfo;
    <a href="#fcookie">fcookie</a>         fc;
    struct devdrv  *dev;
    struct fileptr *next;
} FILEPTR;
</pre>
<p>Querverweis: <a href="00500f.html#Dcntl">Dcntl</a> &nbsp; <a href="00b015.html#DEVDRV">DEVDRV</a></p>

<h3><a name="flock_2C_20Fcntl"></a>5.20.19 flock, Fcntl</h3>
<pre>struct <a href="003004.html#flock">flock</a>
{
    int16_t  l_type;     /* Art des Lockings */
    int16_t  l_whence;   /* SEEK_SET, SEEK_CUR, SEEK_END */
    int32_t  l_start;    /* Start des Locking-Bereiches  */
    int32_t  l_len;      /* Länge des Locking-Bereiches  */
    int16_t  l_pid;      /* PID des sperrenden Prozesses */
};
</pre>
<p><b>Hinweis:</b> Mögliche Werte für l_type sind 0 =
Read-Locking, 1 = Write-Locking sowie 3 = kein Locking.</p>

<h3><a name="LINE"></a>5.20.20 LINE</h3>
<pre>typedef struct
{
    uint8_t   maxlen;        /* max. Zeilenlänge     */
    uint8_t   actuallen;     /* aktuelle Zeilenlänge */
    int8_t    buffer[255];   /* Zeilen-Puffer        */
} LINE;
</pre>
<p>Querverweis: <a href="005010.html#Cconrs">Cconrs</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<h3><a name="ltchars"></a>5.20.21 ltchars</h3>
<pre>struct ltchars
{
    int8_t t_suspc;
    int8_t t_dsuspc;
    int8_t t_rprntc;
    int8_t t_flushc;
    int8_t t_werasc;
    int8_t t_lnextc;
};
</pre>
<p>Querverweis: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="00b015.html">XFS-Konzept in MagiC</a></p>

<h3><a name="mutimbuf"></a>5.20.22 mutimbuf</h3>
<pre>struct mutimbuf
{
   uint16_t actime;     /* Zugriffszeit                 */
   uint16_t acdate;     /* Zugriffsdatum                */
   uint16_t modtime;    /* Uhrzeit der letzten Änderung */
   uint16_t moddate;    /* Datum der letzten Änderung   */
};
</pre>
<p>Querverweis: <a href="00500f.html#Dcntl">Dcntl</a> &nbsp; <a href="005009.html#Fcntl">Fcntl</a> &nbsp; <a href="005.html">GEMDOS</a></p>

<h3><a name="Process-Descriptor_20_28PD_29_20bzw._20BASEPAGE"></a>5.20.23 Process-Descriptor (PD) bzw. BASEPAGE</h3>
<a name="PD"></a>
<a name="BASEPAGE"></a>
<pre>typedef struct pd
{
   VOID     *p_lowtpa;      /* Anfangsadresse der TPA            */
   VOID     *p_hitpa;       /* erstes Byte nach dem Ende der TPA */
   VOID     *p_tbase;       /* Anfangsadresse des Programmcodes  */
   int32_t   p_tlen;        /* Länge des Programmcodes           */
   VOID     *p_dbase;       /* Anfangsadresse des DATA-Bereichs  */
   int32_t   p_dlen;        /* Länge des DATA-Abschnittes        */
   VOID     *p_bbase;       /* Anfangsadresse des BSS-Bereichs   */
   int32_t   p_blen;        /* Länge des BSS-Abschnittes         */
   <a href="#DTA">DTA</a>      *p_dta;         /* Zeiger auf Default-<a href="#DTA">DTA</a>.           */
                            /* Achtung: zeigt zunächst in die    */
                            /* Kommandozeile !                   */
   struct pd *p_parent;     /* Zeiger auf die Basepage des auf-  */
                            /* rufenden Prozesses                */
   int32_t   p_resrvd0;     /* reserviert                        */
   int8_t   *p_env;         /* Adresse der Environment-Strings   */
   int8_t    p_resrvd1[80]; /* reserviert                        */
   int8_t    p_cmdlin[128]; /* Kommandozeile                     */
} PD; /* auch: BASEPAGE */
</pre>
<p><b>Hinweis zur Kommandozeile:</b> Im ersten Byte wird die Anzahl
der Zeichen eingesetzt. Die maximale Länge der Kommandozeile beläuft
sich <i>nicht</i> auf 127, sondern nur auf 124 Zeichen! (Dies trift
nicht für <a href="00b.html">MagiC</a> ab Version 3 zu - siehe <a href="005011.html">ARGV-Verfahren</a>).</p>

<p>Querverweis: <a href="005.html">GEMDOS</a> &nbsp; <a href="010009.html#OSHEADER">OSHEADER</a> &nbsp; <a href="00500b.html#Pexec">Pexec</a> &nbsp; <a href="005006.html">Programmstart und TPA</a></p>

<h3><a name="ploadinfo"></a>5.20.24 ploadinfo</h3>
<pre>struct ploadinfo
{
   int16_t fnamelen;  /* Länge von 'fname'                         */
   int8_t *cmdlin;    /* Kommandozeile des Prozesses (128 Bytes)   */
   int8_t *fname;     /* vollst. Pfad- und Dateiname des Prozesses */
};
</pre>
<p>Querverweis: <a href="005009.html#Fcntl">Fcntl</a> &nbsp; <a href="005009.html#PLOADINFO">PLOADINFO</a></p>

<h3><a name="sgttyb"></a>5.20.25 sgttyb</h3>
<pre>struct sgttyb
{
    int8_t   sg_ispeed;
    int8_t   sg_ospeed;
    int8_t   sg_erase;
    int8_t   sg_kill;
    uint16_t sg_flags;
};
</pre>
<p>Querverweis: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="00b015.html">XFS-Konzept in MagiC</a></p>

<h3><a name="struct_20sigaction"></a>5.20.26 struct sigaction</h3>
<a name="sigaction"></a>
<p>Diese Struktur ist wie folgt definiert:</p>

<pre>struct sigaction
{
   void cdecl (*sa_handler)(int32_t sig);
   int32_t    sa_mask;
   int16_t    sa_flags;
};
</pre>
<p><b>Hinweis:</b> Die Komponente <i>sa_handler</i> kann dabei
verschiedene Werte annehmen. Ein Wert von 0 bedeutet eine
Default-Signal-Behandlung durch das System, bei einem Wert von 1 wird
das Signal ignoriert; jeder andere Werte wird als die Adresse einer
Signalbehandlungsroutine interpretiert, die dann aufgerufen wird.</p>

<p>Die Komponente <i>sa_mask</i> enthält die zusätzlich (zu dem
gerade in Bearbeitung befindlichen Signal) während der
Signalbehandlung zu maskierenden <a href="005007.html">Signale</a>. Es gilt dann also mask =
oldmask+(1<<sig)+sa_mask). Über <i>sa_flags</i> kann das Verhalten
eines Signals weiter beeinflußt werden. Ein Wert von 1 für
<i>sa_flags</i> bedeutet in MiNT, daß das Signal <a href="005007.html#SIGCHLD">SIGCHLD</a> nur beim
Terminieren, und nicht beim Anhalten eines Childs ausgelöst wird;
andere Werte für <i>sa_flags</i> sind z.Zt. noch nicht definiert.</p>

<p>Querverweis: <a href="005007.html">Signale</a> &nbsp; <a href="005007.html#Signalhandler_20in_20MagiC">Signalhandler in MagiC</a> &nbsp; <a href="005.html">GEMDOS</a> &nbsp;
<a href="00500b.html#Psigaction">Psigaction</a> &nbsp; <a href="00500b.html">Prozessfunktionen</a></p>

<h3><a name="tchars"></a>5.20.27 tchars</h3>
<pre>struct tchars
{
    int8_t t_intrc;
    int8_t t_quitc;
    int8_t t_startc;
    int8_t t_stopc;
    int8_t t_eofc;
    int8_t t_brkc;
};
</pre>
<p>Querverweis: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="00b015.html">XFS-Konzept in MagiC</a></p>

<h3><a name="timeval"></a>5.20.28 timeval</h3>
<pre>struct timeval
{
  int32_t int tv_sec;
  int32_t int tv_usec;
};
</pre>
<p>tv_sec enthält die Anzahl Sekunden, die seit dem Ursprung
vergangen sind. Der Ursprung ist Donnerstag, 1.Januar 1970, 00:00:00
UTC.</p>

<p>tv_usec enthält den Nachkommaanteil von tv_sec in Mikrosekunden.</p>

<h3><a name="timezone"></a>5.20.29 timezone</h3>
<pre>struct timezone
{
  int32_t int tz_minuteswest;
  int32_t int tz_dsttime;
};
</pre>
<p>tz_minuteswest enthält den Offset zur UTC in Sekunden. Zeitzonen
östlich den Null-Meridians (z.B. Osteuropa) haben einen negativen
Offset, Zeitzonen westlich des Null-Meridians (z.B. Amerika) haben
einen positiven.</p>

<p>tz_dsttime ist ungleich Null, wenn innerhalb des Jahr auf
Sommerzeit umgestellt wird.</p>

<h3><a name="struct_20tty"></a>5.20.30 struct tty</h3>
<pre>struct tty
{
    int16_t         pgrp;
    int16_t         state;
    int16_t         use_cnt;
    int16_t         res1;
    struct <a href="#sgttyb">sgttyb</a>   sg;
    struct <a href="#tchars">tchars</a>   tc;
    struct <a href="#ltchars">ltchars</a>  ltc;
    struct <a href="#winsize">winsize</a>  wsiz;
    int32_t         rsel;
    int32_t         wsel;
    int8_t          *<a href="#xkey">xkey</a>;
    int32_t         hup_ospeed;
    uint16_t        vmin, vtime;
    int32_t         resrvd[1];
};
</pre>
<p>Querverweis: <a href="00500f.html#Dcntl">Dcntl</a> &nbsp; <a href="00b015.html#dev_descr">dev_descr</a> &nbsp; <a href="00b015.html">XFS-Konzept in MagiC</a></p>

<h3><a name="winsize"></a>5.20.31 winsize</h3>
<pre>struct winsize
{
    int16_t  ws_row;
    int16_t  ws_col;
    int16_t  ws_xpixel;
    int16_t  ws_ypixel;
};
</pre>
<p>Querverweise: <a href="005009.html#Fcntl">Fcntl</a> &nbsp; <a href="005009.html#TIOCGWINSZ">TIOCGWINSZ</a></p>

<h3><a name="XATTR"></a>5.20.32 XATTR</h3>
<pre>typedef struct xattr
{
   uint16_t   mode;              /* Dateimodus, Angaben zu     */
                                 /* - möglichen Filetypen      */
                                 /* - speziellen Bits          */
                                 /* - Zugriffsrechten          */
   int32_t    index;             /* Dateinummer                */
   uint16_t   dev;               /* Gerätenummer               */
   uint16_t   rdev;              /* tatsächliches Gerät        */
                                 /* (z.B. bei <a href="003.html">BIOS</a>-Files)      */
                                 /* in <a href="00b.html">MagiC</a> jedoch reserviert */
   uint16_t   nlink;             /* Anzahl der Links           */
   uint16_t   uid;               /* Benutzernummer             */
   uint16_t   gid;               /* Gruppennummer              */
   int32_t    size;              /* Dateilänge                 */
   int32_t    blksize, nblocks;  /* Blockgröße/belegte Blocks  */
   uint16_t   mtime, mdate;      /* Datum der letzten Änderung */
   uint16_t   atime, adate;      /* Datum des letzten Zugriffs */
   uint16_t   ctime, cdate;      /* Erstellungsdatum           */
   uint16_t   attr;              /* <a href="002.html">TOS</a>-Dateiattribute         */
   uint16_t   reserved2;         /* reserviert                 */
   int32_t    reserved3[2];      /* reserviert                 */
} XATTR;
</pre>
<p><b>Hinweis:</b> <a href="00b.html">MagiC</a> liefert für FAT-Dateisysteme folgende
<a href="indexudo.html">Index</a>-Daten:</p>

<table>
<tr><td nowrap="nowrap" valign="top">• Verzeichnisse:</td>
<td valign="top">Startcluster im Motorola-Format</td></tr>

<tr><td nowrap="nowrap" valign="top">• sonstige Dateien:</td>
<td valign="top"><table>
<tr><td nowrap="nowrap" valign="top">Hiword =</td>
<td valign="top">Startcluster des Verzeichnisses</td></tr>

<tr><td nowrap="nowrap" valign="top">Loword =</td>
<td valign="top">Position innerhalb des Verzeichnisses >> 5
</td></tr>
</table>


</td></tr>
</table>

<p>Dieses Verfahren ist ähnlich wie das, welches Linux und Solaris
verwenden. Nachteil ist, daß Dateien beim Verschieben ihren <a href="indexudo.html">Index</a>
ändern.</p>

<p>Die Komponente <i>index</i> ist also ein Langwort zur eindeutigen
Identifizierung einer Datei bzw. eines Ordners. Der <a href="indexudo.html">Index</a> muß
innerhalb eines Dateisystems eindeutig sein; zusammen mit dem
folgenden Feld (<i>dev</i>) ist damit eine Datei oder ein Ordner
systemglobal vollständig festgelegt.</p>

<p>Unter UNIX-ähnlichen Dateisystemen ist <i>index</i> die Nummer
des Inode.</p>

<p>Auf Macintosh-Partitionen wird die hard file ID bzw. die hard dir
ID verwendet, die vom MacOS zur Verfügung gestellt wird. Das MacOS
verwendet als Standard-Deskriptoren aber das FSSpec. Für
Verzeichnisse, d.h. für Directory IDs, gibt es Funktionen des MacOS,
um einen FSSpec zu berechnen. Leider lassen sich die hard file IDs
für normale Dateien (d.h. nicht Unterverzeichnisse) <i>nicht</i>
weiter verwenden, da sie von keiner Funktion des MacOS verarbeitet
werden.</p>

<p>Querverweis: <a href="00b015.html">XFS-Konzept in MagiC</a> &nbsp; <a href="005009.html#Fxattr">Fxattr</a> &nbsp; <a href="00500f.html#Dxreaddir">Dxreaddir</a></p>

<h4><a name="XATTR_2C_20dev-Komponente"></a>5.20.32.1 XATTR, dev-Komponente</h4>
<p>Legt das Dateisystem fest. Auf dem Atari sind 0..25 die
<a href="003.html">BIOS</a>-Laufwerke A: bis Z:, Laufwerk U: oder andere Dateisysteme
verwenden höhere Nummern. Auf dem Macintosh wird die 'volume ID'
eingesetzt, die vom MacOS vergeben wird.</p>

<h5><a name="XATTR_2C_20m_C3_B6gliche_20Filetypen"></a>5.20.32.1.1 XATTR, mögliche Filetypen</h5>
<a name="m_C3_B6gliche_20Filetypen"></a>
<p><b>Mögliche Filetypen, die über die <a href="#XATTR">XATTR</a>-Struktur gesetzt bzw.
ermittelt werden können:</b></p>

<pre>#define S_IFMT  0170000  /* zur Isolierung des Filetyps */
#define S_IFCHR 0020000  /* spezielles <a href="003.html">BIOS</a>-File        */
#define S_IFDIR 0040000  /* Verzeichnis                 */
#define S_IFREG 0100000  /* normale Datei               */
#define S_IFIFO 0120000  /* FIFO (Pipe mit Namen)       */
#define S_IMEM  0140000  /* Speicherblock/Prozeבƒfile    */
#define S_IFLNK 0160000  /* symbolischer Link           */
</pre>
<h5><a name="Sticky-Bit"></a>5.20.32.1.2 Sticky-Bit</h5>
<p><b>Spezielle Bits, die über die <a href="#XATTR">XATTR</a>-STruktur gesetzt bzw.
ermittelt werden können:</b></p>

<pre>#define S_ISUID 04000  /* User-ID des Eigentב¶mers setzen */
#define S_ISGID 02000  /* Gruppen-ID bei Aufruf setzen   */
#define S_ISVTX 01000  /* Sticky bit                     */
</pre>
<p><b>Hinweis:</b> Die Bedeutung des <i>Sticky-Bits</i> ist dabei
vom Filetyp abhängig.</p>

<h5><a name="XATTR_2C_20size-Komponente"></a>5.20.32.1.3 XATTR, size-Komponente</h5>
<p>Auf <b>DOS-Partitionen</b> wird für Ordner der Wert 0 als Länge
geliefert. Die tatsächliche Länge kann leider aufgrund der
Einschränkungen von MSDOS nicht ermittelt werden. Die Länge des
Wurzelverzeichnisses kann allerdings ermittelt werden.</p>

<p>Auf <b>Macintosh-Partitionen</b> haben Ordner immer die Länge 0,
die tatsächliche Länge läßt sich (zumindest unter System 7) nicht
ermitteln.</p>

<h5><a name="XATTR_2C_20spezielle_20Bits"></a>5.20.32.1.4 XATTR, spezielle Bits</h5>
<p><b>Spezielle Bits, die über die <a href="#XATTR">XATTR</a>-STruktur gesetzt bzw.
ermittelt werden können:</b></p>

<pre>#define S_ISUID 04000  /* User-ID des Eigentב¶mers setzen */
#define S_ISGID 02000  /* Gruppen-ID bei Aufruf setzen   */
#define S_ISVTX 01000  /* Sticky bit                     */
</pre>
<p><b>Hinweis:</b> Die Bedeutung des <i>Sticky-Bits</i> ist dabei
vom Filetyp abhängig.</p>

<h5><a name="XATTR_2C_20Zugriffsrechte"></a>5.20.32.1.5 XATTR, Zugriffsrechte</h5>
<p><b>Mögliche Zugriffsrechte, die über die <a href="#XATTR">XATTR</a>-Struktur gesetzt
bzw. ermittelt werden können:</b></p>

<pre>#define S_IRUSR 0400   /* Eigentב¶mer darf Datei lesen    */
#define S_IWUSR 0200   /* dto. darf beschreiben          */
#define S_IXUSR 0100   /* dto. darf ausfב¶hren            */
#define S_IRGRP 0040   /* Gruppenmitglieder dב¶rfen lesen */
#define S_IWGRP 0020   /* dto. dב¶rfen beschreiben        */
#define S_IXGRP 0010   /* dto. dב¶rfen ausfב¶hren          */
#define S_IROTH 0004   /* Andere dב¶rfen Datei lesen      */
#define S_IWOTH 0002   /* dto. dב¶rfen beschreiben        */
#define S_IXOTH 0001   /* dto. dב¶rfen ausfב¶hren          */
</pre>
<h4><a name="xkey"></a>5.20.32.2 xkey</h4>
<pre>struct xkey
{
    int16_t   xk_num;
    int8_t    xk_def[8];
};
</pre>
<p>Querverweise: <a href="005009.html#Fcntl">Fcntl</a> &nbsp; <a href="005009.html#TIOCGXKEY">TIOCGXKEY</a></p>

<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="005.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="005013.html"><img src="udo_lf.gif" alt="GEMDOS-Funktionsliste" title="GEMDOS-Funktionsliste" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="006.html"><img src="udo_rg.gif" alt="Line-A" title="Line-A" border="0" width="24" height="24"></a></body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Bildschirmfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO 7.04 (1296) for Linux">
</head>
<body>
<? include "/var/www/banner.php"; ?>

<a id="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_HEAD" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_HEAD" href="004004.html"><img src="udo_lf.gif" alt="xbios-Trap" title="xbios-Trap" border="0" width="24" height="24"></a><a id="UDO_nav_rg_HEAD" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen-XBIOS-Erweiterung" title="CENTScreen-XBIOS-Erweiterung" border="0" width="24" height="24"></a>
<hr>

<h1><a name="Bildschirmfunktionen"></a>4.5 Bildschirmfunktionen</h1>
<table>
<tr><td nowrap="nowrap" valign="top">• <a href="#Cursconf">Cursconf</a></td>
<td valign="top">Cursordarstellung ändern oder ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EgetPalette">EgetPalette</a></td>
<td valign="top">Farbtabelle lesen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EgetShift">EgetShift</a></td>
<td valign="top">Shift Mode Register lesen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetBank">EsetBank</a></td>
<td valign="top">Farbtabelle setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetColor">EsetColor</a></td>
<td valign="top">Farbtabelleneintrag setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetGray">EsetGray</a></td>
<td valign="top">Farbinterpretation setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetPalette">EsetPalette</a></td>
<td valign="top">Farbtabelle laden.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetShift">EsetShift</a></td>
<td valign="top">Shift Mode Register setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#EsetSmear">EsetSmear</a></td>
<td valign="top">Farbverwischung setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Getrez">Getrez</a></td>
<td valign="top">Auflösung ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Initmouse">Initmouse</a></td>
<td valign="top">Mauszeiger initialisieren.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Logbase">Logbase</a></td>
<td valign="top">Adresse des logischen Bildschirmspeichers ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#mon_type">mon_type</a></td>
<td valign="top">Monitortyp ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Physbase">Physbase</a></td>
<td valign="top">Adresse des physikal. Bildschirmspeichers ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Setcolor">Setcolor</a></td>
<td valign="top">Farbe einstellen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Setpalette">Setpalette</a></td>
<td valign="top">Farbpalette auswählen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Setscreen">Setscreen</a></td>
<td valign="top">Festlegen der Bildschirmauflösung und -adressen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VgetRGB">VgetRGB</a></td>
<td valign="top">RGB-Wert einer Farbe ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VSetscreen">VSetscreen</a></td>
<td valign="top">Festlegen der Bildschirmauflösung und -adressen</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VgetSize">VgetSize</a></td>
<td valign="top">Größe des Bildschirmpuffers ermitteln.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VsetMask">VsetMask</a></td>
<td valign="top">Transparenz für True-Color setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Vsetmode">Vsetmode</a></td>
<td valign="top">Videohardwareregister setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VsetRGB">VsetRGB</a></td>
<td valign="top">RGB-Wert einer Farbe setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#VsetSync">VsetSync</a></td>
<td valign="top">Synchronisationsart setzen.</td></tr>

<tr><td nowrap="nowrap" valign="top">• <a href="#Vsync">Vsync</a></td>
<td valign="top">Vertikales Synchronisationssignal abfragen.

</td></tr>
</table>

<h3><a name="Cursconf"></a>4.5.1 Cursconf</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»cursor configuration« - legt die Arbeitsweise des Cursors
fest.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">21</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Cursconf( int16_t func, int16_t rate );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Routine Cursconf verändert das Aussehen und
wahlweise die Blinkgeschwindigkeit des Cursors. Der Parameter
<i>func</i> kann folgende Werte annehmen:<table>
<tr><td nowrap="nowrap" valign="top">func</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top">Cursor abschalten</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top">Cursor einschalten</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;2</td>
<td valign="top">Cursor blinkt</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;3</td>
<td valign="top">Cursor blinkt nicht</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4</td>
<td valign="top">Die Blinkgeschwindigkeit des Cursors wird auf den Wert
<i>rate</i> gesetzt.</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;5</td>
<td valign="top">Liefert die aktuelle Blinkfrequenz

</td></tr>
</table>

<br><br>

<b>Hinweis:</b> Der Parameter <i>rate</i> soll in Schritten der
Wiederholfrequenz des Bildschirms verwendet werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert nur dann ein definiertes Ergebnis,
nämlich die Blinkfrequenz, wenn im Parameter <i>func</i> die Zahl 5
übergeben wurde.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Cursconf">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Cursconf"></a>4.5.1.1 Bindings für Cursconf</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Cursconf">Cursconf</a>( int16_t func, int16_t rate );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    rate,-(sp)   ; Offset 4
move.w    func,-(sp)   ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EgetPalette"></a>4.5.2 EgetPalette</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Get look up table registers« - Liest mehrere Einträge aus
der Farbtabelle.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">85</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void EgetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EgetPalette liest einen zusammenhängenden
Bereich aus den TT-Farbregistern aus.<table>
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top">Bedeutung</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top">&nbsp;</td></tr>

<tr><td nowrap="nowrap" valign="top">colorNum</td>
<td valign="top">erstes auszulesendes Farbregister</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top">Anzahl der auszulesenden Farbregister</td></tr>

<tr><td nowrap="nowrap" valign="top">palettePtr</td>
<td valign="top">Zeiger auf zu übertragende Farbpalette (dieser muß gerade
sein).

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EgetPalette">Binding</a> &nbsp; <a href="#EsetPalette">EsetPalette</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EgetPalette"></a>4.5.2.1 Bindings für EgetPalette</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#EgetPalette">EgetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #85,-(sp)       ; Offset 0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp       ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EgetShift"></a>4.5.3 EgetShift</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Get current shift mode value« - Liest das Shift Mode
Register.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">81</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EgetShift( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EgetShift liest das Shift Mode Register aus
und liefert den Inhalt des Registers als Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den Wert des Registers gemäß folgender
Belegung:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Nummer der Farbregister-Bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Modus, gemäß <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-Mono  (vgl. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear-Modus (vgl. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EgetShift">Binding</a> &nbsp; <a href="#EsetShift">EsetShift</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EgetShift"></a>4.5.3.1 Bindings für EgetShift</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EgetShift">EgetShift</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #81,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetBank"></a>4.5.4 EsetBank</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set color look up bank« - Setzt Bank für Farbtabelle.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">82</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EsetBank( int16_t bankNum );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EsetBank setzt die Banknummer für die
Farbtabelle des TT auf den Wert <i>bankNum</i>. Der erlaubte Wert von
bankNum liegt zwischen 0 und 15. Ist <i>bankNum</i> negativ, wird die
aktuelle Einstellung nicht verändert.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die vorherige Einstellung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetBank">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetBank"></a>4.5.4.1 Bindings für EsetBank</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EsetBank">EsetBank</a>( int16_t bankNum );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    bankNum,-(sp)  ; Offset 2
move.w    #82,-(sp)      ; Offset 0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp          ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetColor"></a>4.5.5 EsetColor</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set color entry« - Schreibt einen Eintrag in die
Farbtabelle.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">83</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EsetColor( int16_t colorNum, int16_t color );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EsetColor setzt den Farbeintrag
<i>colorNum</i> (0..255) in der Farbtabelle auf den Wert
<i>color</i>; ein negativer Wert verändert den Eintag nicht.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die vorherige Einstellung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetColor">Binding</a> &nbsp; <a href="#Setcolor">Setcolor</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetColor"></a>4.5.5.1 Bindings für EsetColor</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EsetColor">EsetColor</a>( int16_t colorNum, int16_t color );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    color,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #83,-(sp)       ; Offset 0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp           ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetGray"></a>4.5.6 EsetGray</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set/clear gray mode« - Schaltet die Farbinterpretation ein
bzw. aus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">86</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EsetGray( int16_t switch );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EsetGray schaltet die Farbinterpretation in
der Farbtabelle als Graustufe ein (1) bzw. aus (0). Ein negativer Wert
verändert die Einstellung nicht.<br><br>

Im Graustufen-Modus kann anstelle von 4096 Farbtönen aus einer
Palette von 256 Graustufen gewählt werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die bisherige Einstellung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung (when
the high word of the '_VDO' cookie has the value of 2).</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetGray">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetGray"></a>4.5.6.1 Bindings für EsetGray</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EsetGray">EsetGray</a>( int16_t switch );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    switch,-(sp) ; Offset 2
move.w    #86,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetPalette"></a>4.5.7 EsetPalette</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set palette registers« - Setzt mehrere Einträge in der
Farbtabelle.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">84</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void EsetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine EsetPalette setzt <i>count</i> Farbeinträge
ab <i>colorNum</i> in der Farbtabelle auf die Werte im Array
<i>palettePtr</i>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion hat kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im <a href="002.html">TOS</a> des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetPalette">Binding</a> &nbsp; <a href="#EgetPalette">EgetPalette</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetPalette"></a>4.5.7.1 Bindings für EsetPalette</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#EsetPalette">EsetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #84,-(sp)       ; Offset 0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp       ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetShift"></a>4.5.8 EsetShift</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set shift mode register« - Setzt das Shift Mode Register.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">80</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EsetShift( int16_t shftMode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Routine EsetShift schreibt in das Shift Mode
Register des TT den Wert <i>shftMode</i>. shftMode ist ein Bitfeld
mit folgender Bedeutung:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Nummer der Farbregister-Bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Modus, gemäß <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-Mono  (vgl. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear-Modus (vgl. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den vorherigen Wert des Registers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im TOS des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetShift">Binding</a> &nbsp; <a href="#EgetShift">EgetShift</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetShift"></a>4.5.8.1 Bindings für EsetShift</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EsetShift">EsetShift</a>( int16_t shftMode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    shftMode,-(sp)  ; Offset 2
move.w    #80,-(sp)       ; Offset 0
trap      #14             ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp           ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="EsetSmear"></a>4.5.9 EsetSmear</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Set/clear video smear mode« - Schaltet die Farbverwischung
ein bzw. aus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">87</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t EsetSmear( int16_t switch );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Routine EsetSmear erlaubt die Umschaltung des
Smear-Modus des TT-Videobausteins. Im Smear-Modus wird anstelle der
Hintergrundfarbe (Farbe 0) die jeweils zuletzt dargestellte Farbe
gezeichnet. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">switch</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top"><0</td>
  <td align="left" valign="top">bisherigen Wert abfragen</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Smear-Modus aus</td>
</tr>
<tr>
  <td align="center" valign="top">>0</td>
  <td align="left" valign="top">Smear-Modus ein</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die bisherige Einstellung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion steht nur im TOS des Atari-TT zur Verfügung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20EsetSmear">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetSmear"></a>4.5.9.1 Bindings für EsetSmear</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#EsetSmear">EsetSmear</a>( int16_t switch );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    switch,-(sp)  ; Offset 2
move.w    #87,-(sp)     ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Getrez"></a>4.5.10 Getrez</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»get resolution« - ermittelt die Auflösung des Bildschirms.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">4</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Getrez( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Getrez ermittelt die Auflösung des
Bildschirms.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis folgende Werte:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">Werte</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">&nbsp;320*200 (vier Planes)</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">&nbsp;640*200 (zwei Planes)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">&nbsp;640*400 (ein Plane)</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">&nbsp;640*480 (vier Planes, nur TT)</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">1280*960 (ein Plane,   nur TT)</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">&nbsp;320*480 (acht Planes, nur TT)</td>
</tr>
</table>
</div>

<br><br>

Alle anderen Werte sind für zukünftige Erweiterungen reserviert.<br><br>

<b>Hinweis:</b> Vom Standpunkt der sauberen Programmierung
betrachtet, <i>sollte diese Funktion auf keinen Fall benutzt
werden</i>. Insbesondere beim Einsatz von Grafikkarten hat sie
praktisch keinen Aussagewert. Stattdessen sollte die Auflösung des
Bildschirms über das <a href="About_the_VDI.html">VDI</a> (<a href="00700a.html#v_opnvwk">v_opnvwk</a>) ermittelt werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Getrez">Binding</a> &nbsp; <a href="00700a.html#v_opnvwk">v_opnvwk</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Getrez"></a>4.5.10.1 Bindings für Getrez</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <portab.h>
<br>#include <tos.h><br><br>

int16_t <a href="#Getrez">Getrez</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #4,-(sp)     ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Initmouse"></a>4.5.11 Initmouse</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»initialize mouse« - initialisiert die Maus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">0</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Initmouse( int16_t type, <a href="004015.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Initmouse ist eine XBIOS-Routine zur
Low-Level-Initialisierung der Maus. Der Parameter <i>type</i> legt
die Betriebsart der Maus fest. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">type</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Maus abschalten</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Maus einschalten, Relativ-Modus</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Maus einschalten, Absolut-Modus</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">reserviert</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Maus einschalten, Tastaturemulation</td>
</tr>
</table>
</div>

<br><br>

Die Bytes von 4 bis 11 des Parameters <i>par</i> werden nur dann
verwendet, wenn die Maus im Absolut-Modus arbeiten soll. Unter
<i>mousevec</i> erhält man die Adresse des Interrupt-Vektors der
Maus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Initmouse">Binding</a> &nbsp; <a href="004015.html#MOUSE">MOUSE</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Initmouse"></a>4.5.11.1 Bindings für Initmouse</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Initmouse">Initmouse</a>( int16_t type, <a href="004015.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       mousevec     ; Offset 8
pea       par          ; Offset 4
move.w    type,-(sp)   ; Offset 2
move.w    #0,-(sp)     ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       12(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Logbase"></a>4.5.12 Logbase</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»logical screen RAM base« - ermittelt die logische
Anfangsadresse des Videospeichers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">3</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void *Logbase( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Routine Logbase ermittelt die logische
Anfangsadresse des momentan als Videospeicher verwendeten
RAM-Bereichs.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert als Ergebnis die Anfangsadresse des
logischen Bildschirmspeichers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Logbase">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Logbase"></a>4.5.12.1 Bindings für Logbase</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void *<a href="#Logbase">Logbase</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #3,-(sp)     ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="mon_type"></a>4.5.13 mon_type</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»mon_type« - Typ des Monitors ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">89</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t mon_type( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion mon_type ermittelt den angeschlossenen
Monitortyp anhand von Pin 18(M1) und 19(M0) des Video-Ports. Ein 0-Bit
bedeutet Masse am entsprechenden Pin, 1-Bit bedeutet keine Verbindung.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den angeschlossenen Monitortyp zurück.
Dabei gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">Wert</td>
  <td align="left" valign="top">Bedeutung</td>
  <td align="left" valign="top">Pin</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">ST-Monochrommonitor</td>
  <td align="left" valign="top">M1:0 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">ST-Farbmonitor</td>
  <td align="left" valign="top">M1:0 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">VGA-Monitor</td>
  <td align="left" valign="top">M1:1 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">TV-Gerät</td>
  <td align="left" valign="top">M1:1 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">LCD</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">DVI</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
</table>
</div>

<br><br>

Die Werte vier und fünf sind nur verfügbar mit dem ct60 und
Radeon Treiber.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20mon_type">Binding</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20mon_type"></a>4.5.13.1 Bindings für mon_type</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#mon_type">mon_type</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #89,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Physbase"></a>4.5.14 Physbase</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»physical screen ram base« - ermittelt die Anfangsadresse des
Video-Speichers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">2</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void *Physbase( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Physbase ermittelt die physikalische
Anfangsadresse des momentan als Videospeicher verwendeten
RAM-Bereichs.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion Physbase liefert als Ergebnis die Adresse des
physikalischen Bildschirmspeichers.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Physbase">Binding</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Physbase"></a>4.5.14.1 Bindings für Physbase</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void *<a href="#Physbase">Physbase</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #2,-(sp)     ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Setcolor"></a>4.5.15 Setcolor</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Setcolor« - legt eine von 16 Farben fest.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">7</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Setcolor( int16_t colornum, int16_t color );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Setcolor erfragt den Wert eines Farbregisters
bzw. setzt dieses auf einen neuen Wert. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">colornum</td>
  <td align="left" valign="top">neuer Farbwert (-1 = nicht ändern)</td>
</tr>
<tr>
  <td align="left" valign="top">color</td>
  <td align="left" valign="top">Nummer des Farbregisters (0..15)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den bisherigen Wert des Farbregisters.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Setcolor">Binding</a> &nbsp; <a href="#Setpalette">Setpalette</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setcolor"></a>4.5.15.1 Bindings für Setcolor</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Setcolor">Setcolor</a>( int16_t colornum, int16_t color );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    color,-(sp)    ; Offset 4
move.w    colornum,-(sp) ; Offset 2
move.w    #7,-(sp)       ; Offset 0
trap      #14            ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp          ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Setpalette"></a>4.5.16 Setpalette</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set palette« - wählt 16 Farben aus.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">6</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Setpalette( void *pallptr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Setpalette erlaubt es, eine neue Farbpalette
an die Videohardware zu übergeben.<br><br>

Der Parameter <i>pallptr</i> zeigt auf eine Tabelle von sechzehn
16-Bit Worten, die die neue Palette enthalten. Die untersten 12-Bits
werden dabei für die RGB-Werte benutzt. <i>pallptr</i> muß auf eine
gerade Adresse zeigen.<br><br>

Da die Daten von der Funktion nicht sofort verarbeitet werden,
muß dafür gesorgt werden, daß der Zeiger <i>pallptr</i> selbst im
nächsten Vertical Blank noch auf etwas sinnvolles zeigt.<br><br>

<b>Hinweis:</b> Es sollte besser auf die entsprechenden
Funktionen des VDI zurückgegriffen werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert keinen Wert.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Setpalette">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setpalette"></a>4.5.16.1 Bindings für Setpalette</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Setpalette">Setpalette</a>( void *pallptr );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>pea       pallptr      ; Offset 2
move.w    #6,-(sp)     ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Setscreen"></a>4.5.17 Setscreen</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set screen« - initialisiert den Bildschirm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">5</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Setscreen( void *laddr, void *paddr, int16_t rez );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine Setscreen dient dazu, Auflösung und
Bildschirmspeicheradressen zu verändern. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Adresse des log. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Adresse des phys. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST-Niedrig</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST-Mittel</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST-Hoch</td>
</tr>
</table>
</div>

<br><br>

Ein Wert von -1 bedeutet in diesem Zusammenhang, daß die
entsprechende Adresse bzw. Auflösung nicht verändert wird.<br><br>

<b>Hinweis:</b> Es sollte stets kontrolliert werden, ob
eventuelle Veränderungen wirklich erfolgreich ausgeführt werden
konnten. Bei einer Änderung der Auflösung wird automatisch der
<a href="003007.html#VT-52-Terminal">VT-52 Emulator</a> initialisiert.<br><br>

Unter bestimmten Umständen gibt es eine erweiterte Version dieser
Funktion (<a href="#VSetscreen">VSetscreen</a>).</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Setscreen">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Getrez">Getrez</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setscreen"></a>4.5.17.1 Bindings für Setscreen</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Setscreen">Setscreen</a>( void *laddr, void *paddr, int16_t rez );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $C(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Setscreen_2C_20Milan"></a>4.5.18 Setscreen, Milan</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set screen« - initialisiert den Bildschirm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">5</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Diese XBIOS-Routine entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern.<a name="MI_MAGIC"></a>
<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">immer 0x4D49 (MI_MAGIC)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Kommando</td>
</tr>
</table>
</div>

<br><br>

Folgende Werte sind für <i>command</i> definiert:<table>
<a name="CMD_GETMODE"></a>
<tr><td nowrap="nowrap" valign="top">CMD_GETMODE (0)</td>
<td valign="top">Getting current mode<br><br>

int32_t mode;
<br>Setscreen(-1,&mode,MI_MAGIC,CMD_GETMODE);<a name="CMD_SETMODE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_SETMODE (1)</td>
<td valign="top">Set new graphic mode<br><br>

int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1,mode,MI_MAGIC,CMD_SETMODE)<br><br>

<a href="003.html">BIOS</a> and <a href="007.html">VDI</a> will be initialised. Not the <a href="008.html">AES</a>.<a name="CMD_GETINFO"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_GETINFO (2)</td>
<td valign="top">Get screen info structure for mode<pre><a href="004015.html#SCREENINFO">SCREENINFO</a> si;
si.size = sizeof(<a href="004015.html#SCREENINFO">SCREENINFO</a>); /* Structure size has to be set         */
si.devID =0x1022;             /* ID of the mode or 0 for current mode */
si.scrFlags=0;                /* status of the operation              */
<a href="#Setscreen">Setscreen</a>(-1,&si,MI_MAGIC,CMD_GETINFO);
if(si.scrFlags & <a href="004015.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts("OK");
else
  puts("Error");
</pre>
<a name="CMD_ALLOCPAGE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_ALLOCPAGE (3)</td>
<td valign="top">Allocate 2nd screenpage<pre>int32_t adr=0;          /* Frame address or -1 */
<a href="#Setscreen">Setscreen</a>(-1,mode,MI_MAGIC,CMD_ALLOCPAGE);
if(adr)
  puts("OK");
else
  puts("Error");
</pre>
<br><br>

This only allocates one page. A further call will only return the
frame address.<a name="CMD_FREEPAGE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_FREEPAGE (4)</td>
<td valign="top">Release 2nd screenpage<br><br>

Setscreen(-1,-1,MI_MAGIC,CMD_FREEPAGE)<br><br>

The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.<a name="CMD_FLIPPAGE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_FLIPPAGE (5)</td>
<td valign="top">Switch to 2nd screenpage<br><br>

Setscreen(-1,-1,MI_MAGIC,CMD_FLIPPAGE)<br><br>

Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will be
set.<a name="CMD_ALLOCMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_ALLOCMEM (6)</td>
<td valign="top">Allocate memory on the graphics card<pre><a href="004015.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="004015.html#SCRMEMBLK">SCRMEMBLK</a>);
blk.blk_y=200;     /* alloc a block of 200 lines*/

<a href="#Setscreen">Setscreen</a>(-1,&blk,MI_MAGIC,CMD_ALLOCMEM);
if(blk.blk_start)
  puts("OK");
else
  puts("Out of memory");
</pre>
<br><br>

The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.<a name="CMD_FREEMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_FREEMEM (7)</td>
<td valign="top">Release graphics card memory<br><br>

Setscreen(-1,&blk,MI_MAGIC,CMD_FREEMEM)
<br>blk of the block to be released.<a name="CMD_SETADR"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_SETADR (8)</td>
<td valign="top">Set screen to fixed address<pre>int32_t logbase=blk.blk_start;   /* logical address or -1  */
int32_t physbase=blk.blk_start;  /* physical address or -1 */

<a href="#Setscreen">Setscreen</a>(logbase,physbase,MI_MAGIC,CMD_SETADR);
</pre>
<a name="CMD_ENUMMODES"></a>
<a name="ENUMMODE_EXIT"></a>
<a name="ENUMMODE_CONT"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_ENUMMODES (9)</td>
<td valign="top">Requests all available modes, since 13.01.2000<pre>int32_t cdecl enumfunc(<a href="004015.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf("%s\n",inf->name);
  return ENUMMODE_CONT;
}

<a href="#Setscreen">Setscreen</a>(-1,&enumfunc,MI_MAGIC,CMD_ENUMMODES);
</pre>
<br><br>

The function "enumfunc" will be called once for every available
mode. ENUMMODE_EXIT (0) will cancel CMD_ENUMMODES. ENUMMODE_CONT (1)
will continue. The parameters are handed over to the stack using the C
standard.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"><a href="VT_52_terminal.html#Return">Return</a> value undefined.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist ab dem MilanTOS 4.08 verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VSetscreen">VSetscreen</a> &nbsp; <a href="#Setscreen_2C_20ct60">Setscreen, ct60</a>

</td></tr>
</table>

<h3><a name="Setscreen_2C_20ct60"></a>4.5.19 Setscreen, ct60</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set screen« - initialisiert den Bildschirm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">5</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Diese XBIOS-Routine entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern.<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">immer 0x564E ('VN' für Vsetscreen New)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Kommando</td>
</tr>
</table>
</div>

<br><br>

Folgende Werte sind für <i>command</i> definiert:<table>
<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a> (0)</td>
<td valign="top">Getting current mode<br><br>

int32_t mode;
<br>Setscreen(-1,&mode,0x564E,<a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a>); This function is identical
to <a href="#Vsetmode">Vsetmode</a>(-1);</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a> (1)</td>
<td valign="top">Set new graphic mode<br><br>

int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1,mode,0x564E,<a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a>)<br><br>

This function is identical to Vsetscreen(0,0,3,modecode);
<br><a href="003.html">BIOS</a> and <a href="007.html">VDI</a> will be initialised. Not the <a href="008.html">AES</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a> (2)</td>
<td valign="top">Get screen info structure for mode<pre><a href="004015.html#SCREENINFO">SCREENINFO</a> si;
si.size = sizeof(<a href="004015.html#SCREENINFO">SCREENINFO</a>); /* Structure size has to be set         */
si.devID =0x1022;             /* ID of the mode or 0 for current mode */
si.scrFlags=0;                /* status of the operation              */
<a href="#Setscreen">Setscreen</a>(-1,&si,0x564E,<a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a>);
if(si.scrFlags & <a href="004015.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts("OK");
else
  puts("Error");
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a> (3)</td>
<td valign="top">Allocate screenpage<pre>int32_t adr=0;          /* Frame address or -1 */
<a href="#Setscreen">Setscreen</a>(-1,mode,0x564E,<a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a>);
if(adr)
  puts("OK");
else
  puts("Error");
</pre>
<br><br>

This only allocates one page. A further call will only return the
frame address.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a> (4)</td>
<td valign="top">Release screenpage<br><br>

Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a>)<br><br>

The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a> (5)</td>
<td valign="top">Switch to screenpage<br><br>

Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a>)<br><br>

Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will be
set.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a> (6)</td>
<td valign="top">Allocate memory on the graphics card<pre><a href="004015.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="004015.html#SCRMEMBLK">SCRMEMBLK</a>);
blk.blk_y=200;     /* alloc a block of 200 lines*/

<a href="#Setscreen">Setscreen</a>(-1,&blk,0x564E,<a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a>);
if(blk.blk_start)
  puts("OK");
else
  puts("Out of memory");
</pre>
<br><br>

The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a> (7)</td>
<td valign="top">Release graphics card memory<br><br>

Setscreen(-1,&blk,0x564E,<a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a>)
<br>blk of the block to be released.</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a> (8)</td>
<td valign="top">Set screen to fixed address<pre>int32_t logbase=blk.blk_start;   /* logical address or -1  */
int32_t physbase=blk.blk_start;  /* physical address or -1 */

<a href="#Setscreen">Setscreen</a>(logbase,physbase,0x564E,<a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a>);
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a> (9)</td>
<td valign="top">Requests all available modes<pre>int32_t cdecl enumfunc(<a href="004015.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf("%s\n",inf->name);
  return <a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a>;
}

<a href="#Setscreen">Setscreen</a>(-1,&enumfunc,0x564E,<a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>);
</pre>
<br><br>

The function "enumfunc" will be called once for every available
mode. <a href="Screen_functions.html#ENUMMODE_EXIT">ENUMMODE_EXIT</a> (0) will cancel <a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>. <a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a> (1)
will continue. The parameters are handed over to the stack using the C
standard.<a name="CMD_TESTMODE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_TESTMODE (10)</td>
<td valign="top">Test a graphic mode<pre>int32_t modecode=VESA_600+HORFLAG2+VGA+COL80+BPS32; /* 800*600*16M */
<a href="#Setscreen">Setscreen</a>(-1,modecode,0x564E,CMD_TESTMODE);
</pre>
<br><br>

Only the <a href="003.html">BIOS</a> is initialised, and a screen test arrives with
colored wide lines.<br><br>

This function not exist inside the MilanTOS.<a name="CMD_COPYPAGE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_COPYPAGE (11)</td>
<td valign="top">Copy screenpage<pre>Vsetscreen(-1,0,0x564E,CMD_COPYPAGE);
Copy first screenpage to second screenpage
Vsetscreen(-1,1,0x564E,CMD_COPYPAGE);
Copy second screenpage to first screenpage
</pre>
<br><br>

This function not exist inside the MilanTOS.<a name="CMD_FILLMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_FILLMEM (12)</td>
<td valign="top">Fill memory on the graphics card<pre><a href="004015.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a> blk;
blk.size=sizeof(<a href="004015.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a>);
blk.blk_op = BLK_COPY;
blk.blk_color = 0x112233;  /* background fill color */

Vsetscreen(-1,&blk,0x564E,CMD_SETMEM);
if(blk.blk_status == <a href="004015.html#BLK_OK">BLK_OK</a>)
  puts("OK");
</pre>
<br><br>

Fill a block with a color with the GPU at (blk_x, blk_y), size is
blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="004015.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast.<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_COPYMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_COPYMEM (13)</td>
<td valign="top">Copy memory on the graphics card<pre><a href="004015.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a> blk;
blk.size=sizeof(<a href="004015.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a>);

Vsetscreen(-1,&blk,0x564E,CMD_COPYMEM);
if(blk.blk_status == <a href="004015.html#BLK_OK">BLK_OK</a>)
  puts("OK");
</pre>
<br><br>

Copy a block with the GPU at (blk_src_x, blk_src_y) to (blk_dst_x,
blk_dst_y), size is blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="004015.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast
when blk_x is blk_dst_x and blk_y is blk_dst_y.<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_TEXTUREMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_TEXTUREMEM (14)</td>
<td valign="top">Put texture in memory on the graphics card<pre><a href="004015.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a> blk;
blk.size=sizeof(<a href="004015.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a>);

Vsetscreen(-1,&blk,0x564E,CMD_TEXTUREMEM);
if(blk.blk_status == <a href="004015.html#BLK_OK">BLK_OK</a>)
  puts("OK");
</pre>
<br><br>

Copy a 65K texture from CPU local area to a 65K screen or an ARGB
texture to a 32M screen pixel format multiple times (best results are
with little source texture and big screen for destination).<br><br>

This function need a texture support inside the <a href="002.html">TOS</a>.
<br>This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_GETVERSION"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_GETVERSION (15)</td>
<td valign="top"><pre>/* if the function is not implemented, 0x0100 is the first release */
long version = 0x0100;
Vsetscreen(-1,&version,0x564E,CMD_GETVERSION);
</pre>
<br><br>

Return the version of the video <a href="004.html">XBIOS</a>.<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_LINEMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_LINEMEM (16)</td>
<td valign="top">Draw line on the graphics card<pre><a href="004015.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a> blk;
blk.size=sizeof(<a href="004015.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a>);
blk.blk_fbcolor = 0x112233;  /* foreground fill color */
blk.blk_bgcolor = 0;  /* background fill color */
blk.blk_pattern = 0xffffffff;  /* solid line */

Vsetscreen(-1,&blk,0x564E,CMD_LINEMEM);
if(blk.blk_status == <a href="004015.html#BLK_OK">BLK_OK</a>)
  puts("OK");
</pre>
<br><br>

Draw a line with colors with the GPU at (blk_x1, blk_y1) to
(blk_x2, blk_y2).<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_CLIPMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_CLIPMEM (17)</td>
<td valign="top">Set clipping rectangle on the graphic card<pre><a href="004015.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a> blk;
blk.size=sizeof(<a href="004015.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a>);
blk.blk_clip_on = 1; /* clipping flag 1:on,
                                      0:off */

Vsetscreen(-1,&blk,0x564E,CMD_CLIPMEM);
if(blk.blk_status == <a href="004015.html#BLK_OK">BLK_OK</a>)
  puts("OK");
</pre>
<br><br>

Enable or diable clipping rectange at (blk_x, blk_y), size is
blk_w, blk_h.<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_SYNCMEM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_SYNCMEM (18)</td>
<td valign="top">Wait an empty GPU fifo for sync the drawing engine with the
memory.<pre>Vsetscreen(-1,-1,0x564E,CMD_SYNCMEM);
</pre>
<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.<a name="CMD_BLANK"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">CMD_BLANK (19)</td>
<td valign="top">Blank / unblank screen.<pre>int32_t blank = 1; /* (0): unblank
                      (1): blank normal
                      (2): VSYNC suspend
                      (3): HSYNC suspend
                      (4): powerdown */
Vsetscreen(-1,blank,0x564E,CMD_BLANK);
</pre>
<br><br>

This function exists since the version 0x0101 of the video <a href="004.html">XBIOS</a>
and is not inside the MilanTOS.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Nothing (or current modecode in TOS mode)</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Only valid with internal TOS Radeon driver (PCI.HEX) for
the ct60 (2007-01-24).</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VSetscreen">VSetscreen</a> &nbsp; <a href="#Setscreen_2C_20Milan">Setscreen, Milan</a>

</td></tr>
</table>

<h3><a name="VgetRGB"></a>4.5.20 VgetRGB</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»VgetRGB« - RGB Wert einer Farbe ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">94</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void VgetRGB( int16_t index, int16_t count, int32_t *array );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion VgetRGB ermittelt die RGB-Werte für
<i>count</i> Farben ab dem Farbindex <i>index</i>. Die
resultierenden Werte werden in <i>array</i> abgelegt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VgetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VgetRGB"></a>4.5.20.1 Bindings für VgetRGB</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#VgetRGB">VgetRGB</a>( int16_t index, int16_t count, int32_t *array );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #94,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="VSetscreen"></a>4.5.21 VSetscreen</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»set screen« - initialisiert den Bildschirm.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">5</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void VSetscreen( void *laddr, void *paddr, int16_t rez, int16_t
mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die <a href="004.html">XBIOS</a>-Routine VSetscreen entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern. Es gilt:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Adresse des log. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Adresse des phys. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST-Niedrig</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST-Mittel</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST-Hoch</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">3 = benutzte Auflösung aus <i>mode</i></td>
</tr>
<tr>
  <td align="left" valign="top">mode</td>
  <td align="left" valign="top">modecode (siehe <a href="#Vsetmode">Vsetmode</a>)</td>
</tr>
</table>
</div>

<br><br>

Ein Wert von -1 bedeutet in diesem Zusammenhang, daß die
entsprechende Adresse bzw. Auflösung nicht verändert wird.<br><br>

<b>Hinweis:</b> Es sollte stets kontrolliert werden, ob
eventuelle Veränderungen wirklich erfolgreich ausgeführt werden
konnten. Bei einer Änderung der Auflösung wird automatisch der VT-52
Emulator initialisiert.<br><br>

Der zusätzliche Parameter <i>mode</i> steht nur zur Verfügung,
wenn der Cookie '<a href="003007.html#Cookie_2C_20_VDO">_VDO</a>' den Wert 0x00030000 oder größer hat.<br><br>

Beim <a href="002.html">TOS</a> des Milans gibt es zusätzliche Funktionen bei <a href="#Setscreen_2C_20Milan">Setscreen</a>,
entsprechendes gilt auch für den <a href="#Setscreen_2C_20ct60">ct60</a>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VSetscreen">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VSetscreen"></a>4.5.21.1 Bindings für VSetscreen</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#VSetscreen">VSetscreen</a>( void *laddr, void *paddr, int16_t rez, int16_t
mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mode,-(sp)   ; Offset 12
move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       14(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="VgetSize"></a>4.5.22 VgetSize</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»VgetSize« - Größe des Bildschirmpuffers ermitteln</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">91</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int32_t VgetSize( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion VgetSize ermittelt die Größe des
Bildschirmpuffers in Bytes für den Grafikmodus <i>mode</i>.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert die Größe des Bildschirmpuffers in Bytes
zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VgetSize">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VgetSize"></a>4.5.22.1 Bindings für VgetSize</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int32_t <a href="#VgetSize">VgetSize</a>( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mode,-(sp)    ; Offset 2
move.w    #91,-(sp)     ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="VsetMask"></a>4.5.23 VsetMask</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»VsetMask« - Transparenz für TrueColor setzen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">150</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void VsetMask( int16_t ormask, int16_t andmask, int16_t overlay
);</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion VsetMask setzt Masken, die benutzt werden,
um die durch die VDI-Funktion <a href="007004.html#vs_color">vs_color</a> gesetzten Farben zu
modifizieren. <a href="007004.html#vs_color">vs_color</a> ermittelt zu seinem Parameter einen RGB-Wert.
Dieser wird bitweise mit <i>ormask</i> verodert und mit
<i>andmask</i> verundet. Somit können Farben im True-Color-Modus
transparent erscheinen. Ist <i>overlay</i> ungleich Null, wird in den
Overlaymodus geschalten bzw. mit Null zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VsetMask">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetRGB">VsetRGB</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetMask"></a>4.5.23.1 Bindings für VsetMask</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#VsetMask">VsetMask</a>( int16_t ormask, int16_t andmask, int16_t overlay );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    overlay,-(sp) ; Offset 6
move.w    andmask,-(sp) ; Offset 4
move.w    ormask,-(sp)  ; Offset 2
move.w    #150,-(sp)    ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Vsetmode"></a>4.5.24 Vsetmode</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»Vsetmode« - Videohardwareregister setzen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">88</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">int16_t Vsetmode( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion Vsetmode programmiert das
Videohardwareregister der Falcon-Computer. Die Bits des Parameters
<i>mode</i> haben folgende Bedeutung:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="right" valign="top">0-2</td>
  <td align="left" valign="top">Anzahl der Farbebenen:</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">0 = 1 Ebene       2 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = 2 Ebenen      4 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">2 = 4 Ebenen     16 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">3 = 8 Ebenen    256 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">4 = 16 Ebenen 65536 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">Gesetzt:  Bildbreite mindestens 640 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: Bildbreite 320 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top">Gesetzt:  VGA-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: TV-Modus (auch Atari-SC-Monitore)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top">Gesetzt:  PAL-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: NTSC-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top">Gesetzt:  Overscan aktiv</td>
</tr>
<tr>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top">Gesetzt:  ST-kompatible Grafik</td>
</tr>
<tr>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top">Gesetzt:  Interlace-Modus aktiv</td>
</tr>
</table>
</div>

<a name="VM_INQUIRE"></a>
<br><br>

Wird als <i>mode</i> VM_INQUIRE (-1) übergeben erhält man die
aktuelle Auflösung, ohne das etwas verändert wird.<br><br>

<b>Hinweis:</b> Es findet keine Überprüfung auf die Richtigkeit
der Kodierung für den angeschlossenen Monitor statt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert den alten Inhalt des
Videohardwareregisters zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="Vsetmode.html#Bindings_20f_C3_BCr_20Vsetmode">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Vsetmode"></a>4.5.24.1 Bindings für Vsetmode</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

int16_t <a href="#Vsetmode">Vsetmode</a>( int16_t mode );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    mode,-(sp)    ; Offset 2
move.w    #88,-(sp)     ; Offset 0
trap      #14           ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="VsetRGB"></a>4.5.25 VsetRGB</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»VsetRGB« - RGB Wert einer Farbe setzen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">93</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void VsetRGB( int16_t index, int16_t count, int32_t *array );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion VsetRGB setzt die RGB-Werte für
<i>count</i> Farben ab dem Farbindex <i>index</i>. Die Farbwerte
sind in <i>array</i> abgelegt.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VsetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetRGB"></a>4.5.25.1 Bindings für VsetRGB</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#VsetRGB">VsetRGB</a>( int16_t index, int16_t count, int32_t *array );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #93,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="VsetSync"></a>4.5.26 VsetSync</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»VsetSync« - Art der Synchronisation setzen</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">90</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void VsetSync( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Funktion VsetSync legt fest, auf welche Art eine
Synchronisation erfolgen soll. Der Parameter <i>flag</i> wird wie
folgt kodiert:<br><br>


<div align="left">
<table border="0">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung für gesetzte Bits</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Externer Takt</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Vertikale Synchronisation</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Horizontale Synchronisation</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis zurück.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20VsetSync">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#Vsetmode">Vsetmode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetSync"></a>4.5.26.1 Bindings für VsetSync</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#VsetSync">VsetSync</a>( int16_t flag );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    flag,-(sp)   ; Offset 2
move.w    #90,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Vsync"></a>4.5.27 Vsync</h3>
<table>
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top">»vertical sync« - wartet auf das nächste vertikale
<a href="00500e.html#Sync">Sync</a>-Signal.</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top">37</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top">void Vsync( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">Die XBIOS-Routine Vsync wartet auf den nächsten
Bildschirm-Refresh (Vertical-Blank Interrupt). Damit ist es möglich,
Bildschirmoperationen mit dem Betriebssystem synchronisieren.<br><br>

<b>Hinweis:</b> Für zeitkritische Abfragen (Scrolling) sollte
besser direkt auf den Zeilenzähler im Shifter zurückgegriffen
werden.</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">Die Funktion liefert kein Ergebnis.</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top">Alle TOS Versionen</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"><a href="#Bildschirmfunktionen">Bildschirmfunktionen</a></td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"><a href="#Bindings_20f_C3_BCr_20Vsync">Binding</a>

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Vsync"></a>4.5.27.1 Bindings für Vsync</h4>
<table>
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">#include <tos.h><br><br>

void <a href="#Vsync">Vsync</a>( void );</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top"><pre>move.w    #37,-(sp)    ; Offset 0
trap      #14          ; <a href="004.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>


</td></tr>
</table>

<h3><a name="Konstanten_20zur_20Videohardware_20des_20Falcons"></a>4.5.28 Konstanten zur Videohardware des Falcons</h3>
<p>Zur vereinfachten Programmierung des Videohardwareregisters des
Falcons mittels der Funktion <a href="#Vsetmode">Vsetmode</a> sind in der Headerdatei tos.h
die folgenden Konstanten definiert, die mit | kombiniert werden:</p>

<pre>    #define VERTFLAG  0x0100  /* Interlace aktivieren          */
    #define STMODES   0x0080  /* ST-kompatible Grafik          */
    #define OVERSCAN  0x0040  /* Overscan aktivieren           */
    #define PAL       0x0020  /* PAL-Modus                     */
    #define FALC_VGA  0x0010  /* VGA-Modus                     */
    #define TV        0x0000  /* TV-Modus                      */

    #define COL80     0x0008  /* Bildbreite mind. 640 Pixel    */
    #define COL40     0x0000  /* Bildbreite 320 Pixel          */

    #define BPS16     4       /* 16 Farbebenen: 65536 Farben   */
    #define BPS8      3       /*  8 Farbebenen:   256 Farben   */
    #define BPS4      2       /*  4 Farbebenen:    16 Farben   */
    #define BPS2      1       /*  2 Farbebenen:     4 Farben   */
    #define BPS1      0       /*  1 Farbebenen:     2 Farben   */
</pre>
<p>Mit der folgenden Konstante kann die Anzahl der Farbebenen
ausmaskiert werden:</p>

<pre>    #define NUMCOLS   7       /* if (( mode & NUMCOLS ) == 0 ) */
                              /*   puts( "monochrome mode" );  */
</pre>
<hr>

<a id="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a><a id="UDO_nav_up_FOOT" href="004.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24"></a><a id="UDO_nav_lf_FOOT" href="004004.html"><img src="udo_lf.gif" alt="xbios-Trap" title="xbios-Trap" border="0" width="24" height="24"></a><a id="UDO_nav_rg_FOOT" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen-XBIOS-Erweiterung" title="CENTScreen-XBIOS-Erweiterung" border="0" width="24" height="24"></a></body>
</html>
